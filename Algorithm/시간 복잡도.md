# 시간 복잡도
- 알고리즘에서 시간 복잡도는 주어진 문제를 해결하기 위한 **연산 횟수**를 말한다.
- 일반적으로 수행 시간은 1억번의 연산을 1초의 시간으로 간주해서 예측한다.
	- 시간제한 2초 = 2억 연산 안에 답이 나와야한다.

## 1) 시간 복잡도 정의하기
### 시간 복잡도 유형
- 빅-오메가 : 최선일 때(best case)의 연산 횟수를 나타낸 표기법
- 빅-세타 : 보통일 때(average case)의 연산 횟수를 나타낸 표기법
- 빅-오 : 최악일 때(worst case)의 연산 횟수를 나타낸 표기법

#### 예시
```java
int findNumber = (int)(Math.random() * 100);
for(int i = 0; i < 100; i++) {
	if(i == findNumber) {
		System.out.prinln(i);
		break;
	}
}
```
- 빅-오메가 : 0이 나올 경우이므로, `1`번이다.
- 빅-세타 : 평균값이므로 `N/2`번이다.
- 빅-오 : 최악은 99이므로, `N번`이다.

## 2) 코딩 테스트에서 사용하는 시간 복잡도 유형은?
- 코딩 테스트에서는 최악인 경우를 염두해둬야 한다. 그러므로 빅-오(`O(n)`) 표기법을 사용한다.
- 다양한 테스트 케이스를 수행해 모든 케이스를 통과해야만 합격으로 판단하게 된다.

### 알고리즘 문제 풀이 시
1. 먼저 알맞은 알고리즘을 선택해야 한다.
2. 비효율적인 로직을 찾아서 효율적으로 바꿔야 한다.
	- 보통 이중 for문

## 3) 시간 복잡도 활용하기
- 백준 온라인 저지 2750번
- 개수가 100만 이라는 것을 생각하고, 시간 제한이 2초라는 것을 생각해야한다.
	- 시간 제한이 2초라는 것은 2억 번의 이하의 연산 횟수로 문제를 해결해야한다.
	- 시간 복잡도는 항상 최악일 때, 즉 데이터의 크기가 가장 클 때를 기준으로 한다.

### 연산 횟수 계산 방법
- 연산 횟수 = 알고리즘 시간 복잡도 * 데이터의 크기

### 알고리즘 적합성 평가
- 버블 정렬
	- `(1000000)^2 = 1000000000000 > 200000000`
	- 부적합 알고리즘
- 병합 정렬
	- `1000000log(1000000) = 약 20000000 < 200000000`
	- 적합 알고리즘
	- 약 0.2초만에 정렬된다.

## 4) 시간 복잡도를 바탕으로 코드 로직 개선하기
- 시간 복잡도는 작성한 코드의 비효율적인 로직을 개선하는 바탕으로 사용할 수 있다.
- 로직을 개선하려면 시간 복잡도를 도출할 수 있어야 한다.

### 시간 복잡도 도출 기준
1. 상수는 시간 복잡도 계산에서 제외한다.
2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.

#### 예시 1
```java
int N = 100000;
int cnt = 0;
for (int i = 0; i < N; i++) {
	System.out.println("연산 횟수 : " + cnt++);
}
```
- N은 100000이다.
- 단순 반복문으로 시간 복잡도는 `O(N)` 이다.

#### 예시 2
```java
int N = 100000;
int cnt = 0;
for (int i = 0; i < N; i++) {
	System.out.println("연산 횟수 : " + cnt++);
}

for (int i = 0; i < N; i++) {
	System.out.println("연산 횟수 : " + cnt++);
}

for (int i = 0; i < N; i++) {
	System.out.println("연산 횟수 : " + cnt++);
}
```
- 각각의 for문에서 10만번씩 30만번의 연산을 하게 된다.
	- `3N`
- 그러나 상수는 무시하므로 시간 복잡도는 `O(N)`이 된다.

#### 예시 3
```java
int N = 100000;
int cnt = 0;
for (int i = 0; i < N; i++) {
	for (int j = 0; j < N; j++) {
		System.out.println("연산 횟수 : " + cnt++);
	}
}
```
- 시간 복잡도는 가장 많이 중첩된 반복문을 기준으로 도출하므로 해당 이중 for 문은 전체 코드의 시간 복잡도 기준이 된다.
- N * N으로 `N^2`이 된다.
- 시간 복잡도는 `O(N^2)`이 된다.