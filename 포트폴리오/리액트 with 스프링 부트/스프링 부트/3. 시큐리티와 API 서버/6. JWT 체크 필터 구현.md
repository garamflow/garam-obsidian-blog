# JWT 체크 필터 구현
- JWT 문자열을 필터해줘야한다.
	- 필터 만들기
	- 어떤 경로로 들어왔을 때 필터할 건지
	- 잘못되었을 시 처리

## 1) JWT 필터 클래스 생성
- Access Token은 API 서버의 특정 경로를 접근하기 위해서 사용한다.
- HTTP 헤더 중 `Authorization` 항목의 값으로 전달해서 서버에서 이를 체크해서 사용한다.
	- `<타입> <토큰>` 형식으로 중간에 공백 문자로 구분된 값으로 구성된다.
	- JWT를 활용하면 `Bearer`라는 타입으로 지정된다.
- 서버에서 보호하려는 자원에 대해서 Access Token을 체크해서 유효한 경우에 접근을 허용하는 구현이 필요한데, 필터나 스프링 MVC의 인터셉터, 스프링 시큐리티의 필터를 활용해서 구현 가능하다.
- `security` 패키지에 `filter` 패키지를 추가해서 `JWTCheckFilter` 클래스를 추가한다.
- 또한 `JWTCheckFilter`를 `CustomSecurityConfig`에 추가해줘야한다.
```java
package org.mall.shoppingmallapi.security.filter;

import com.google.gson.Gson;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.log4j.Log4j2;
import org.mall.shoppingmallapi.util.JWTUtil;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Map;

@Log4j2
public class JWTCheckFilter extends OncePerRequestFilter {
    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {

        // true == not checking
        String path = request.getRequestURI();

        // false == check
        return false;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

		filterChain.doFilter(request, response);
    }
}
```
- `OncePerRequestFilter`
	- 모든 요청에 대해서 체크하려고 할 때 사용한다.
- `shouldNotFilter()`
	- 필터로 체크하지 않을 경로나 메소드 등을 지정하기 위해 사용한다.

```java
public class CustomSecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        ...
        http.addFilterBefore(new JWTCheckFilter(), UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
```

## 2) 필터를 통한 검증, 예외 처리하기
- `JWTCheckFilter`에서 `Preflight`로 전송되는 OPTIONS 방식이거나 로그인을 처리하는 경로, 첨부파일 이미지를 사용하는 경로 등에 대해서 체크하지 않도록 지정이 가능하다.

### (1) 예외 처리하기
```java
@Override
    protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {

        // Preflight요청은 체크하지 않음
        if(request.getMethod().equals("OPTIONS")){
            return true;
        }
        
        String path = request.getRequestURI();
        log.info("check uri.............." + path);
        
        //api/member/ 경로의 호출은 체크하지 않음
        if(path.startsWith("/api/member/")) {
            return true;
        }
        
        //이미지 조회 경로는 체크하지 않음
        if(path.startsWith("/api/productss/view/")) {
            return true;
        }
        return false;
    }
```

### (2) Access Token에 대한 예외 발생 여부 확인하기
- 정상적이라면 컨트롤러까지 호출이 가능하다.
- Access Token에 문제가 있다면 JSON으로 에러 메시지가 전송된다.
```java
@Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        String authHeaderStr = request.getHeader("Authorization");

        try {
            //Bearer accessToken...
            String accessToken = authHeaderStr.substring(7);
            Map<String, Object> claims = JWTUtil.validateToken(accessToken);
            log.info("JWT claims: " + claims);
            filterChain.doFilter(request, response);
        }catch(Exception e) {
            log.error("JWT Check Error..............");
            log.error(e.getMessage());
            Gson gson = new Gson();
            String msg = gson.toJson(Map.of("error", "ERROR_ACCESS_TOKEN"));
            response.setContentType("application/json");
            PrintWriter printWriter = response.getWriter();
            printWriter.println(msg);
            printWriter.close();
        }
    }
```

## 3) Postman으로 확인하기
- 정삭적인 Access Token과 만료된 Access Token으로 확인이 가능하다.
- Postman에서 상품 리스트를 확인하는 `/api/productss/list`에 요청을 보낼 때, Header에 Authorization을 추가해서 `Bearer 토큰값` 을 입력해주면 된다.