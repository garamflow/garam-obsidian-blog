# JWT와 @PreAuthorize 이용하기
## 1) @PreAuthorize를 통한 접근 권한 처리
- 스프링 시큐리티의 `@PreAuthorize`를 이용하면 특정한 권한을 가진 사용자만 접근 가능하도록 구성이 가능하다.
### (1) CustomSecurityConfig에 어노케이션 추가하기
```java
@EnableMethodSecurity
public class CustomSecurityConfig {
	...
```

### (2) 컨트롤러에서 각 메소드에 권한 설정하기
- 각 메소드에는 `@PreAuthorize`를 붙여서 특정 권한을 가진 사용자만 접근할 수 있도록 제한할 수 있다.
```java
@PreAuthorize("hasAnyRole('ROLE_USER','ROLE_ADMIN')")
    @GetMapping("/view/{fileName}")
    public ResponseEntity<Resource> viewFileGet(@PathVariable("fileName") String fileName) {
        return fileUtil.getFile(fileName);
    }
```

### (3) JWT 인증 정보를 활용해서 시큐리티 지정하기
- `JWTCheckFilter`에서 JWT 인증 정보를 활용해서 사용자를 구성하고 이를 시큐리티에 지정해줘야한다.
- 인증에 필요한 모든 정보를 JWT 토큰이 가지고 있으므로 활용해서 시큐리티에 필요한 객체를 구성한다.
```java
@Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        String authHeaderStr = request.getHeader("Authorization");

        try {
            String accessToken = authHeaderStr.substring(7);
            Map<String, Object> claims = JWTUtil.validateToken(accessToken);

            log.info("JWT claims: " + claims);
            String email = (String) claims.get("email");
            String password = (String) claims.get("password");
            String nickname = (String) claims.get("nickname");
            Boolean social = (Boolean) claims.get("social");
            List<String> roleNames = (List<String>) claims.get("roleNames");

            MemberDTO memberDTO = new MemberDTO( email, password, nickname, social.booleanValue(),
                    roleNames);

            log.info("-----------------------------------");
            log.info(memberDTO);
            log.info(memberDTO.getAuthorities());
            UsernamePasswordAuthenticationToken authenticationToken
                    = new UsernamePasswordAuthenticationToken(memberDTO,password,memberDTO.getAuthorities());
            SecurityContextHolder.getContext().setAuthentication(authenticationToken);
            filterChain.doFilter(request, response);

        }catch(Exception e) {
            log.error("JWT Check Error..............");
            log.error(e.getMessage());
            Gson gson = new Gson();
            String msg = gson.toJson(Map.of("error", "ERROR_ACCESS_TOKEN"));
            response.setContentType("application/json");
            PrintWriter printWriter = response.getWriter();
            printWriter.println(msg);
            printWriter.close();
        }
    }
```

## 2) 메소드 접근제한 예외 처리하기
- API 서버는 항상 호출한 애플리케이션에게 정확한 메시지를 전달해야하므로 접근 제한 상황에 대해서 예외 메시지를 전달해줘야한다.
### (1) 접근제한 예외에 대한 클래스 생성
```java
package org.mall.shoppingmallapi.security.handler;

import com.google.gson.Gson;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.log4j.Log4j2;
import org.springframework.http.HttpStatus;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.web.access.AccessDeniedHandler;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Map;

@Log4j2
public class CustomAccessDeniedHandler implements AccessDeniedHandler {
    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {
        Gson gson = new Gson();
        String jsonStr = gson.toJson(Map.of("error", "ERROR_ACCESSDENIED"));
        response.setContentType("application/json");
        response.setStatus(HttpStatus.FORBIDDEN.value());
        PrintWriter printWriter = response.getWriter();
        printWriter.println(jsonStr);
        printWriter.close();
    }
}
```

### (2) 핸들러를 CustomSecurityConfig에 연결하기
```java
public class CustomSecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        ...

        http.exceptionHandling(config -> {
            config.accessDeniedHandler(new CustomAccessDeniedHandler());
        });
        
        return http.build();
    }
```
- 유효시간이 지나지 않아도 권한이 없는 사용자가 가진 Access Token을 사용하는 경우 `ERROR_ACCESSDENIED` 라는 메시지를 전송해준다.