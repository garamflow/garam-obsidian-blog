# 상품 API 서버 구성하기
## 1) 업로드 설정하기
- 업로드에 관한 설정을 해주려면 `application.yml`에 추가적인 설정이 필요하다.
```yml
...
servlet:  
  multipart:  
    max-request-size: 30MB  
    max-file-size: 10MB
...

org:
  shopplingmall:
    upload:
      path: upload
```
- 파일 사이즈, 한 번에 받아들일 수 있는 양 등을 설정할 수 있다.
	- `max-file-size: 10MB`
		- multipart로 파일을 올릴 때, 한 파일의 사이즈가 10MB를 넘을 수 없다.
- 업로드는 폴더를 만들어 사용할 수도 있지만 별도의 서버를 만들어서 사용하는게 좋다.
- 현재는 따로 폴더를 만들어서 사용할 예정이다.
	- 나중에 nginx 와 같은 서버로 분리시켜주는 것을 추천한다.

## 2) ProductDTO 만들어주기
- DTO는 어떤 용도를 사용할 것인지 생각해야한다.
- `ProductDTO`는 상품 등록 및 조회할 때 사용할 예정이다.
	- 상품 등록 시, multipartFile이라고 업로드 파일을 처리해야하고
	- 상품 조회 시, 데이터베이스에 파일을 저장하면 안된다. 왜냐하면 DB는 많이 써서 속도도 느리고 성능도 효율적이지 않기 때문이다.
		- 조회 시에는 파일의 이름만 들어갈 것이다.
```java
package org.mall.shoppingmallapi.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.web.multipart.MultipartFile;

import java.util.ArrayList;
import java.util.List;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ProductDTO2 {
    private Long pno;

    private String pname;
    private int price;
    private String pdesc;

    // 실제로는 삭제하지 않고 플래그를 통해 삭제된 것 처럼 보여주게 하는 것
    private boolean delFlag;

    // 파일
    @Builder.Default
    private List<MultipartFile> files = new ArrayList<>();

    // 이미 데이터베이스에 올라가있는 파일 이름을 갖고올 때 사용
    @Builder.Default
    private List<String> uploadedFileName = new ArrayList<>();
}
```

## 3) 파일 업로드 처리하기
- controller에서 사용할 업로드 관련 기능들을 미리 만들어놓는다.
### (1) 경로 초기화 및 폴더 생성
- 먼저 업로드할 장소가 필요하므로 경로 설정 및 폴더 생성이 필요하다.
```java
package org.mall.shoppingmallapi.util;

import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.util.List;

@Component
@Log4j2
@RequiredArgsConstructor
public class CustomFileUtil {

    // 업로드 경로 초기화
    @Value("${org.shoppingmall.upload.path}")
    private String uploadPath;

    // 폴더 만들어주는 용도
    @PostConstruct
    public void init() {
        File tempFolder = new File(uploadPath);
        if(!tempFolder.exists()) {
            tempFolder.mkdir();
        }

        uploadPath = tempFolder.getAbsolutePath();
    }

    // controller에서 업로드할 때 사용할 것
    public List<String> saveFiles(List<MultipartFile> files) throws RuntimeException {
        return null;
    }
}
```

### (2) 파일 업로드 기능 구현하기
```java
...
public List<String> saveFiles(List<MultipartFile> files) throws RuntimeException {
    // 파일이 없거나 비어있으면 비어있는 리스트 반환
    if(files == null || files.size() == 0) {
        return List.of();
    }

	// 업로드된 파일 이름을 저장할 리스트
    List<String> uploadNames = new ArrayList<>();

	// 파일 저장 로직
    for(MultipartFile file: files) {
	    // 파일 이름 중복 방지를 위해 원본 이름 앞에 UUID를 붙인다.
        String savedName = UUID.randomUUID().toString() + "_" + file.getOriginalFilename();

		// 파일을 저장할 경로를 생성한다.
        Path savePath = Paths.get(uploadPath, savedName);

		// 파일을 저장한다.
        try {
	        // 원본 파일 업로드
	        // 파일의 입력 스트림으로부터 데이터를 읽어서 경로에 파일을 생성한다.
            Files.copy(file.getInputStream(), savePath);
            // 파일 저장 성공 시, 생성된 파일 이름을 리스트에 추가한다.
            uploadNames.add(savedName);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    return uploadNames;
}
```

## 4) 상품 컨트롤러 구현하기
```java
package org.mall.shoppingmallapi.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.mall.shoppingmallapi.dto.ProductDTO2;
import org.mall.shoppingmallapi.util.CustomFileUtil;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

@Controller
@Log4j2
@RequiredArgsConstructor
@RequestMapping("/api/products2")
public class ProductController2 {
    private final CustomFileUtil fileUtil;

    @PostMapping("/")
    public Map<String, String> register(ProductDTO2 productDTO) {
        log.info("register" + productDTO);

		// DTO 객체에서 업로도된 파일들을 가지고 온다.
        List<MultipartFile> files = productDTO.getFiles();
        // 파일들을 저장하고, 저장된 파일의 이름들을 리스트로 반환한다.
        List<String> uploadedFileNames = fileUtil.saveFiles(files);

        // 저장된 파일 이름을 설정한다.
        productDTO.setUploadedFileName(uploadedFileNames);
        log.info(uploadedFileNames);

        return Map.of("Result", "Success");
    }
}
```

## 5) 썸네일 처리하기
### (1) thumbnailator 추가하기
- 썸네일 처리할 때, 자주 쓰이는 라이브러리로 `build.gradle`에 추가해주자.
```
// https://mvnrepository.com/artifact/net.coobird/thumbnailator
implementation 'net.coobird:thumbnailator:0.4.20'
```

### (2) 썸네일 추가 시, 이름 변경 기능 추가하기
- 썸네일 처리는 그림 파일에만 적용되어야 하고, 이름 또한 달라야한다.
- `CustomFileUtil`에 기능을 추가해주자.
```java
for(MultipartFile file: files) {
    String savedName = UUID.randomUUID().toString() + "_" + file.getOriginalFilename();

    Path savePath = Paths.get(uploadPath, savedName);

    try {
        Files.copy(file.getInputStream(), savePath);

		// 파일의 MIME 타입을 반환한다.
        String contentType = file.getContentType();
        // 파일의 콘텐츠 타입이 null이 아니고 image로 시작하면 썸네일을 생성한다.
        if(contentType != null && contentType.startsWith("image")) {  
            // 썸네일 파일 이름은 원본 파일 이름 앞에 s_를 붙여서 구분한다.
            Path thumbnailPath = Paths.get(uploadPath, "s_" + savedName);

            // 썸네일의 크기는 200x200픽셀이고 생성된 썸네일은 지정된 경로에 파일로 저장된다.
            Thumbnails.of(savePath.toFile()).size(200, 200).toFile(thumbnailPath.toFile());
        }
        ...
```
