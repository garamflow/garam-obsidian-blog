# 상품 API 서버 구성하기
## 1) 업로드 설정하기
- 업로드에 관한 설정을 해주려면 `application.yml`에 추가적인 설정이 필요하다.
```yml
...
servlet:  
  multipart:  
    max-request-size: 30MB  
    max-file-size: 10MB
...

org:
  shopplingmall:
    upload:
      path: upload
```
- 파일 사이즈, 한 번에 받아들일 수 있는 양 등을 설정할 수 있다.
	- `max-file-size: 10MB`
		- multipart로 파일을 올릴 때, 한 파일의 사이즈가 10MB를 넘을 수 없다.
- 업로드는 폴더를 만들어 사용할 수도 있지만 별도의 서버를 만들어서 사용하는게 좋다.
- 현재는 따로 폴더를 만들어서 사용할 예정이다.
	- 나중에 nginx 와 같은 서버로 분리시켜주는 것을 추천한다.

## 2) ProductDTO 만들어주기
- DTO는 어떤 용도를 사용할 것인지 생각해야한다.
- `ProductDTO`는 상품 등록 및 조회할 때 사용할 예정이다.
	- 상품 등록 시, multipartFile이라고 업로드 파일을 처리해야하고
	- 상품 조회 시, 데이터베이스에 파일을 저장하면 안된다. 왜냐하면 DB는 많이 써서 속도도 느리고 성능도 효율적이지 않기 때문이다.
		- 조회 시에는 파일의 이름만 들어갈 것이다.
```java
package org.mall.shoppingmallapi.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.web.multipart.MultipartFile;

import java.util.ArrayList;
import java.util.List;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ProductDTO2 {
    private Long pno;

    private String pname;
    private int price;
    private String pdesc;

    // 실제로는 삭제하지 않고 플래그를 통해 삭제된 것 처럼 보여주게 하는 것
    private boolean delFlag;

    // 파일
    @Builder.Default
    private List<MultipartFile> files = new ArrayList<>();

    // 이미 데이터베이스에 올라가있는 파일 이름을 갖고올 때 사용
    @Builder.Default
    private List<String> uploadedFileName = new ArrayList<>();
}
```

## 3) 파일 업로드 처리하기
- controller에서 사용할 업로드 관련 기능들을 미리 만들어놓는다.
### (1) 경로 초기화 및 폴더 생성
- 먼저 업로드할 장소가 필요하므로 경로 설정 및 폴더 생성이 필요하다.
```java
package org.mall.shoppingmallapi.util;

import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.util.List;

@Component
@Log4j2
@RequiredArgsConstructor
public class CustomFileUtil {

    // 업로드 경로 초기화
    @Value("${org.shoppingmall.upload.path}")
    private String uploadPath;

    // 폴더 만들어주는 용도
    @PostConstruct
    public void init() {
        File tempFolder = new File(uploadPath);
        if(!tempFolder.exists()) {
            tempFolder.mkdir();
        }

        uploadPath = tempFolder.getAbsolutePath();
    }

    // controller에서 업로드할 때 사용할 것
    public List<String> saveFiles(List<MultipartFile> files) throws RuntimeException {
        return null;
    }
}
```

### (2) 파일 업로드 기능 구현하기
```java
...
public List<String> saveFiles(List<MultipartFile> files) throws RuntimeException {
    // 파일이 없거나 비어있으면 비어있는 리스트 반환
    if(files == null || files.size() == 0) {
        return List.of();
    }

	// 업로드된 파일 이름을 저장할 리스트
    List<String> uploadNames = new ArrayList<>();

	// 파일 저장 로직
    for(MultipartFile file: files) {
	    // 파일 이름 중복 방지를 위해 원본 이름 앞에 UUID를 붙인다.
        String savedName = UUID.randomUUID().toString() + "_" + file.getOriginalFilename();

		// 파일을 저장할 경로를 생성한다.
        Path savePath = Paths.get(uploadPath, savedName);

		// 파일을 저장한다.
        try {
	        // 원본 파일 업로드
	        // 파일의 입력 스트림으로부터 데이터를 읽어서 경로에 파일을 생성한다.
            Files.copy(file.getInputStream(), savePath);
            // 파일 저장 성공 시, 생성된 파일 이름을 리스트에 추가한다.
            uploadNames.add(savedName);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    return uploadNames;
}
```

## 4) 상품 컨트롤러 구현하기
```java
package org.mall.shoppingmallapi.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.mall.shoppingmallapi.dto.ProductDTO2;
import org.mall.shoppingmallapi.util.CustomFileUtil;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

@Controller
@Log4j2
@RequiredArgsConstructor
@RequestMapping("/api/products2")
public class ProductController2 {
    private final CustomFileUtil fileUtil;

    @PostMapping("/")
    public Map<String, String> register(ProductDTO2 productDTO) {
        log.info("register" + productDTO);

		// DTO 객체에서 업로도된 파일들을 가지고 온다.
        List<MultipartFile> files = productDTO.getFiles();
        // 파일들을 저장하고, 저장된 파일의 이름들을 리스트로 반환한다.
        List<String> uploadedFileNames = fileUtil.saveFiles(files);

        // 저장된 파일 이름을 설정한다.
        productDTO.setUploadedFileName(uploadedFileNames);
        log.info(uploadedFileNames);

        return Map.of("Result", "Success");
    }
}
```

## 5) 썸네일 처리하기
### (1) thumbnailator 추가하기
- 썸네일 처리할 때, 자주 쓰이는 라이브러리로 `build.gradle`에 추가해주자.
```
// https://mvnrepository.com/artifact/net.coobird/thumbnailator
implementation 'net.coobird:thumbnailator:0.4.20'
```

### (2) 썸네일 추가 시, 이름 변경 기능 추가하기
- 썸네일 처리는 그림 파일에만 적용되어야 하고, 이름 또한 달라야한다.
- `CustomFileUtil`에 기능을 추가해주자.
```java
for(MultipartFile file: files) {
    String savedName = UUID.randomUUID().toString() + "_" + file.getOriginalFilename();

    Path savePath = Paths.get(uploadPath, savedName);

    try {
        Files.copy(file.getInputStream(), savePath);

		// 파일의 MIME 타입을 반환한다.
        String contentType = file.getContentType();
        // 파일의 콘텐츠 타입이 null이 아니고 image로 시작하면 썸네일을 생성한다.
        if(contentType != null && contentType.startsWith("image")) {  
            // 썸네일 파일 이름은 원본 파일 이름 앞에 s_를 붙여서 구분한다.
            Path thumbnailPath = Paths.get(uploadPath, "s_" + savedName);

            // 썸네일의 크기는 200x200픽셀이고 생성된 썸네일은 지정된 경로에 파일로 저장된다.
            Thumbnails.of(savePath.toFile()).size(200, 200).toFile(thumbnailPath.toFile());
        }
        ...
```

## 6) 업로드 파일 조회 구현하기
- 조회는 실제 파일이 아니라 파일 데이터를 전달해주는 것이다.
	- 리소스 데이터를 전달한다.
	- 전송해주는 데이터의 MIME type을 지정해줘야한다.
- API 서버가 파일까지 제공해줘야되느냐에 대해서는 설계 이슈가 있다.
	- 실제로는 파일 서버가 따로 있다고 보면 된다.
- 해당 부분에 대한 Controller도 따로 만들어주는 것도 좋다.
```java
public ResponseEntity<Resource> getFile(String fileName) {

    Resource resource = new FileSystemResource(uploadPath + File.separator + fileName);

    if (!resource.isReadable()) {
        resource = new FileSystemResource(uploadPath + File.separator + "default.jpeg");
    }

    HttpHeaders headers = new HttpHeaders();

    try {
        headers.add("Content-Type", Files.probeContentType(resource.getFile().toPath()));
    } catch (IOException e) {
        throw new RuntimeException(e);
    }

    return ResponseEntity.ok().headers(headers).body(resource);
}
```
- `Resource resource = new FileSystemResource(uploadPath + File.separator + fileName);`
	- 요청 받은 파일 이름에 해당하는 파일 리소스를 생성한다.
	- `FileSystemResource` : 파일 시스템의 특정 파일을 나타내는 Spring의 `Resource`의 구현체
	- `uploadPath` : 파일이 저장된 디렉토리 경로
	- `File.separator` : 시스템에 따른 디렉토리 구분자('/') 또는 ('\\') 를 사용한다.
	- `fileName` : 메소드에 전달된 파일 이름
- `resource.isReadable()`
	- 리소스가 실제로 존재하고 읽을 수 있는 지 확인한다.
- `new FileSystemResource(uploadPath + File.separator + "default.jpeg");`
	- 파일이 존재하지 않거나 읽을 수 없을 경우, 기본 이미지로 대체한다.
- `Files.probeContentType(resource.getFile().toPath())`
	- 파일의 MIME 타입을 추론해서 적절한 `Content-Type`을 헤더에 설정한다.
		- JPEG 파일의 경우 `image/jpeg`
- `ResponseEntity.ok().headers(headers).body(resource);`
	- `ResponseEntity.ok()` : 상태 코드 200(OK)의 `ResponseEntity` 빌더를 생성한다.
	- `.headers(headers)` : HTTP 헤더를 응답에 포함시킨다.
	- `.body(resource)` : 클라이언트에 반환될 `Resource` 객체를 설정한다. `Resource` 는 요청된 파일 혹은 요청된 파일이 읽을 수 없는 경우 기본 이미지 리소스이다.

## 7) 업로드 파일 삭제 구현하기
- 상품 데이터가 사라질 수 있으니 삭제 기능도 필요하다.
- DB에서 직접 사라지는 게 아니라 컬럼값만 변경하면 된다.
```java
public void deleteFiles(List<String> fileNames) {
    if(fileNames == null || fileNames.size() == 0) return;

    fileNames.forEach(fileName -> {

		// 썸네일 파일 이름 구성하기
        String thumbnameFileName = "s_" + fileName;
        // 썸네일 파일의 전체 경로 설정
        Path thumbnailPath = Paths.get(uploadPath, thumbnameFileName);
        // 원본 파일의 전체 경로 설정
        Path filePath = Paths.get(uploadPath, fileName);

        try {
	        // 지정된 경로에 파일이 존재하는 경우 해당 파일 삭제
            Files.deleteIfExists(filePath);
            Files.deleteIfExists(thumbnailPath);
        } catch (IOException e) {
            throw new RuntimeException(e.getMessage());
        }
    });
}
```

## 8) 상품 엔티티 처리하기
- 상품의 경우 연관된 관계가 ManyToOne을 쓰는 경우가 많다.
- 그러나 상품과 이미지의 관계는 ManyToOne 보다는 `@ElementCollection`을 사용하는 게 더 좋다.
	- `@ElementCollection`은 ID가 없다.
	- 상품 엔티티에서 상품 이미지를 같이 관리하게 된다.

### (1) 상품 이미지 엔티티 만들기
```java
package org.mall.shoppingmallapi.domain;

import jakarta.persistence.Embeddable;
import lombok.*;

@Embeddable
@Getter
@ToString
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ProductImage {
    private String fileName;
    // 순번
    private int ord;  

    public void setOrd(int ord) {
        this.ord = ord;
    }
}
```
- `@Embeddable` : 해당 클래스의 인스턴스가 다른 엔티티에 내장될 수 있음을 나타낸다.

### (2) 상품 Entity 만들기
```java
package org.mall.shoppingmallapi.domain;

import jakarta.persistence.*;
import lombok.*;

import java.util.ArrayList;
import java.util.List;

@Entity
@Getter
@Table(name= "tbl_product")
@Builder
@AllArgsConstructor
@NoArgsConstructor
@ToString(exclude = "imageList")
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long pno;

    private String pname;
    private int price;
    private String pdesc;
    private boolean delFlag;

    @ElementCollection
    @Builder.Default
    private List<ProductImage> imageList = new ArrayList<>();

    public void changePrice(int price) {
        this.price = price;
    }

    public void changeDesc(String desc) {
        this.pdesc = desc;
    }
 
    public void changeName(String name) {
        this.pname = name;
    }

    // 이미지에 대한 관리도 해당 엔티티가 맡는다.
    public void addImage(ProductImage image) {
        image.setOrd(imageList.size());
        imageList.add(image);
    }

    // DB에 저장하는 방법이
    // 파일을 저장, 문자열을 저장
    public void addImageString(String fileName) {
        ProductImage productImage = ProductImage.builder()
                .fileName(fileName)
                        .build();
        addImage(productImage);
    }

    // 상품 삭제 시
    public void clearList() {
        this.imageList.clear();
    }
}
```

## 9) 상품 레포지토리 생성하기
```java

```