# 스프링부트와 API 서버
- 처음에 프로젝트를 만들면 에러가 난다.
- 왜냐하면 데이터베이스에 관한 설정을 추가해줘야되기 때문이다.

## 1) 데이터베이스 만들기 및 사용자 만들고 권한 주기
- 먼저 MySQL의 root 계정으로 접속해준다.
```mysql
create database shoppingmallapidb;  
  
create user 'apidbuser'@'localhost' identified by 'apidbuser';  
create user 'apidbuser'@'%' identified by 'apidbuser';  
  
grant all privileges on shoppingmallapidb.* to 'apidbuser'@'localhost';  
grant all privileges on shoppingmallapidb.* to 'apidbuser'@'%';
```
- 위와 같이 데이터베이스를 만들어주고 사용자를 만들고 권한을 설정해준다.
- IntelliJ에서 새로운 데이터 소스 만들기에 들어간다. (데이터 소스 및 드라이버)
	- 왼쪽 위 + 를 통해서 mysql 데이터 소스를 새롭게 만든다.
	- 데이터베이스를 shoppingmallapidb로 설정해준다.
	- 사용자는 위에서 만든 apidbuser와 비밀번호도 적어준다.
	- 테스트 후 적용-확인
- 데이터 베이스를 만들고서 `select now();`를 통해 현재 시간과 일치하는지 확인해줘야한다.

### application.yml 수정하기
```groovy
spring:  
  datasource:  
    url: "jdbc:mysql://localhost:3306/shoppingmallapidb"  
    username: "apidbuser"  
    password: "apidbuser"  
    driver-class-name: com.mysql.cj.jdbc.Driver  
  jpa:  
    hibernate:  
      ddl-auto: update  
    properties:  
      hibernate:  
        show_sql: true  
        format_sql: true  
        dialect: org.hibernate.dialect.MySQL8Dialect
```
- 스프링부트는 Hikaricp를 사용한다.
```shell
2024-02-06T12:26:11.997+09:00  INFO 24353 --- [  restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2024-02-06T12:26:12.353+09:00  INFO 24353 --- [  restartedMain] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@4485e6f8
2024-02-06T12:26:12.356+09:00  INFO 24353 --- [  restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
```
- yml은 처음에 기본 설정을 잘 해줘야한다.
	- 위에 yml의 기본 설정은 커넥션풀이다.
		- 커넥션 풀: 커넥션을 미리 만들어주고 재사용하는 방식
	- 그런데 AWS를 사용하면 너무 많이 만들기 때문에 커넥션 풀의 초기 크기, 타임아웃을 설정해줘야한다.
		- 타임아웃 : SQL이 어느정도 시간이 지나도 동작을 안하면 버려버리게 한다.
- `ddl-auto`
	- 테이블이 없으면 만들어주고 있으면서 변경되면 alter로 테이블을 변경한다.

## 2) 엔티티 클래스 만들기
- 엔티티
	- 엔티티 클래스
		- 우리가 지금 만드는 것
	- 엔티티 객체
- 테이블을 먼저 만드는 경우가 있지만 JPA를 쓸 경우에는 엔티티를 먼저하는 걸 추천한다.
- 엔티티를 만들어주고 이제 레포지토리를 만들어준다.
- 그다음에는 테스트 코드를 만들어준다.
```java
package org.mall.shoppingmallapi.domain;  
  
import jakarta.persistence.Entity;  
import jakarta.persistence.GeneratedValue;  
import jakarta.persistence.GenerationType;  
import jakarta.persistence.Id;  
import lombok.*;  
  
import java.time.LocalDate;  
  
@Entity  
@ToString  
@Getter  
@Builder  
@AllArgsConstructor  
@NoArgsConstructor  
public class ProductEntity {  
  
    @Id  
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    private Long id;  
  
    private String name;  
    private String description;  
    private Double price;  
    private Integer stockQuantity;  
    private String ImageUrl;  
    private LocalDate uploadDate;  
}
```
## 3) 엔티티 테스트 코드
- 테스트 코드를 만들 때는 build.gradle의 dependencies에서 확인할 수 있는, lombok과 annotationProcessor에서 추가를 해줘야할게 있다.
```
dependencies {
	...
	testCompileOnly 'org.projectlombok:lombok'
	testAnnotationProcessor 'org.projectlombok:lombok'
}
```
- 위와 같이 작성해줘야 테스트할 시 log4j 등을 사용할 수 있다.
- repository를 테스트할 것이니, `test.org.mall.shoppingmallapi.repository` 패키지 내부에 repositor이름 + Tests 를 붙인 이름으로 클래스를 만들어준다.
- `@DataJpaTest` 등 좋은 테스트를 써도 되지만 `@SpringBootTest`와 `@Log4j2`를 통해 로그도 찍어볼 것이다.
- 보통 insert, read, update 정도를 테스트 해준다.
	- 업데이트의 경우 로딩해서 `setter`로 변경해줘야해서 엔티티에 setter를 추가해줘야한다.
```java
@SpringBootTest  
@Log4j2  
public class ProductRepositoryTests {  
  
    @Autowired  
    private ProductRepository productRepository;  
  
    @Test  
    public void test1() {  
        Assertions.assertNotNull(productRepository);  
        log.info(productRepository.getClass().getName());  
    }  
  
    @Test  
    public void testInsert() {  
        ProductEntity product = ProductEntity.builder()  
                .name("A")  
                .description("many")  
                .price(100.0)  
                .stockQuantity(2)  
                .ImageUrl("test")  
                .uploadDate(LocalDate.parse("2020-10-10"))  
                .build();  
  
        ProductEntity result = productRepository.save(product);  
        log.info(result);  
    }  
  
    @Test  
    public void testRead() {  
        Long id = 1L;  
        Optional<ProductEntity> result = productRepository.findById(id);  
        ProductEntity product = result.orElseThrow();  
        log.info(product);  
    }  
  
    @Test  
    public void testUpdate() {  
        Long id = 1L;  
        Optional<ProductEntity> result = productRepository.findById(id);  
        ProductEntity product = result.orElseThrow();  
  
        product.setName("bbb");  
        product.setDescription("change");  
        product.setStockQuantity(2);  
        product.setPrice(200.0);  
        product.setImageUrl("assdf");  
        product.setUploadDate(LocalDate.parse("2010-10-10"));  
  
        productRepository.save(product);  
    }  
}
```

## 4) 목록 (페이징) 처리 구현
- `Pageable` 인터페이스를 페이징 처리를 위해서 사용할 수 있다.
- 페이징 처리는 데이터베이스로부터 데이터 조회 시, 전체 데이터를 한 번에 가져오는 게 아니라, 페이지 단위로 나누어서 일정량만 가져오는 기법을 말한다.
- 서버 메모리 사용량을 줄이고, 사용자에게 데이터를 더 빠르게 제공할 수 있다.
- `Pageable` 인터페이스는 페이지 번호, 크기, 정렬 방식 등 페이징 처리에 필요한 정보를 제공한다.
- 단, 주의 사항으로는 페이지 번호는 0부터 시작한다. 즉, 첫 번째 페이지는 0이다.
- `Pagealbe` 을 사용하는 메소드는 `Page<T>` 타입의 객체를 반환하며, 조회된 데이터와 데이터 수, 페이지 번호, 페이지 크기 등의 정보를 포함하고 있다.
```java
@Test  
public void testPaging() {
    Pageable pageable = PageRequest.of(0, 10, Sort.by("id").descending());

    Page<ProductEntity> result = productRepository.findAll(pageable);

    log.info(result.getTotalElements());
    log.info(result.getContent());
}
```

## 5) Querydsl 설정하기
- 검색과 같은 동적 처리를 하기 위해서 querydsl을 사용할 것이다.
	- querydsl보다는 jooq를 사용하는 것도 좋지만 한국은 기본적으로 querydsl을 쓴다.
- querydsl을 사용하기 위해서는 먼저 build.gradle에 설정을 추가해줘야한다.
```
buildscript {  
    ext {  
        queryDslVersion = '5.0.0'  
    }  
}
...

dependencies {  
    ...
  
    implementation "com.querydsl:querydsl-jpa:${queryDslVersion}:jakarta"
    annotationProcessor(
            "jakarta.persistence:jakarta.persistence-api",
            "jakarta.annotation:jakarta.annotation-api",
            "com.querydsl:querydsl-apt:${queryDslVersion}:jakarta"
    )
}

...

compileJava.dependsOn('clean')
```
- 다시 gradle을 빌드하고서 정상적으로 적용되었는지 확인하기 위해서 IntelliJ 옆에 gradle 메뉴를 열어본다.
	- `Tasks/other/compileJava` 가 있는데 해당 컴파일자바를 실행시킨다.
	- 제대로 실행되었는지 확인하기 위해서 프로젝트의 `build.generated.sources.annotationProcessor.java.main....` 밑에 `Q~~~` 파일이 정상적으로 있는지 확인해주자.

### Quqerydsl 사용하기
- 컴파일자바를 통해 생성된 `Q`가 붙은 파일은 `Qdomain`이라고 부른다.
- 이제 동적 처리를 하는 검색을 위한 파일을 생성해줘야한다.
- repository 패키지 내부에 search라는 패키지를 생성해주고, `ProductSearch` 라는 인터페이스를 생성해주자.
```java
package org.mall.shoppingmallapi.repository.search;  
  
import org.mall.shoppingmallapi.domain.ProductEntity;  
import org.springframework.data.domain.Page;  
  
public interface ProductSearch {  
  
    Page<ProductEntity> search1();  
}
```
- querydsl을 사용하려면 인터페이스를 `ProductSearch` 라고 했으면 클래스는 `ProductSearchImpl` 이라고 정확히 붙여줘야한다.
```java
package org.mall.shoppingmallapi.repository.search;  
  
import org.mall.shoppingmallapi.domain.ProductEntity;  
import org.springframework.data.domain.Page;  
import org.springframework.data.jpa.repository.support.QuerydslRepositorySupport;  
  
public class ProductSearchImpl extends QuerydslRepositorySupport implements ProductSearch {  
      
    public ProductSearchImpl() {  
        super(ProductEntity.class);  
    }  
  
    @Override  
    public Page<ProductEntity> search1() {  
        return null;  
    }  
}
```
- 이 때, 생성자는 그냥 class를 사용해준다.
- 