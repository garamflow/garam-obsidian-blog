# 스프링부트와 API 서버
- 처음에 스프링부트 프로젝트를 만들면 에러가 난다.
- 왜냐하면 데이터베이스에 관한 설정을 추가해줘야되기 때문이다.

## 1) 데이터베이스 만들기 및 사용자 만들고 권한 주기
### (1) 데이터베이스 생성 및 사용자 만들고 권한 주기
- 먼저 MySQL의 root 계정으로 접속해준다.
```mysql
create database shoppingmallapidb;

create user 'apidbuser'@'localhost' identified by 'apidbuser';
create user 'apidbuser'@'%' identified by 'apidbuser';

grant all privileges on shoppingmallapidb.* to 'apidbuser'@'localhost';
grant all privileges on shoppingmallapidb.* to 'apidbuser'@'%';
```
- 위와 같이 데이터베이스를 만들어주고 사용자를 만들고 권한을 설정해준다.
 
### (2) 만들어둔 데이터베이스 사용하기
- IntelliJ에서 새로운 데이터 소스 만들기에 들어간다. (데이터 소스 및 드라이버)
- 왼쪽 위에  "+" 를 통해서 mysql 데이터 소스를 새롭게 만든다.
- 데이터베이스를 shoppingmallapidb로 설정해준다.
- 사용자는 위에서 만든 apidbuser와 비밀번호도 적어준다.
- 테스트 후 성공하면 "적용", "확인"
- 데이터 베이스를 만들고서 `select now();`를 통해 현재 시간과 일치하는지 확인해줘야한다.

## 2) `application.yml` 수정하기
- 데이터베이스에 접속까지 했다면 이제 스프링부트와 데이터베이스를 연결시켜줘야한다.
- `application.yml` 또는 `application.properties` 를 통해서 설정해주자.
```groovy
// application.yml

spring:
  datasource:
    url: "jdbc:mysql://localhost:3306/shoppingmallapidb"
    username: "apidbuser"
    password: "apidbuser"
    driver-class-name: com.mysql.cj.jdbc.Driver
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        show_sql: true
        format_sql: true
        dialect: org.hibernate.dialect.MySQL8Dialect
```
- application.yml은 커넥션 풀을 사용한다.
- AWS를 사용 할 때, 커넥션 풀을 너무 많이 만드는 경우가 있을 수 있으므로 초기 크기, 타임아웃을 설로이 필요할 수 도 있다.
	- 타임아웃 : SQL이 어느정도 시간이 지나도 동작을 안하면 버려버린다.
- `ddl-auto`
	- 테이블이 없으면 만들고 있는데 변경되면 alter로 테이블을 변경시킨다.

### HikariCP
- 스프링부트는 데이터베이스 연결관리를 위해 HikariCP 라이브러리를 기본 커넥션 풀로 사용한다.
- 커넥션 풀은 데이터베이스와의 연결을 관리하는 컴포넌트로 애플리케이션이 데이터베이스에 연결 요청할 때마다 새로운 연결 생성 대신에, 미리 생성해둔 연결들을 풀(pool)에서 가져와 사용한다.
- 사용이 끝나면 연결을 다시 풀에 반환하는 방식으로 작동한다.
- 이런 식으로 연결 생성 및 소멸에 소요되는 시간과 자원 절약이 가능하다.

```shell
2024-02-06T12:26:11.997+09:00  INFO 24353 --- [  restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2024-02-06T12:26:12.353+09:00  INFO 24353 --- [  restartedMain] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@4485e6f8
2024-02-06T12:26:12.356+09:00  INFO 24353 --- [  restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
```

## 3) 엔티티 클래스 만들기
- 엔티티는 주의해야할 게 크게 두 가지 종류가 있다고 생각하면 된다.
	- 엔티티 클래스 : 지금 만들 것
	- 엔티티 객체
- 테이블을 먼저 만드는 경우가 있지만 JPA를 쓸 경우에는 엔티티를 먼저하는 걸 추천한다.
- 엔티티 생성 - 레포지토리 생성 - 테스트코드 작성 의 순서를 기억해두면 편하다.

### (1) 엔티티 클래스 생성
```java
package org.mall.shoppingmallapi.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.*;

import java.time.LocalDate;

@Entity
@ToString
@Getter
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ProductEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String description;
    private Double price;
    private Integer stockQuantity;
    private String ImageUrl;
    private LocalDate uploadDate;
}
```
- 엔티티는 `domain`이라는 패키지 혹은 `entity` 라는 패키지안에 따로 분류해서 만들어준다.

## 4) 엔티티에 연관된 레포지토리 만들어주기
- 해당 엔티티를 테스트해주기 위해서는 repository가 필요하다.
- `repository` 패키지 내부에 


## 5) 엔티티 테스트 코드 작성해주기
### (1)`build.gradle` 추가 설정해주기
- 테스트 코드를 만들 때는 `build.gradle`의 `dependencies`에 추가할 코드가 있다.
```
dependencies {
	...
	testCompileOnly 'org.projectlombok:lombok'
	testAnnotationProcessor 'org.projectlombok:lombok'
}
```
- 위와 같이 작성해줘야 테스트할 시 log4j 등을 사용할 수 있다.

### (2)테스트 코드 작성하기
- repository를 테스트할 것이니, `test.org.mall.shoppingmallapi.repository` 패키지 내부에 repository이름 + Tests 를 붙인 이름으로 클래스를 만들어준다.
- `@DataJpaTest` 등 좋은 테스트를 써도 되지만 `@SpringBootTest`와 `@Log4j2`를 통해 로그도 찍어볼 것이다.
- 보통 insert, read, update, delete를 테스트하는데, delete는 문제가 생길 가능성이 조금 있다.
	- 업데이트의 경우 로딩해서 `setter`로 변경해줘야해서 엔티티에 setter를 추가해줘야한다.
```java
@SpringBootTest
@Log4j2
public class ProductRepositoryTests {

    @Autowired
    private ProductRepository productRepository;

    @Test
    public void test1() {
        Assertions.assertNotNull(productRepository);
        log.info(productRepository.getClass().getName());
    }

    @Test
    public void testInsert() {
        ProductEntity product = ProductEntity.builder()
                .name("A")
                .description("many")
                .price(100.0)
                .stockQuantity(2)
                .ImageUrl("test")
                .uploadDate(LocalDate.parse("2020-10-10"))
                .build();

        ProductEntity result = productRepository.save(product);
        log.info(result);
    }

    @Test
    public void testRead() {
        Long id = 1L;
        Optional<ProductEntity> result = productRepository.findById(id);
        ProductEntity product = result.orElseThrow();
        log.info(product);
    }

    @Test
    public void testUpdate() {
        Long id = 1L;
        Optional<ProductEntity> result = productRepository.findById(id);
        ProductEntity product = result.orElseThrow();

        product.setName("bbb");
        product.setDescription("change");
        product.setStockQuantity(2);
        product.setPrice(200.0);
        product.setImageUrl("assdf");
        product.setUploadDate(LocalDate.parse("2010-10-10"));

        productRepository.save(product);
    }
}
```

## 6) 목록 (페이징) 처리 구현
### (1) 페이징 처리
- 페이징 처리란 데이터베이스로부터 데이터 조회 시, 일정한 양의 데이터만을 선택적으로 가져오는 기법을 말한다.
- 대용량 데이터를 다루는 애플리케이션에서 필요하다.
	- 성능 향상 : 필요한 데이터만을 작은 단위로 나누어 로드해서 메모리 사용량을 줄여서 성능 개선이 가능하다.
	- 사용자 경험 개선 : 한 번에 너무 많은 정보를 보는 것보다 덜 부담스럽고 효율적이여서 사용자 경험을 개선할 수 있다.
	- 리소스 관리 : 서버와 클라이언트 모두에서 리소스 사용 최적화가 가능하다. 요청된 페이지만큼의 데이터만 처리하고 클라이언트는 요청안 데이터만 로딩해서 보여주면 된다.

### (2) JPA에서 페이징 처리하기
#### `Pageable` 인터페이스
- `Pageable` 인터페이스를 활용해서 페이징 처리를 할 수 있다.
- `Pageable` 인터페이스는 페이지 번호, 크기, 정렬 방식 등 페이징 처리에 필요한 정보를 제공한다.
- 단, 주의 사항으로는 페이지 번호는 0부터 시작한다. 즉, 첫 번째 페이지는 0이다.
- `Pagealbe` 을 사용하는 메소드는 `Page<T>` 타입의 객체를 반환하며, 조회된 데이터와 데이터 수, 페이지 번호, 페이지 크기 등의 정보를 포함하고 있다.

#### `Pageable` 인터페이스 사용하기
```java
@Test  
public void testPaging() {
    Pageable pageable = PageRequest.of(0, 10, Sort.by("id").descending());

    Page<ProductEntity> result = productRepository.findAll(pageable);

    log.info(result.getTotalElements());
    log.info(result.getContent());
}
```
- `Pageable pageable = PageRequest.of(0, 10, Sort.by("id").descending());`
	- `PageRequest.of()` 메소드를 사용해서 페이지 번호, 페이지 크기, 정렬 조건을 지정할 수 있다.
	- 첫 번째 페이지의 데이터 10개를 `id` 필드 기준으로 내림차순 정렬해서 요청하는 `Pageable` 객체를 생성한다.
	- 0은 첫 번째 페이지를 의미한다.
- `productRepository.findAll(pageable);`
	- 생성된 `Pageable` 객체에 맞춰 데이터를 조회한다.
	- 반환된 `Page<ProductEntity>` 객체는 조회된 데이터 목록뿐 아니라 페이징 처리에 필요한 추가 정보 (총 데이터 수, 페이지 수 등)를 포함한다.
- `result.getTotalElements()`
	- 페이징 처리된 전체 결과 집합의 크기, 즉 데이터베이스에 저장된 `ProductEntity`의 총 개수를 반환한다.
- `result.getContent()`
	- 현재 페이지에 해당하는 `ProductEntity` 객체의 데이터.

## 7) Querydsl 설정 및 사용하기
### (1) Querydsl을 사용하는 이유
- 컴파일 시간에 쿼리의 타입 안전성을 검사해서 실행 시간에 발생하는 오류를 최소화할 수 있다.
- 쿼리를 자바 코드 형태로 작성할 수 있어서, SQL 문자열을 직접 작성하는 것보다 가독성이 좋고 유지 보수성도 높다.
- 조건에 따라 다른 쿼리를 생성해야 하는 상황에서 쉽게 구성할 수 있어서 유연성을 제공한다.

### (2) Querydsl 사용하기 위한 세팅
- 검색과 같은 동적 처리를 하기 위해서 querydsl을 사용할 것이다.
	- querydsl보다는 jooq를 사용하는 것도 좋지만 한국은 기본적으로 querydsl을 쓴다.
- querydsl을 사용하기 위해서는 먼저 build.gradle에 설정을 추가해줘야한다.
```
buildscript {  
    ext {  
        queryDslVersion = '5.0.0'  
    }  
}
...

dependencies {  
    ...
  
    implementation "com.querydsl:querydsl-jpa:${queryDslVersion}:jakarta"
    annotationProcessor(
            "jakarta.persistence:jakarta.persistence-api",
            "jakarta.annotation:jakarta.annotation-api",
            "com.querydsl:querydsl-apt:${queryDslVersion}:jakarta"
    )
}

...

compileJava.dependsOn('clean')
```
- gradle을 빌드하고서 정상적으로 적용되었는지 확인하기 위해서 IntelliJ 옆에 gradle 메뉴를 열어본다.
	- `Tasks/other/compileJava` 가 있는데 컴파일 자바를 실행시킨다.
	- 제대로 실행되었는지 확인하기 위해서 프로젝트의 `build.generated.sources.annotationProcessor.java.main....` 밑에 `Q~~~` 파일이 정상적으로 있는지 확인해주자.
	- 컴파일자바를 통해 생성된 `Q`가 붙은 파일은 `Qdomain`이라고 부른다.

### (3) Querydsl 사용하기 - 검색 관련 파일 생성
#### 검색 인터페이스 생성하기
- 검색을 위한 파일을 생성해줘야한다.
- repository 패키지 내부에 search라는 패키지를 생성해주고, `ProductSearch` 라는 인터페이스를 생성해주자.
```java
package org.mall.shoppingmallapi.repository.search;

import org.mall.shoppingmallapi.domain.ProductEntity;
import org.springframework.data.domain.Page;

public interface ProductSearch {

    Page<ProductEntity> search1();
}
```

#### 검색 클래스 생성하기
- querydsl을 사용하려면 인터페이스를 `ProductSearch` 라고 했으면 클래스는 `ProductSearchImpl` 이라고 정확히 붙여줘야한다.
	- 실제 일을 해주는 객체
```java
package org.mall.shoppingmallapi.repository.search;

import org.mall.shoppingmallapi.domain.ProductEntity;
import org.springframework.data.domain.Page;
import org.springframework.data.jpa.repository.support.QuerydslRepositorySupport;

@Log4j2
public class ProductSearchImpl extends QuerydslRepositorySupport implements ProductSearch {

    public ProductSearchImpl() {
        super(ProductEntity.class);
    }

    @Override
    public Page<ProductEntity> search1() {
        return null;
    }
}
```
- 생성자는 그냥 class를 사용해준다.

#### `ProductRepository`에 검색 인터페이스 적용해주기
```java
public interface ProductRepository extends JpaRepository<ProductEntity, Long>, ProductSearch {}
```
- 이제 ProductRepository에도 해당 인터페이스를 적용해줘야한다.

### (4) Querydsl 사용하기 - 검색 메소드 작성하기
- `ProductSearch` 인터페이스에서 `search1()` 메소드에 대해서 작성해주자.
- querydsl을 이용해서 사용하는 방식이다.
	- 인터넷 검색 시 나오는 코드들이 예전 방식인 경우도 많고, 변화가 빠른 편이라서 정석적인 방법을 사용하자.
```java
@Override
public Page<ProductEntity> search1() {

    log.info("search1-------------------------------");

    // 쿼리를 날리기 위한 객체
    QProductEntity product = QProductEntity.productEntity;

    // JPQL 쿼리
    JPQLQuery<ProductEntity> query = from(product);

    // 리턴타입이 프리디케이트, true값에 가까운
    query.where(product.name.contains("1"));

    // paging 처리하기
    Pageable pageable = PageRequest.of(1, 10, Sort.by("id").descending());
    this.getQuerydsl().applyPagination(pageable, query)

    // 쿼리 실행 (목록 데이터 가져오기)
    query.fetch();

    // 쿼리 실행 (Long 타입)
    query.fetchCount();

    return null;
}
```

#### 테스트 코드 작성
- 위 코드들을 테스트하는 것도 작성해주자.
```java
@Test
public void testSearch1() {
    productRepository.search1();
}
```

## 8) DTO 설정
### (1) DTO
- querydsl의 목적은 동적인 쿼리를 만들고 처리하는 것이다.
- 이 때, 동적 쿼리를 위해서 필요한 데이터는 DTO로 받는다.
- 서비스 계층은 기본적으로 파라미터와 리턴은 DTO가 맞다고 보는 시각도 있다.
- 특히 JPA는 엔티티를 JPA에서 관리를 하고 있는 객체로, DB라고 생각하는게 좋다.
	- 많은 것을 돌아다니지 않게 처리해야한다.
	- mybatis는 jdbc 결과만 가져다가 mybatis로 매핑해서 사용하는 것이다.
- 엔티티는 JPA에서 관리하고 서비스나 레포지토리는 스프링에서 관리하는데 DTO는 아무도 관리하지 않는다.
- 엔티티는 테이블과 관련 있으나 DTO는 관련 없다.
- 오히려 업무와 관련 있다. 상황에 따라 여러개를 만들어도 된다.

### (2) DTO 만들기
- DTO를 만들 때 기본적으로 엔티티와 똑같이 만들면 되는데, 변경이 자유롭게 getter, setter를 다 만들어준다.
- DTO를 엔티티로 바꾸고 엔티티를 DTO로 바꾸는 경우가 생길 수 있다.
	- 해당사항의 경우 서비스 계층에서 변환하는 작업을 하는게 좋다.
```java
package org.mall.shoppingmallapi.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ProductDTO {
    private Long id;
    private String name;
    private String description;
    private Double price;
    private Integer stockQuantity;
    private String ImageUrl;
    private LocalDate uploadDate;
}
```

## 7) 서비스 계층 만들기
- 서비스 계층을 만들 때, 트랜잭션을 설정하는 게 중요하다.
- 일단은 `@Transactional`은 인터페이스에 걸어줘도 된다.

### (1) 서비스 인터페이스
```java
package org.mall.shoppingmallapi.service;

import org.mall.shoppingmallapi.domain.ProductEntity;
import org.mall.shoppingmallapi.dto.ProductDTO;
import org.springframework.transaction.annotation.Transactional;

@Transactional
public interface ProductService {

    ProductDTO getProduct(Long id);

    // product entity -> dto
    default ProductDTO entityToDTO(ProductEntity product) {
        return ProductDTO.builder()
                .id(product.getId())
                .name(product.getName())
                .description(product.getDescription())
                .price(product.getPrice())
                .stockQuantity(product.getStockQuantity())
                .ImageUrl(product.getImageUrl())
                .uploadDate(product.getUploadDate())
                .build();
    }

    // product dto -> entity
    default ProductEntity dtoToEntity(ProductDTO productDTO) {
        return ProductEntity.builder()
                .id(productDTO.getId())
                .name(productDTO.getName())
                .description(productDTO.getDescription())
                .price(productDTO.getPrice())
                .stockQuantity(productDTO.getStockQuantity())
                .ImageUrl(productDTO.getImageUrl())
                .uploadDate(productDTO.getUploadDate())
                .build();
    }
}
```

### (2) 서비스 클래스
```java
@Service
@Log4j2
@RequiredArgsConstructor
public class ProductServiceImpl implements ProductService {

    private final ProductRepository productRepository;

    @Overrid
    public ProductDTO getProduct(Long id) {

        Optional<ProductEntity> result = productRepository.findById(id);
        ProductEntity productEntity = result.orElseThrow();

        return entityToDTO(productEntity);
    }
}
```

- 중간에 테스트 코드를 작성해주면 더 좋다.
```java
package org.mall.shoppingmallapi.service;

import lombok.extern.log4j.Log4j2;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
@Log4j2
public class ProductServiceTests {

    @Autowired
    ProductService productService;

	@Test
    public void testGetProduct() {
        Long id = 1L;
        log.info(productService.getProduct(id));
    }
}
```