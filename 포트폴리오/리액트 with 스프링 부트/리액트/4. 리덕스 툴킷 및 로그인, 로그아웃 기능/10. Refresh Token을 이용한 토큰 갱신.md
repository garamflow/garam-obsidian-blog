# Refresh Token을 이용한 토큰 갱신
## 1) Refresh Token을 이용한 자동 갱신
- 유효 기간이 지난 Access Token이 있다면 API 서버 호출 시 에러가 발생한다.
- 유효 기간이 지나면 사용자가 록인 결과로 받은 Refresh Token을 이용해서 자동으로 Access Token을 개싱해줘야한다.
	- 사일런트 리프레쉬 (silent refresh)
- Access Token에 문제가 생기면 리액트에서 갖고 있는 Refresh Token으로 `/api/member/refresh` 경로를 호출해서 Access Token을 갱신해줘야 한다.

## 2) Refresh API 호출하기
- `jwtUtil.js`에 Access Token, Refresh Token으로 `/api/member/refresh`를 호출하는 함수를 추가한다.
```javascript
const refreshJWT = async (accessToken, refreshToken) => {
  const host = API_SERVER_HOST;
  const header = { headers: { 'Authorization': `Bearer ${accessToken}` } };
  const res = await axios.get(`${host}/api/member/refresh?refreshToken=${refreshToken}`, header);
  return res.data;
};
```

## 3) beforeRes() 에 refreshJWT() 적용하기
- `beforeRes()`에서 응답 데이터가 `ERROR_ACCESS_TOKEN`와 같이 Access Token 관련된 메시지인 경우에는 Refresh Token을 활용해서 다시 호출한다.
```javascript
const beforeRes = async (res) => {
  const data = res.data;

  if (data && data.error === 'ERROR_ACCESS_TOKEN') {
    const memberCookieValue = getCookie('member');

    const result = await refreshJWT(memberCookieValue.accessToken, memberCookieValue.refreshToken);

    memberCookieValue.accessToken = result.accessToken;
    memberCookieValue.refreshToken = result.refreshToken;

    setCookie('member', JSON.stringify(memberCookieValue), 1);
  };

  return res;
};
```

## 4) 갱신된 토큰 저장 및 재호출
- 만료된 Access Token을 사용했을 때 자동으로 Refresh Token을 사용하게 되었으니 갱신된 토큰들을 다시 저장하고 원래 원했던 호출을 다시 시도해야한다.
- 원래 호출하려던 API 서버의 경로를 다시 호출하게 해줘야한다.
```javascript
const beforeRes = async (res) => {
  const data = res.data;

  if (data && data.error === 'ERROR_ACCESS_TOKEN') {
    const memberCookieValue = getCookie('member');

    const result = await refreshJWT(memberCookieValue.accessToken, memberCookieValue.refreshToken);

    memberCookieValue.accessToken = result.accessToken;
    memberCookieValue.refreshToken = result.refreshToken;

    setCookie('member', JSON.stringify(memberCookieValue), 1);

    const originalReqeust = res.config;

    originalReqeust.headers.Authorization = `Bearer ${result.accessToken}`;

    return await axios(originalReqeust);
  };

  return res;
};
```

## 5) 토큰에 따른 예외 처리하기
- Axios를 이용한 호출에서 예외 처리가 필요한 상황은 Access Token이 아예 없거나 권한이 없어서 문제가 발생하는 경우이다.
- 이에 대한 처리를 React-Router를 이용하거나 만들어뒀던 `useCustomLogin` 훅을 이용해서 처리할 수 있다.
- 해당 함수를 이용해서 권한 없는 사용자가 `/product/list`에 접속하면 경고창이 뜨게 만들어준다.
```javascript
// src/hooks/useCustomLogin.js
import { Navigate, createSearchParams, useNavigate } from 'react-router-dom';
...

  ...
  const exceptionHandle = (exception) => {
    const errorMsg = exception.response.data.error;

    const errorStr = createSearchParams({ error: errorMsg }).toString();

    if (errorMsg === 'REQUIRE_LOGIN') {
      alert('로그인 해야 합니다.');
      navigate({ pathname: '/member/login', search: errorStr });
      return;
    };

    if (exception.response.data.error === 'ERROR_ACCESSDENIED') {
      alert('권한이 없습니다.');
      navigate({ pathname: '/member/login', search: errorStr });
      return;
    };
  };

  return { loginState, isLogin, doLogin, doLogout, moveToPath, moveToLogin, moveToLoginReturn, exceptionHandle }
}

export default useCustomLogin;
```

```javascript
...
const ListComponent = () => {

  const { exceptionHandle } = useCustomLogin();
  const { moveToList, moveToDetail, page, size, refresh } = useCustomMove();

  const [serverData, setServerData] = useState(initState);
  const [fetching, setFetching] = useState(false);

  useEffect(() => {
    setFetching(true);
    getList({ page, size }).then(data => {
      setServerData(data);
      setFetching(false);
    }).catch(error => exceptionHandle(error));
  }, [page, size, refresh]);
  ...
```