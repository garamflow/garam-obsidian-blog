# React-Router
- 웹 애플리케이션이므로 리액트 프로젝트를 시작할 때는 라우터에 대한 기본 골격을 설정하고서 만들어야한다.
- 어떤 페이지가 있는가, 어디를 통해서 어떤 페이지로 이동하는가 등을 미리 생각해야한다.

## 1) react-router-dom 설치 및 셋팅

### (1) react-router-dom 설치
```shell
npm install react-router-dom
```

### (2) react-router-dom 세팅
```javascript
// src/router/root.js

import { createBrowserRouter } from 'react-router-dom';
import MainPage from '../pages/MainPage';

const root = createBrowserRouter([
	{
		path: '',
		element: <MainPage />
	},
])

export default root;
```

```javascript
// App.js

import { RouterProvider } from 'react-router-dom';
import root from './router/root';

function App() {
	return (
		<RouterProvider router={root} />
	);
}

export default App;
```

```javascript
// src/pages/MainPage.js

import React from 'react';

function MainPage() {
	return (
		<div className={'text-3xl'}>
			<div>Main Page</div>
		</div>
	);
}

export default MainPage;
```

## 2) 코드 스플리팅 (+ Link 컴포넌트)
- SPA 리액트 애플리케이션은 초기 실행 시간이 오래 걸리는 게 단점이다.
- 그래서 성능 최적화를 위해서 여러 개의 청크로 나눠서 실제로 필요한 시점에만 특정 부분을 로드하기 위해서 코드 스플리팅을 사용한다.
- 초기 로딩이 감소하고 사용자 경험이 향상되는 효과를 기대할 수 있다.
- 예시)
	- MainPage에 접속하면 네트워크에서 MainPage 부분만 다운받고, 그외는 다운받지 않는다.
	- 그외 페이지로 이동하면 추가로 다운받게 되고, 뒤로가기로 MainPage에 접속하면 이전에 다운받았던 페이지 정보를 이용한다.

```javascript
// src/router/root.js

import { Suspense, lazy } from 'react';
import { createBrowserRouter } from 'react-router-dom';

const Loading = <div>Loading...</div>;
const Main = lazy(() => import("../pages/MainPage"));
const About = lazy(() => import("../pages/AboutPage"));

const root = createBrowserRouter([
	{
		path: '',
		element: <Suspense fallback={Loading}><Main /></Suspense>
	},
	{
		path: 'about',
		element: <Suspense fallback={Loading}><About /></Suspense>
	}
]);

export default root;
```

### Link 컴포넌트
- react-router를 이용할 때는 `a` 태그가 아니라 `Link` 컴포넌트를 이용해야한다.
- 그 이유는 리액트는 SPA로 브라우저 주소창을 통해 컴포넌트를 출력하는데, 주소창 변겨은 애플리케이션 전체 로딩과 처리를 의미하기 때문이다.
- 그래서 SPA에서는 새 창을 열거나 새로고침하는 부분에 대해서 주의해야한다.

### 페이지 컴포넌트를 이용한 레이아웃
- React-Router를 이용해서 페이지 간 이동처럼 컴포넌트를 처리할 수 있다.
- `Link` 등으로 브라우저 새로고침을 최소화하고, 페이지 간 이동을 할 수 있다.
- 공통 레이아웃을 템플릿을 구성하면 메뉴 구조로 재사용 가능한 링크를 처리할 수 있다.

## 3) 공통 레이아웃 적용하기
- `children`을 통해서 기본 골격을 입혀주면 메뉴 화면 등 공통 레이아웃을 적용하기 좋다.
- `src/layouts/BasicLayout.js` 파일을 만들어서 기본 골격이 될 레이아웃을 만들어준다.
	- `BasicLayout`은 props로 `children`을 받는다.
	- 해당 `children`은 배열이며, pages에 있는 페이지를 받을 것이다.
- `pages`에 있는 페이지를 `<BasicLayout><div>MainPage</div></BasicLayout>`와 같이 감싸주면 `children`으로 해당 메인페이지의 div가 넘아갈 것이다.

## 4) Outlet을 통한 서브 메뉴 만들기
- 우선 세부 메뉴를 통해 필요한 페이지는 상품 목록 페이지, 상품 등록 페이지, 상품 조회 페이지, 상품 수정/삭제 페이지 등이 필요하다.
- 해당 상품 관련 페이지들을 고유의 레이아웃이 필요하다. 그 때 필요한 것이 Outlet이다.
- `pages/product/indexPage.js` 라는 파일을 만들자
```javascript
...
const indexPage = () => {

	return (
		<BasicLayout>
			<div className="w-full flex m-2 p-2 ">
				<div className="text-xl m-1 p-2 w-20 font-extrabold text-center underline">LIST</div>
				
				<div className="text-xl m-1 p-2 w-20 font-extrabold text-center underline">ADD</div>		
			</div>
			<div className="flex flex-wrap w-full">	
				<Outlet />
			</div>
		</BasicLayout>
	);
}
...
```
- 위와 같이 `BasicLayout`으로 감싸주고 내부에 `Outlet`을 만들어주자.
- `src/pages/product/ProductListPage.js` 를 만들어주자.
	- 해당 페이지는 딱히 `BasicLayout`으로 감싸줄 필요가 없다.
- `src/router/root.js`에서 해당 페이지들의 라우터를 설정해주자.
```javascript
{
	path: 'product',
	element: <Suspense fallback={Loading}><ProductIndex /></Suspense>,
	children: [
		{
			path: 'list',
			element: <Suspense fallback={Loading}><ProductList /></Suspense>
		}
	]
}
```
- 위와 같이 `/product/` 주소로 접속하면 `ProductIndex` 페이지가 접속할 수 있고, Outlet으로 설정해둔 자리에 들어갈 페이지를 `children` 배열로 넣어주면 해당 페이지는 `BasicLayout`과 `ProductIntext`페이지에 감싸져있는 세부 페이지로 이동하게 된다. 해당 페이지는 `/product/list/` 주소로 접속하면 들어갈 수 있다.

## 5) Router 나누기
- `root.js` 에서 `product`에 관한 `children`이 점점 더 길이지면 코드가 복잡해지니까 따로 함수로 빼주도록 한다.
```javascript
// src/router/productRouter.js

import { Suspense, lazy } from 'react';

const Loading = <div>Loading...</div>;
const ProductList = lazy(() => import('../pages/product/ProductListPage'));

const productRouter = () => {
	return [
		{
			path: 'list',
			element: <Suspense fallback={Loading}><ProductList /></Suspense>
		}
	]
} 

export default productRouter;
```

```javascript
// src/router/root.js

{
	path: 'product',
	element: <Suspense fallback={Loading}><ProductIndex /></Suspense>,
	children: productRouter()
}
```

## 6) 리다이렉트를 위한 Navigate
- 조건부 렌더링 사용 시 `Navigate`를 통해서 리다이렉트를 이용할 수 있다.
- `replace` 옵션을 사용하면 해당 주소로 이동하게 된다.
```javascript
const productRouter = () => {
return [
		{
			path: '',
			element: <Navigate replace={true} to={'list'} />
		},
		{
			path: 'list',
			element: <Suspense fallback={Loading}><ProductList /></Suspense>
		},
	]
}
```
- 위 코드는 `localhost:3000/product/`에 접속하면 `localhost:3000/product/list`로 이동하게 된다.
- 이제 로그인 하지 않았다면 로그인 페이지로 replace 되게 만들어주는 식으로 구현할 수 있다.

## 7) 경로값 추출을 위한 useParams
```javascript
{
	path: 'detail/:no',
	element: <Suspense fallback={Loading}><ProductDetailPage /></Suspense>
}
```
- 위와 같이 `:no` 라는 식으로 경로를 지정한 다음에 해당 페이지에 들어갔을 때의 페이지 컴포넌트에 `useParams`를 찍어보면 해당 `no`에 값을 알 수 있다.
- url 뒤의 쿼리스트링의 경로를 알 수 있다.

## 8) 가변적인 쿼리스트링 처리를 위한 useSearchParams
- 쿼리스트링의 가변적인 값들을 알아내기 위해서는 useSearchParams를 이용한다.
```javascript
const ProductListPage = () => {

	const [queryParams] = useSearchParams();
	const category = queryParams.get('category') ? parseInt(queryParams.get('category')) : 1;
	const page = queryParams.get('page') ? parseInt(queryParams.get('page')) : 1;  

return (
		<div>
		ProductListPage
		{category}, {page}
		</div>
	)
}
```

## 9) 동적 데이터 처리를 위한 useNavigate
- useNavigate를 통해서 동적 데이터 처리로 이동하는 경우를 처리할 수 있다.
```javascript
const navigate = useNavigate();

const handleClickList = useCallback(() => {
	navigate({ pathname: 'list' });
}, []);

const handleClickAdd = useCallback(() => {
	navigate({ pathname: 'add' });
}, []);
```

## 10) 동적 페이지 이동
- 조회화면에서 뭔가를 클릭하면 매번 다른 번호로 이동할 것이다.
- props로 써야되는 것과 router로 써야되는 것을 구분해야한다.
- 