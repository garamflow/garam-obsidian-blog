# 리액트와 API 서버 통신
## 1) Ajax를 위한 Axios 설정
- `npm install axios`
	- 기본이 json이라서 json 데이터를 다룰 때 편하다.
- async 함수의 모든 리턴은 비동기여서 promise이다.
- `useEffect`
	- 비동기 통신으로 인해 상태 변화가 생기고 컴포넌트가 다시 리렌더링되는게 반복될 수 있다.
	- 그래서 `useState`와 `useEffect`를 이용해 어떤 조건에서만 호출하게 만들 수 있다.

## 2) 조회 기능 구현하기
- 상품 하나에 대한 상세 조회에 대해서 컴포넌트를 만들고, 해당 컴포넌트를 페이지에 적용해야 한다.

```javascript

```


## 3) 네비게이션 관련 커스텀 훅 만들기
```javascript
import { createSearchParams, useNavigate, useSearchParams } from 'react-router-dom'

const getNum = (param, defaultValue) => {
	if (!param) {
		return defaultValue
	}
	return parseInt(param)
}

const useCustomMove = () => {
	const navigate = useNavigate();
	const [queryParams] = useSearchParams();

	const page = getNum(queryParams.get('page'), 1);
	const size = getNum(queryParams.get('size'), 10);

	const queryDefault = createSearchParams({ page, size }).toString();
	
	const moveToList = (pageParam) => {
		let queryStr = "";

		if (pageParam) {
			const pageNum = getNum(pageParam.get('page'), 1);
			const sizeNum = getNum(pageParam.get('size'), 10);
			
			queryStr = createSearchParams({ page: pageNum, size: sizeNum }).toString();
	
		} else {
			queryStr = queryDefault;
		}

		navigate({ pathname: '../list', search: queryStr });
	}
	return { moveToList }
}

export default useCustomMove
```

## 4) 수정 페이지로 이동하기
- 상세 조회 페이지에서 수정 페이지로 이동할 수 있어야 한다.
- 해당 부분도 `useCustomMove` 에 만들어준다.
```javascript
const moveToModify = (id) => {
	navigate({
		pathname: `../modify/${id}`,
		search: queryDefault
	})
}
...
return { moveToList, moveToModify, page, size }
...
```

## 5) 목록 처리하기

### (1) 
- 리스트 컴포넌트를 만들어줘서 해당 컴포넌트에서 처리해줄 것이다.

### (2) 목록 페이징 처리하기
- 리스트 밑에 페이지 번호 컴포넌트를 추가할 것이다.
- 해당 컴포넌트는 공통 컴포넌트이므로 `common` 이라는 폴더에 새로 만들어주자.
```javascript
import React from 'react'

const PageComponent = ({ serverData, movePage }) => {
	return (
		<div className="m-6 flex justify-center">
			{serverData.prev ? <div className="m-2 p-2 w-16 text-center font-bold text-blue-400" onClick={() => movePage({ page: serverData.prevPage })}>
				Prev
			</div> : <></>}

		{serverData.pageNumberList.map(pageNum =>
			<div key={pageNum} className={`m-2 p-2 w-12 text-center rounded shadow-md text-white ${serverData.current === pageNum ? 'bg-gray-500' : 'bg-blue-400'}`} onClick={() => movePage({ page: pageNum })}>
				{pageNum}
			</div>
		)}

		{serverData.next ? <div className="m-2 p-2 w-16 text-center font-bold text-blue-400" onClick={() => movePage({ page: serverData.nextPage })}>
			Next
		</div> : <></>}
		</div>
	)
}

export default PageComponent
```

```javascript
// ListComponent

		<PageComponent serverData={serverData} movePage={moveToList} />
	</div>
)
}
```
### (3) 동일 페이지 클릭 처리하기
- 동일 페이지를 클릭해도 반응이 없는데, 이 부분은 `useEffect`에서 `page, size`가 동일하기 때문이다.
	- ajax가 똑같은 것인줄 알고 데이터를 안가지고 올 수 있다.
- 그래서 그 조건을 만들어줘서 클릭했을 때, true와 false를 왔다갔다 해주는 조건을 만들어줘서 똑같은 페이지를 클릭해도 그대로 동작하게 해주면 된다.

```javascript
const useCustomMove = () => {
	const navigate = useNavigate();
	const [refresh, setRefresh] = useState(false);
...

	const moveToList = (pageParam) => {
		...
		setRefresh(!refresh);
	}
	...

	return { moveToList, moveToModify, page, size, refresh }
}
```

```javascript
const ListComponent = () => {
	const { page, size, refresh, moveToList } = useCustomMove();
	...

	useEffect(() => {
		...
	}, [page, size, refresh]);
```

## 6) 상세 페이지로 이동하기
- 리스트 페이지에서 상세 페이지로 이동하게 해줘야 한다.

### (1) detail 페이지로 이동하는 기능 구현
- 이동하는 기능은 계속해서 `useCustomMove`에서 만들어준다.
```javascript
	...
	const moveToDetail = (number) => {
		navigate({
		pathname: `../detail/${number}`,
		search: queryDefault
	})
	...
}
```
- number를 받는 이유는 어떤 게시판을 만들던 페이징 기능을 만들 때 똑같이 쓸 수 있기 때문이다.

### (2) 리스트 컴포넌트에 기능 연결하기
```javascript

```