# 1. HTTP 트랜잭션
- HTTP는 요청과 응답이 하나의 묶음을 이루도록 설계되어 있다.
- 이 묶음을 **HTTP 트랜잭션** 이라 한다.

## 1) HTTP 트랜잭션 확인하기
- 일반적으로 웹 클라이언트는 웹 브라우저이며, HTTP의 경우 아래 그림처럼 반드시 클라이언트가 먼저 요청을 하고 서버가 그에 대한 응답을 한다.

![서버가 클라이언트의 HTTP 요청에 응답하는 과정](/media/서적/이것이%20취업을%20위한%20백엔드%20개발이다%20with%20자바/Part%2002.%20백엔드%20개발을%20위한%20필수%20기본%20지식/Chapter%2008.%20서버와%20클라이언트의%20약속,%20HTTP/서버가%20클라이언트의%20HTTP%20요청에%20응답하는%20과정.png)

- 정적 리소스를 제외한 클아이언트의 요청과 서버의 응답 사이에 HTTP 요청 처리 과정이 추가되기도 한다.

### (1) 개발자 도구를 통한 HTTP 트랜잭션 확인
- 개발자 도구를 켜놓고서 웹 페이지에 접속한다.
- \[Network] 탭에서 확인할 수 있다.
- HTTP 트랜잭션에 대한 내용을 볼 수 있다.

#### 각 탭의 역할
- Headers: HTTP 헤더에 대한 정보를 보여 준다. 요청, 응답 헤더를 나눠 볼 수 있다.
- Payload: 데이터 전송에 포함되는 내용의 데이터를 의미한다. HTTP 요청은 헤더와 바디 부분으로 나뉘므로, 요청의 바디에 해당하는 데이터가 있는 경우 해당 탭에서 확인 가능하다.
- Preview: 응답의 바디에 포함된 데이터를 보기 좋은 형태로 미리보기 할 수 있다.
- Response: 응답의 바디에 포함된 데이터를 보여 주지만, 그대로 보여 준다.
- Initiator: 
- Timing: 
- Cookies: 

### (2) 여러 번의 HTTP 트랜잭션이 발생한 이유
- 웹 브라우저를 통해 HTTP 페이지에 대한 요청을 하면, 브라우저는 HTTP 페이지에 포함된 이밎, 자바스크립트, CSS에 대한 요청을 자동으로 수행하게 된다.
- 만약 Postman으로 요청했으면 한 번의 트랜잭션만 발생했을 것이다.

> 트랜잭션(Transaction)
> - 쪼개질 수 없는 처리를 의미한다.
> - 두 가지 이상의 연산이 실행될 때 중간에 멈춘 상태로 두지 않고, 모두 실행한 상태로 만들거나 아무것도 실행하지 않은 상태 둘 중 하나로 만드는 것을 트랜잭셔널(Transactional)한 처리라고 한다.
> - 쪼개질 수 없는 연산의 단위를 트랜잭션, 쪼개질 수 없는 특징을 원자성(Atomic)을 가진다 라고 한다.
> - HTTP 트랜잭션은 요청과 응답이라는 하나의 묶음이다.

## 2) HTTP의 특징
- HTTP는 HyperText Transfer Protocol의 줄임말이다.
	- 즉, HTTP는 웹 페이지들 사이에서 링크를 타고 다니면서 정보를 전송하는 통신 규약(protocol)이다.
- 기본적으로 HTTP/1.1 버전을 알아야한다.
	- 해당 버전은 프로토콜이 안정적으로 자리 잡은 버전으로 가장 널리 사용된다.
	- 현재는 HTTP/2 버전으로 빠르게 전환되고 있지만, HTTP/1.1에 기초를 두고 있다.

### (1) HTTP/1.1 버전에 기반한 HTTP의 대표적 특징
#### HTTP는 클라이언트의 요청으로 HTTP 트랜잭션이 시작된다.
- 클라이언트가 먼저 요청을 시작한다는 HTTP의 특징은 서버에서 데이터를 줘야 할 때 실시간으로 줄 수 없다는 한계가 있다.
	- 그래서 웹 소켓과 같은 기술이 도입되기도 했다.

#### HTTP는 상태를 가지지 않는다.
- 이전 HTTP 트랜잭션과 다음 HTTP 트랜잭션 사이에 연관 관계가 없다.
- HTTP는 무상태성(stateless)이다 라고 한다.
- 로그인을 하면 서버가 사용자를 구분하는데, 이것은 HTTP라는 프로토콜 자체에서 구분하는 게 아니라 쿠키, 세션, 토큰 등 사용자를 식별할 수 있는 별도의 수단을 사용하여 구분한 것이다.

#### HTTP는 비연결성(Connctionless)을 갖는다.
- 데이터를 주고 받기 위해 연결이라는 과정이 필요하고, HTTP 트랜잭션이 종료되면 연결을 끊어 버린다.
- 이러한 네트워크 연결은 보통 커넥션이라고 표현한다.
- 장점
	- 클라이언트와 서버의 자원을 효율적으로 사용할 수 있다.
	- 특히 서버 측에서 다수의 클라이언트가 서버로 접속하기 때문에 연결된 클라이언트가 쌓이기만 하면 새로운 클라이언트를 연결하지 못할 수 있다.
- 단점
	- 매번 HTTP 트랜잭션마다 연결을 맺고 끊는 과정이 추가되어야 한다.
	- 매 연결마다 조금씩 성능상의 손해를 보게 만드는 오버헤드(overhead)가 발생한다.

>- HTTP에서 커넥션을 유지하려는 경우 Connection, Keep-Alive 같은 헤더를 사용한다.

> 오버헤드를 없앨 수는 없을까?
> - 오버헤드란 어떤 작업을 위해 필연적으로 수반되는 부수적인 작업을 이야기한다.
> - HTTP 트랜잭션에서 클라이언트와 서버가 교환하고 싶었던 것은 HTTP 메시지인데, 네트워크상에서 커넥션을 맺는 과정이 필요하며, 이것이 바로 오버헤드이다.
> - HTTP 메시지가 남아 있다면 연결을 끊지 않게 하는 식으로 오버헤드를 줄일 수도 있다.
> - 대부분 오버헤드는 필연적으로 발생하는데, 한 쪽에서 오버헤드를 줄이는 것이 다른 쪽에서 문제를 일으킬 수 있기 때문에 적절한 트레이드 오프(Trade-off)가 필요하다.

#### HTTP는 사람에게 진화적인 프로토콜이다.
- 통신 프로토콜은 보통 알아보기 어려운 바이너리(binary) 형태로 데이터를 주고받는데, HTTP는 사람이 읽을 수 있는 형태로 헤더를 주고받는다.
- 바디 부분은 Content-Encoding 이라는 헤더의 정의된 대로 압축하여 주고받고, 헤더를 압축하지 않고 사람이 읽을 수 있는 형태 그대로 보내 준다.
- 단, HTTPS에서는 헤더가 암호화되기 때문에 바로 알아볼 수 없다.

### (2) HTTP/1.1 외의 버전
- HTTP/1.1 이전 버전들은 0.9에서 GET이라는 하나의 메소드만 지원했고, 1.0에서는 POST와 HEAD 메소드, 상태 코드와 여러 가지 헤더가 추가되었다.
	- 1.0이 1.1의 기반을 닦은 버전이라고 할 수 있다.
- HTTP/1.1에서는 지속적인 연결(persistence connections)이 추가되어 HTTP 트랜잭션에 대한 오버헤드를 줄일 수 있게 발전되었고, 여러 가지 헤더가 추가되었다.

#### HTTP/2 버전의 특징
- 주요 변경점은 아래와 같다.
1. 하나의 커넥션에서 여러 개의 요청을 동시에 다중(multiplex) 처리할 수 있다.
	- HTTP/1.1에서는 파이프라이닝(pipelining)이라는 방법으로 하나의 커넥션을 통해 요청과 응답을 처리하도록 개선했다.
	- 그러나 반드시 요청한 순서와 동일하게 응답이 와야 한다는 제약이 있어서 앞쪽 요청에 대한 처리가 늦어지면 뒤쪽 요청에 대한 처리 역시 늦어졌다.
	- 다중화(multiplexing)를 통해 요청한 순서에 상관없이 응답이 오는 대로 처리할 수 있도록 개선했다.
2. 헤더를 압축한다.
	- HTTP/1.1 에서는 헤더를 압축하지 않아서 사람이 바로 읽을 수 있었다.
	- 그러나 헤더의 사이즈가 커지고 파싱(parsing)하는 데 비효율적이어서 낮은 성능을 보였다.
	- TCP (Transmission Control Protocol)의 느린 시작(slow start)라는 특성이 이런 문제를 부각시켰다.
		- 처음 요청하여 실패할 수도 있는 요청에게 네트워크 대역폭을 낭비하지 않도록 만들어 전체적인 네트워크 효율을 높이기 위함이다.
	- HTTP/2 에서는 이런 문제를 hpack이라는 헤더 압축 방식을 채택하여 해결하고자 했다.
3. 서버에서 예상되는 요청을 미리 클라이언트에 전송한다.
	- 연달아 제공되는 파일들이 있다면 해당 파일들을 서버에서 먼저 클라이언트에게 보내 두는 것도 좋은 방법이다.
		- HTML 요청이 오면 해당 HTML에 포함된 CSS, 자바스크립트 등을 요청이 오기 전에 서버 쪽에서 클라이언트에게 보내 두는 방식이다.
	- 이를 서버 푸시(server push)라고 한다.
	- 그러나 서버 푸시가 모든 상황에서 좋지 않으므로 주의해야한다.

#### HTTP/3 버전의 특징
- QUIC (Quick UDP Internet Connections)이라는 UDP를 사용하는 프로토콜을 선택했다.
- HTTP 트랜잭션은 네트워크상에서 커넥션을 맺는 과정이 필요했는데, 네트워크상에서 커넥션을 맺는 과정은 TCP의 핸드쉐이킹(handshaking)을 의미한다. 이를 통해 TCP는 안전하게 두 주체 간 정보를 교환하지만 과정 자체가 오버헤드가 된다.
- UDP는 이런 핸드쉐이킹 과정이 없고, 네트워크 헤더도 오직 출발지 포트, 목적지 포트, 데ㅔ이터의 길이, 체크섬(checksum) 정도만 가지고 있다.

> 체크섬(Checksum)
> - 데이터 전송 시 오류가 발생했는지 검증하기 위한 값을 의미한다.
> - CRC32와 같은 알고리즘을 알아야 한다.

- UDP는 가벼운 프로토콜인데, HTTP 통신에서 TCP가 해주던 여러 가지 기능이 필요하다. 그것을 QUIC이 새로 구현해 주면 되기 때문에 UDP만으로도 충분하다.