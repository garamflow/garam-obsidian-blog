# 03. 알고리즘의 효율 분석
## 1) 시간 복잡도란?
- 시간 복잡도(time complexity)란 알고리즘의 성능을 나타내는 지표로, 입력 크기에 대한 연산 횟수의 상한을 의미한다.
	- 시간 복잡도는 낮으면 낮을수록 좋다.
	- 입력 크기: 알고리즘이 처리해야 할 데이터의 양

### (1) 1차원 배열 검색하기
#### 값을 가장 빨리 찾는 경우
- 검색 시작 위치에 찾을 값이 바로 있는 경우

#### 값을 가장 늦게 찾는 경우
- 찾으려는 값이 없거나 가장 마지막에 위치하는 경우

### (2) 알고리즘 수행 시간을 측정하는 방법
#### 절대 시간을 측정하는 방법
- 시간을 측정하는 방법.
- 프로그램 실행 환경에 따라 달라질 수 있어서 코딩 테스트에서는 잘 활용하지 않는다.

#### 시간 복잡도를 측정하는 방법
- 알고리즘이 시작한 순간부터 결괏값이 나올 때까지의 연산 횟수를 나타낸다.
- 시간 복잡도를 측정한 결과는 최선, 보통, 최악으로 나뉜다.
- 입력 크기를 N으로 일반화해서 연산 횟수의 추이를 나타내야 하며, 이런 방식으로 입력 크기에 따른 연산 횟수의 추이를 활용해서 시간 복잡도를 표현하는 방법은 **점근적 표기법**이라고 한다.

### (3) 최악의 경우 시간 복잡도를 표현하는 빅오 표기법
- **빅오 표기법(big-O notation)** 은 최악의 경우에 대한 시간 복잡도를 표현하는 방법이다.
	- 점근적 표기법의 상한선을 활용하는 방법이다.
- 표기법
	- 어떤 프로그램의 연산 횟수가 f(x)일 때, 함수의 최고차항을 남기고 계수를 지워 O(...)와 같이 표기하면 된다.
	- 예시) f(x) = 2x^2+3x+5
		- O(x^2)

| 수식                 | 빅오 표기  | 설명                                                    |
| ------------------ | ------ | ----------------------------------------------------- |
| 3x^2 + 5x + 6      | O(x^2) | 다항함수로 구성되어 있으므로 최고차항인 x^2만 남는다.                       |
| x + logx           | O(x)   | 다항함수와 로그함수로 구성되어 있으므로 증가폭이 더 낮은 로그함수는 사라지고 다항함수만 남는다. |
| 2^x + 10x^5 + 5x^2 | O(2^x) | 지수함수는 다항함수보다 빠르게 증가하므로 지수함수만 남는다.                     |
| 5x^2 - 6x          | O(x^2) | 최고차항 x^2만 남는다.                                        |

### (4) 빅오 표기법을 쉽게 쓸 때는 왜 최고차항만 남기고 계수를 지울까?
| 함수 종류 | 예시   |
| ----- | ---- |
| 지수함수  | 2^x  |
| 다항함수  | 3x^2 |
| 로그함수  | logx |

- x값이 무한하게 커지면 최고차항외에는 무시할 수 있을정도로 작아진다.
- 로그함수는 다항함수보다 느리게 증가하고, 지수함수는 다항함수보다 빠르게 증가한다.

### (5) 시간 복잡도를 코딩 테스트에 활용하는 방법
- 문제를 분석하고 빅오 표기법을 활용해서 해당 알고리즘을 적용했을 때 제한 시간 내에 출력값이 나올 수 있을지 확인해볼 수 있다.
- 아래를 기준으로 알고리즘을 선택한다.
	- "컴퓨터가 초당 연산할 수 있는 최대 횟수는 1억 번이다."
- 연산 횟수를 1,000 ~ 3,000만 정도로 고려해서 시간 복잡도를 생각하면 된다.

| 시간 복잡도   | N의 가용 법위   |
| -------- | ---------- |
| O(N!)    | 10         |
| O(2^N)   | 20~25      |
| O(N^3)   | 200~300    |
| O(N^2)   | 3000~5000  |
| O(NlogN) | 100만       |
| O(N)     | 1000~2000만 |
| O(logN)  | 10억        |

- 예시)
	- 배열에서 하나씩 짚어가며 찾는 방식은 시간 복잡도가 O(N)이므로, 허용하는 연산 횟수는 2000만 정도이다.
	- 데이터의 개수가 2000만 이하라면 해당 알고리즘을 사용해도 된다.

## 2) 시간 복잡도 계산해보기
- 시간 복잡도를 계산하는 방법에는 순서가 있다.
	1. 문제 정의
	2. 연산 횟수 측정
	3. 시간 복잡도 분석

### (1) 별 찍기 문제
- 숫자 N을 입력받으면 N번째 줄까지 별을 1개부터 N개까지 늘려가며 출력하라.

#### 푸는 과정
1. 연산 횟수를 구한다. 출력 자체가 연산이므로 1번째 줄은 1번 연산, 2번째 줄은 2번 연산...N번째 줄은 N번 연산이다.
2. f(N) = N(N+1)/2 이므로 빅오 표기법은 O(N^2) 이다.

### (2) 박테리아 수명 문제
- 초기 박테리아 세포 개수가 N일 때, 해마다 세포 개수가 이전 세포 개수의 반으로 준다면, 언제 모든 박테리아가 죽을지 계산하라.

#### 푸는 과정
1. 현재 박테리아 수가 N이라면 1년 후는 `1/2 * N` 이라고 할 수 있다.
2. Y년 후에는 `(1/2)^Y * N` 이다.
3. 박테리아 소멸 시기는 값이 최초로 1보다 작아질 때 이다.
4. 수식으로 나타내면 `(1/2)^Y * N <= 1`을 찾으면 된다.
5. 수식을 정리하면 `Y > log2N` 이다.
6. 이를 통해 알고리즘은 `O(logN)`의 시간 복잡도를 가진다는 것을 알 수 있다.

> 특정 값이 반으로 줄이는 동작은 시간 복잡도를 `O(logN)` 이라 생각하자.