# 1. IPv4 주소의 구조
- <span style="background:#d4b106">192</span>.<span style="background:#d4b106">168</span>.<span style="background:#d4b106">0</span>.<span style="background:#d4b106">10</span>
	- <span style="background:#affad1">1100 0000</span> <span style="background:#affad1">1010 1000</span> <span style="background:#affad1">0000 0000</span> <span style="background:#fff88f">0000 1010</span>
	- <span style="background:#affad1">Network ID</span> / <span style="background:#fff88f">Host ID</span>
		- 24bit / 8bit
			- 8bit : 0~255
	- Network ID를 시~동까지 주소라고 생각하고 Host ID를 ~번지라고 생각하면 쉽다.
	- 해당 동 네트워크까지 진입하고 나서 Host ID라는 번지 주소를 통해 위치를 찾게된다.
![IPv4](/media/Network/개념%20강의%20정리/널널한%20개발자/외워서%20끝내는%20네트워크%20핵심이론%20-%20기초/4/IPv4.svg)

# 2. L3 IP Packet
- Packet은 단위 데이터이다.
	- 무언가를 감싸서 하나의 단위 데이터로 만든것이다.
- Packet이라는 말은 L3 IP Packet으로 외우자.
- Header와 Payload로 나뉘며 이는 상대적인 분류이다.
	- 네트워크의 단위 데이터는 항상 두 개로 나눈다.
	- Header가 나르는 대상을 Payload라고 한다.
	- Header에는 출발지, 목적지 정보가 들어있다.
- **최대 크기는 MTU (Maximum Transmission Unit)** 이다.
	- Header 처음부터 Payload 끝까지
	- **1500bytes** (1.4 * kb)
- 택배 박스 하나 혹은 퍼즐 조각 하나로 생각하자.
![Packet](/media/Network/개념%20강의%20정리/널널한%20개발자/외워서%20끝내는%20네트워크%20핵심이론%20-%20기초/4/Packet.svg)

# 3. Encapsulation, Decapsulation
![Encapsulation, Decapsulation](/media/Network/개념%20강의%20정리/널널한%20개발자/외워서%20끝내는%20네트워크%20핵심이론%20-%20기초/4/Encapsulation,%20Decapsulation.svg)
## 1) Encapsulation
- 러시아 전통 목각 인형인 마트료시카 인형을 떠올리면 쉽다.
- 어떤 박스 안에 쏙 집어넣었다. = **단위화**했다. = 포장했다.
	- 안에 무엇이 들어있는지 잘 보이지 않는다.

## 2) Decapsulation
- 하나씩 포장을 풀어서 알맹이를 뽑아내는 것

# 4. 패킷의 생성과 전달
## 패킷의 생성, 전달, 소멸
- 철수 (Process)가 영희(Process)에 책(Data, 정보)을 보내고자 한다.
- 책을 포장해서 택배(Packet)가 된다.
	- 송장을 붙이는데 송장에는 주소(출발지, 목적지)와 이름(보내는 이, 받는 이)가 적혀 있다.
- 집(Host) 현관(Interface)에서 택배 기사(Gateway)에게 택배를 맡기게된다.
- 택배 기사는 물류 체계에 따라 라우팅(Routing)한다.
- 목적지 주소(IPv4)를 보고 영희네 집(host)까지 찾아온다.
- 집에 도착하면 송장에 적혀있는 이름(Port 번호)을 보고 넘겨준다.
![Packet의 생성, 전달, 소멸](/media/Network/개념%20강의%20정리/널널한%20개발자/외워서%20끝내는%20네트워크%20핵심이론%20-%20기초/4/Packet의%20생성,%20전달,%20소멸.svg)

# 5. 계층별 데이터 단위
![계층별 데이터 단위](/media/Network/개념%20강의%20정리/널널한%20개발자/외워서%20끝내는%20네트워크%20핵심이론%20-%20기초/4/계층별%20데이터%20단위.svg)
# ‼️ 6. TCP/IP 송, 수신구조 ‼️
## 1) 송신하는 쪽 과정
- 송신하는 과정은 주로 Encapsulation이 일어난다.

1. 컴퓨터의 HDD, SDD와 같은 곳에 파일이 존재한다.
2. User mode의 Socket (File)에도 저장되는 공간인 Buffer (메모리 공간)이 있다.
	- 해당 공간은 개발자가 어떻게 설정하냐에 따라 크기가 다르다.
	- 해당 Socket에는 I/O (입출력)가 존재한다.
3. Process App(Server)에도 Buffer가 존재한다.
4. Process가 컴퓨터에 존재하는 원본 파일의 일부를 복사(Copy)해서 Process App의 Buffer에 담는다.
5. Process에 있는 Buffer에서 Socket의 Buffer에 Send하게 된다. (복사)
	- 데이터 단위는 Stream이다.
	- 해당 Stream은 파일 전체를 보내야 끝난다.
6. TCP에서 분해된 Segment를 잘라온다.
	- TCP는 순서 개념이 있어서 잘라올 때, 1번, 2번 과 같이 번호표를 붙여서 순서대로 갖고오게 된다.
7. Segment가 L3로 한 층 내려가 Packet이 된다.
	- 준비되있던 박스에 Segment를 집어넣고, 포장이 끝나면 송장을 붙이게된다.
8. L2로 내려가면 택배기사(Frame)가 Packet을 들고 가게된다.
	- 택배기사인 Frame은 유통 과정에서 수시로 바뀌게 된다.

## 2) 수신하는 쪽 과정
- 수신하는 쪽은 주로 Decapsulation이 일어난다.

1. 도착한 택배기사가 도착하면 L2에서 택배(Packet)을 하차하게 된다.
2. L3에 Packet이 놓이게 되고 이제 박스를 버리고 1번 번호표를 갖고 있는 Segment가 L4로 가게된다.
3. 송신하는 쪽도 Socket (File) 에 I/O Buffer가 있어서 1번 Segment가 Buffer에 쌓이게 된다.
	- 해당 Buffer에 여유공간(Window Size)이 존재한다.
4. Process인 Chrome에도 Buffer가 존재해서 1번 Segment를 퍼올리게 된다.
	- 여기서 속도차가 존재한다.
	- Network는 계속 Socket I/O Buffer를 채우려고 하고, Chrome은 Socket I/O Buffer에 있는 것을 퍼올리게 된다.
	- Chrome은 받게되는 것이니 Receive 되는 것이다.
5. 송신하는 측에서는 1번 Segment를 송신하면서 동시에 2번, 3번을 준비해놨다가 보내게된다.
	- 이 때, 잠시 기다렸다 보낼 지 바로 보낼 지는 내부 타이머에 따라 결정된다.
6. 2번 Segment가 들어오게 되면 Socket I/O Buffer의 여유공간이 줄어들게 된다.
	- TCP는 연결 지향이다보니 잘 받았을 때, 피드백을 주는데 이 피드백 (ACK)을 주게된다.
	- ACK #3 이면 2번까지 잘 받았다는 의미이다.
	- ACK #3 이 도착하면 송신측에서 3번 택배를 보내게된다.
7. Chrome Process에서 Socket I/O Buffer에 있는 데이터를 Receive 받게 되고, 조각나있던 데이터가 합쳐지게 된다.
8. 그러면 Socket I/O Buffer의 여유 공간이 늘어나게 된다.
	- ACK에는 여유 공간의 크기도 같이 보내게 된다.
	- 만약 여유 공간이 없다면 송신하는 측에서 보내지 못하게 된다.

## 3) 네트워크 장애
- Loss Segment
	- 유실되는 경우다.
- Re-transmission + ACK Duplicate
	- 송신하는 측에서 1번 택배를 보내고 ACK를 기다리는데, ACK가 안오면 다시 보내게 된다.
	- 하지만 다시보낼 때 겹쳐서 ACK #2 가 도착할 수도 있다.
	- 그러면 다시 ACK #2 를 다시 보내게된다.
- Out of order
	- 1번, 2번, X, 4번
	- 1번, 2번, 4번, 3번
	- 순서가 알맞지 않게 도착할 수 있다.
- Zero Window
	- 여유공간이 없다.
	- Process인 App이 퍼올리는것보다 Network에서 들어오는 데이터의 속도가 더 빠른 경우에 일어날 수 있다.
	- End-point에서 APP에서 문제가 생긴것이다.

# 7. IP 헤더 형식
## IPv4 Header 형식
![IPv4 헤더](/media/Network/개념%20강의%20정리/널널한%20개발자/외워서%20끝내는%20네트워크%20핵심이론%20-%20기초/4/IPv4%20헤더.svg)

# 8. 서브넷 마스크와 CIDR
## 1) 서브넷 마스크
![Subnet Mask](/media/Network/개념%20강의%20정리/널널한%20개발자/외워서%20끝내는%20네트워크%20핵심이론%20-%20기초/4/Subnet%20Mask.svg)

## 2) CIDR
![CIDR](/media/Network/개념%20강의%20정리/널널한%20개발자/외워서%20끝내는%20네트워크%20핵심이론%20-%20기초/4/CIDR.svg)

# 9. Broadcast IP 주소
![Broadcast IP주소](/media/Network/개념%20강의%20정리/널널한%20개발자/외워서%20끝내는%20네트워크%20핵심이론%20-%20기초/4/Broadcast%20IP주소.svg)

# 10. Host 자신을 가리키는 IP 주소
- 127.0.0.1
	- Loopback Address
	- PC의 특정 Process가 같은 PC의 다른 Process에 연결하고 싶을 때 사용하는 IP 주소이다.
	- Packet이 L2를 거치지 않고 서로간에 통신을 하게 된다.
	- IPC (Inter Processor Communication)
![127.0.0.1](/media/Network/개념%20강의%20정리/널널한%20개발자/외워서%20끝내는%20네트워크%20핵심이론%20-%20기초/4/127.0.0.1.svg)

# 11. TTL과 단편화
- 인터넷은 라우터와 DNS의 집합체라고 할 수 있는 논리 네트워크이다.
- Router vs L3 Switch
	- Router가 L3 Switch이냐 L3 Switch가 Router이냐 논란이 있다.

## 1) TTL
- Time To Live는 세포의 '텔로미어'같은 역할을 한다.
- Packet이 목적지에 도착하는 데 실패하게 되면 해당 Packet이 사라져야하는데, 그 역할을 하는게 TTL이다.
- 라우터와 라우터 사이 거리를 Hop이라고 하는데, Hop을 지날 때 마다 숫자가 줄어들게 된다.
- TTL이 0이되면 해당 라우터는 Packet을 버리게 된다.
	- 라우터에 따라 Packet을 버렸단 걸 알려주는 라우터도 있고 안알려주는 라우터도 있다.

## 2) 단편화
- MTU 크기 차이로 발생한다.
	- MTU는 보통 1500bytes
- 만약 MTU가 1400bytes라서 1500짜리를 못받게되면 그것을 둘로 쪼개는 작업을 하는데, 그것을 단편화라고 한다.
	- Payload를 A Payload, B Payload로 나눈다.
	- IP Header는 복사해서 A, B에 붙여넣는다.
		- IP Header 완전 복사는 아니고 옵션이 조금 다르다. 
- 단편화된 Packet의 조립은 보통 수신측 End-point에서 하게된다.
	- 수신측 IP 계층에서 A, B를 조립하고 Segment를 끄집어내서 TCP쪽에 넘기게된다.
- 단편화가 일어나지 않게 아예 처음부터 1400bytes로 보낼수도 있다.
- 보통 VPN 등을 사용하게 되면 단편화가 나는 경우가 있다. 그외에는 거의 없다.

# 12. 인터넷 설정 자동화를 위한 DHCP
- 인터넷 사용 전에 해야 할 설정
	- IP 주소
	- Subnet Mask
	- Gateway IP주소
		- 여기까지 L3 설정
	- DNS 주소
- 하지만 보통 자동으로 설정하기를 사용한다.
## DHCP (Dynamic Host Configuration Protocol)
- 해당 체계는 주소를 할당하는 서버와 할당 받으려는 클라이언트로 구성된다.
- 복잡한 인터넷 설정을 자동으로 해주는데, 스스로 사용할 IP주소를 서버가 알려준다.
- Broadcast 도메인에 묶여 있어야 한다.

### 예시
- 여러 개의 PC중 DHCP Server 역할을 하는 A PC가 있다고 가정해보자.
- 다른 B PC가 전원을 키면 먼저 네트워크에 Broadcast Packet을 보낸다.
	- 네트워크로 DHCP Server가 있는지 물어보게 된다.
- A는 자기가 DHCP Server라고 답장을 한다.
	- 다른 PC는 아무런 응답을 보내지 않는다.
- B는 이전에 받았던 주소가 있으면 그 주소를 사용해도 되는지 다시 물어보게 되고 A는 사용 가능 여부를 답변하게 된다.
	- 처음 접속하는 거면 주소를 그냥 알려주게 된다.
- A는 Pool에 갖고 있던 IP 주소와 Gateway주소, DNS 주소 등 여러 정보를 B에게 알려준다.

# 13. ARP
## ARP (Address Resolution Protocol)
- 주소(Address)라고 불리는건 보통 Host를 식별하는 IP주소와 NIC를 식별하는 MAC주소가 있다.
- ARP는 IP주소로 MAC주소를 알아내려 할 때 활용된다.
	- Gateway의 MAC주소를 모르면 인터넷을 할 수 없으므로 MAC주소를 알아야한다.
- 보통의 경우 PC를 부팅하면 Gateway의 MAC주소를 찾아내기 위해 ARP Request가 발생하며 이에 대응하는 Reply로 MAC주소를 알 수 있다.

### 예시
- PC A : 192.168.0.100 / Gateway : 192.168.0.1 / Naver : 3.3.3.3
1. 어떤 PC A가 네이버 (IPv4 : 3.3.3.3)에 접속하려고 한다.
2. A에서 broadcast로 ARP Request로 `192.168.0.1`을 찾게된다.
3. Gateway가 A한테 Reply로 MAC주소를 알려준다. 
	1. DHCP로 알 수 없다.
4. 답장을 받은 A는 네이버에 접속할 수 있다.
	- Packet
		- 출발지 \[MAC주소 : PC의 MAC주소 / IP주소 : PC의 IPv4 주소]
		- 목적지 \[**MAC주소 : Gateway의 MAC주소** / IP주소 : 네이버의 IPv4 주소]

# 14. Ping과 RTT
- Ping 유틸리티는 특정 Host에 대한 RTT(Round Trip Time)을 측정할 목적으로 사용된다.
	- 유틸리티 : 그냥 프로그램을 말한다.
- ICMP 프로토콜을 이용한다.
- DoS(Denial of Service) 공격용으로 악용되기도 한다.