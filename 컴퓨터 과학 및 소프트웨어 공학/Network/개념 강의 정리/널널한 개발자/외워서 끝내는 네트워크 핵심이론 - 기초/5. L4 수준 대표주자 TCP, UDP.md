# 1. TCP와 UDP 개요
- TCP에만 연결(**Connection**, **Session**) 개념이 있다.
	- 연결은 매우 논리적(Virtual)이다.
- 연결은 결과적으로 순서번호로 구현된다.
	- 순서번호는 byte수이다.
- **연결은 '상태(전이)' 개념을 동반**한다.
	- 전화를 생각하면 쉽다.
	- 통화전-연결-통화후-종료
- TCP는 배려남, UDP는 (배려가 없는) 나쁜 남자에 비유할 수 있다.
	- 수신하는 쪽에서 받을 수 없으면 TCP는 안보내지만 UDP는 무시하고 보낸다.
![OSI 7 Layer에서 주요 부분들](/media/Network/개념%20강의%20정리/널널한%20개발자/외워서%20끝내는%20네트워크%20핵심이론%20-%20기초/5/OSI%207%20Layer에서%20주요%20부분들.svg)

## TCP 예시
- Client(Process)와 Server(Process)가 있다.
	- Server는 **연결 대기**(Listen) 상태이다.
		- Server도 Socket를 생성 및 개방하게 된다.
		- Process가 운영체제에게 특정 TCP Port 번호만 받을 수 있다고 말한다.
		- 운영체제는 특정 TCP Port 번호를 Socket에게 부여한다.
		- 연결 대기 상태가 된다.
1. Client가 Socket을 생성 및 개방한다.
	1. Client는 Process 식별자인 PID를 갖게 된다.
2. 운영체제(Kernel mode)에서 Socket에 TCP Port 번호를 부여한다.
	1. IPv4가 192.168.0.10, 3000
3. Server에 연결한다.
	1. Server 접속 시, IP 주소와 TCP Port 번호를 알아야만 연결할 수 있다.

# 2. TCP 연결 과정
![TCP 연결 과정 (3-way handshaking)](/media/Network/개념%20강의%20정리/널널한%20개발자/외워서%20끝내는%20네트워크%20핵심이론%20-%20기초/5/TCP%20연결%20과정%20(3-way%20handshaking).svg)
## 1) 과정 요약
1. Client가 Sequence number 1000을 생성해서 Server에 보내게 된다.
	- Sequence number는 랜덤이다.
2. Server는 자기도 Sequence number 4000을 생성한다음, Client에게 받은 Sequence number에 1 증가시킨 ACK와 같이 Client 에게 보내게 된다.
3. Client도 Server의 Sequence number에 1 증가시킨 ACK를 Server에게 응답한다.

- Client가 Server의 IP주소와 Port 번호를 알고 있는 상태이다.
- Server는 연결 대기 상태이다.
- 통신 단위는 Segment이며, Payload가 없다.

## 2) TCP 연결 과정 (3- way handshaking)
- Sequence number를 교환한다.
- 정책을 교환한다.
	- **MSS (Maximum Segment Size)**
	- Client가 Server에게, Server가 Client에게 MSS를 알려준다.
	- 만약 Server가 상대적으로 작다면 Client가 Server에 맞춰준다.
- Client와 Server 사이에 연결되었다고 판단하는 시간에 차이가 있다.
- 논리적 연결이다. (Virtual Circuit)

# 3. TCP 연결 종료 및 상태 변화
![TCP 연결 종료 과정 (4-way handshaking)](/media/Network/개념%20강의%20정리/널널한%20개발자/외워서%20끝내는%20네트워크%20핵심이론%20-%20기초/5/TCP%20연결%20종료%20과정%20(4-way%20handshaking).svg)
- 특별한 일이 없다면 Client가 Active하다.
	- 연결을 하자는 것도, 끊겠다고 하는 것도 Client이다.
- Client는 연결 상태이다.

## 1) 과정 요약
1. Client가 연결을 끊자고 FIN + ACK 를 Server에 보낸다.
2. Server는 알겠다고 ACK를 Client에 응답한다.
	- Client는 FIN을 기대하며 FIN_WAIT1 상태인데, ACK만 왔으므로 FIN_WAIT2 상태가 된다.
3. Server에서 Client에 FIN + ACK를 보내면서 마지막 ACK를 기다리는 LASK_ACK 상태가 된다.
4. Client는 TIME_WAIT 상태에서 Server에 ACK를 응답한다.
5. 연결이 종료된다.

## 2) TCP 연결 종료 및 상태 변화
- 만약 Server에 TIME_WAIT 상태가 나오면, 서버가 연결을 끊자고 하는 상태인 것이다.
	- TIME_WAIT는 연결을 끊자고 하는 쪽에서 생기는 상태이다.
	- Server가 해당 상태라면 무언가 문제가 생긴것이다.
	- 해당 현상은 Application Protocol 설계가 문제로, 설계 시 Client가 먼저 끊게 유도를 해야한다.
- 연결이 종료되면 사용중이던 Socket이 줄어들어서 사용할 수 있는 Socket이 늘어난다.
	- 만약 Server가 먼저 끊자고 하면 TIME_WAIT에서 CLOSED가 되는게 Client가 아니다보니 Socket이 사라지지 않는다.
	- Socket이 낭비될 수 있다.

# 4. TCP, UDP  Header 형식과 게임서버 특징
## 1) TCP Header 형식

## 2) UDP Header 형식
- 혼잡 제어를 하지 않는다.
- 영상 송출 같은 것을 할 때는 모두를 고려하지 않는 UDP로 보내야한다.
- 게임 서버를 TCP를 사용하면 하향평준화를 하게 되므로, 동기화를 하기 위해서 UDP를 사용한다.
	- UDP 기반의 혼잡 제어를 만들어서 사용한다.
- UDP는 멀티미디어 전송에 특화되어 있다.

# 5. TCP '연결'이라는 착각
- TCP/IP로 파일 다운로드 중 LAN 케이블을 분리했다가 다시 연결하면 TCP 연결은 어떻게 될까?
	- TCP 연결은 L4 수준이지만 LAN 케이블은 L1 수준이므로 TCP 연결은 유지된다.
	- 그러나 LAN 케이블을 분리한 시간이 길면 끊길수도 있다.
	- 그래서 연결을 계속 재확인하게 된다. (Heartbeat)
- 재전송 타이머의 기본 근사 값은 대략 3초이다. 하지만 대부분의 운영체제는 1초 미만이다.
- 재전송 타이머 만료 후에도 확인 응답을 받지 못한 경우 Segment를 재전송하고 RTO(Retransmission Time-Out) 값은 두 배로 증가한다.
	- 예를 들어 1초 > 2초 > 4초 > 8초 > 16초 간격으로 재전송한다.
- 보통 최대 5회 재전송을 시도하고 5회 이상 모두 실패할 경우 전송 오류가 발생한다.
- LAN 케이블이 분리되는 것과 같은 것을 충격이라고 하고, 이런 것을 대비하기 위해 Buffer가 미리 일부를 저장해놓는다.
	- Buffer를 충격 완화 장치라고 한다.

# 6. TCP 연결과 게임 버그
- MMORPG 게임에서 아이템 복제 버그가 발생하였다.
- 논리적 TCP 연결과 물리적 링크간 차이를 이용한 시간차 공격이라 볼 수 있으며, 연결이 사실은 End-point의 주관적 판단에 불과하다는 것을 알 수 있다.
- TCP의 연결이라는 말과 함께 항상 보안성이 없다는 말이 따라다닌다.
	- 보안성
		- 기밀 : 누군가 알 수 있는가
		- 무결 : 변조되지 않는가
		- 가용 : 항상 되는가