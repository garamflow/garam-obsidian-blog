# 8. 도커를 실무에 적용하기
## 8.1 레이어 관리
- Dockerfile에 작성된 지시어 하나 당 레이어가 한 개 추가됩니다.
- 불필요한 레이어가 많아지면 이미지의 크기가 늘어나고 빌드 속도가 느려질 수 있습니다.
![레이어 관리1](/media/도구%20및%20환경/Docker/강의%20정리/데브위키/개발자를%20위한%20쉬운%20도커/레이어%20관리1.png)

### 8.1.1 Run 지시어 관리
- RUN 지시어는 &&을 활용해 최대한 하나로 처리합니다.
- 불필요한 명령어를 추가해서 레이어의 개수를 늘리지 않습니다.
![레이어 관리 - Run 지시어 관리](/media/도구%20및%20환경/Docker/강의%20정리/데브위키/개발자를%20위한%20쉬운%20도커/레이어%20관리%20-%20Run%20지시어%20관리.png)

### 8.1.2 크기 관리
1. 애플리케이션의 크기를 가능한 작게 관리합니다.
![레이어 관리 - 크기 관리](/media/도구%20및%20환경/Docker/강의%20정리/데브위키/개발자를%20위한%20쉬운%20도커/레이어%20관리%20-%20크기%20관리.png)

2. 베이스 이미지는 가능한 작은 이미지를 사용합니다.
- alpine OS를 사용하는 것이 좋습니다.
![레이어 관리 - 크기 관리 with alpine](/media/도구%20및%20환경/Docker/강의%20정리/데브위키/개발자를%20위한%20쉬운%20도커/레이어%20관리%20-%20크기%20관리%20with%20alpine.png)

3. `.dockerignore` 파일을 사용해서 불필요한 파일을 제거합니다.
![레이어 관리 - 크기 관리 with dockerignore](/media/도구%20및%20환경/Docker/강의%20정리/데브위키/개발자를%20위한%20쉬운%20도커/레이어%20관리%20-%20크기%20관리%20with%20dockerignore.png)



## 8.2 캐싱을 활용한 빌드
- 캐싱은 빌드 속도를 빠르게 만들어주는 기술입니다.
- Dockerfile에 작성된 순서대로 결과 이미지의 레이어가 쌓입니다.
- Docker는 각 단계의 결과 레이어를 캐시처리합니다. 지시어가 변경되지 않으면 다음 빌드에서 레이어를 재사용합니다.
- COPY, ADD 명령의 경우 빌드 컨텍스트의 파일 내용이 변경되어도 캐시를 사용하지 않습니다.
- 레이어가 변경되면 그 레이어와 이후의 모든 레이어는 캐시를 사용하지 않고 새로운 레이어가 만들어집니다.

### 8.2.1 캐싱을 활용한 빌드
- 잘 변경되지 않는 파일들을 아래 레이어에 배치하면, 캐시를 활용하는 빈도를 높일 수 있습니다.
- package.json, package-lock.json 파일은 소스 코드가 의존하는 외부 라이브러리 정보가 있습니다. 개발 시 자주 변경되지 않습니다.
- package.json, package-lock.json 파일이 변경되지 않을 경우 npm ci 단계(의존 라이브러리 설치)까지 캐시를 활용할 수 있습니다

![캐싱을 활용한 빌드](/media/도구%20및%20환경/Docker/강의%20정리/데브위키/개발자를%20위한%20쉬운%20도커/캐싱을%20활용한%20빌드.png)

## 8.3 3Tier 아키텍처 구성
- 세 가지 종류의 서버가 유기적으로 상호작용 하면서 하나의 애플리케이션으로 구성되는 것을 3Tier 아키텍처라고 한다.
	- Tier: 하나의 단계
- 백엔드 애플리케이션이 외부에 노출되어 있을 경우 개발자가 의도하지 않은 API를 호출할 위험이 있습니다.
	- 클라이언트가 직접 백엔드 서버에 요청하는 것은 좋지 못합니다.

### 8.3.1 Nginx 설정 커스터마이징, 3 Tier 아키텍처 구성하기
- Nginx의 프록시 기술을 활용해 보안에 뛰어난 3Tier 아키텍처를 구성할 수 있습니다.
- Nginx는 특정 경로로 온 요청(/api로 시작하는 경로)를 지정한 서버로 전달합니다.
- Nginx를 프록시 서버로 활용하여 보안 향상, 부하 관리 및 API 응답 캐싱을 활용할 수 있습니다.

![Nginx 설정 커스터마이징, 3 Tier 아키텍처 구성하기](/media/도구%20및%20환경/Docker/강의%20정리/데브위키/개발자를%20위한%20쉬운%20도커/Nginx%20설정%20커스터마이징,%203%20Tier%20아키텍처%20구성하기.png)
- `http://localhost/index.html` > 웹서버의 정적 파일 응답
- `http://localhost/api/~` > 애플리케이션으로 요청 전달

#### 프론트엔드 서버
```javascript
// api.js
import axios from 'axios';

// 클라이언트가 모든 요청을 자기 자신에게 보내도록 지정
const api = axios.create({
});

export default api;
```

```
// nginx.conf
// 

server {
	listen 80;
	server_name _;

	// 웹 서버로 오는 요청 중 / index.html을 제공한다.
	location / {
		root /usr/share/nginx/html;
		index index.html index.htm;
	}

	// 웹 서버로 오는 요청 중 /api/로 시작하는 경로의 요청을 모두 http://leafy:8080으로 전달
	location /api/ {
		proxy_pass http://leafy:8080;
	}

	error_page 500 502 503 504 /50x.html;
	location = /50x.html {
		root /usr/share/nginx/html;
	}
}
```

```docker
# Dockerfile

...

# 소스코드의 nginx.conf 파일을 이미지 빌드 시 nginx 설정으로 복사
COPY nginx.conf /etc/nginx/conf.d/default.conf

...
```

#### 결과
![Nginx 설정 커스터마이징, 3 Tier 아키텍처 구성하기 - 결과1](/media/도구%20및%20환경/Docker/강의%20정리/데브위키/개발자를%20위한%20쉬운%20도커/Nginx%20설정%20커스터마이징,%203%20Tier%20아키텍처%20구성하기%20-%20결과1.png)

![Nginx 설정 커스터마이징, 3 Tier 아키텍처 구성하기 - 결과2](/media/도구%20및%20환경/Docker/강의%20정리/데브위키/개발자를%20위한%20쉬운%20도커/Nginx%20설정%20커스터마이징,%203%20Tier%20아키텍처%20구성하기%20-%20결과2.png)

