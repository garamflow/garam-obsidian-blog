# 세션 정리
- 이미지 = CD
	- 실행 가능한 애플리케이션과 그 환경 정의 파일.
	- 변경 불가능.
	- 코드, 런타임, 라이브러리 등 포함
- 컨테이너
	- 프로그램
	- 이미지 실행 상태
- 버전 관리가 쉽다
- MSA 에서 쓰이기 좋다
	- 관리 서버가 많으므로

- 빌드를 항상 해줘야된다
	- 빌드까지 하는 스크립트를 Dockerfile에도 적어준다
- alpine 혹은 -slim 이 붙은 이미지를 사용하자
	- 아주 가끔 풀버전을 사용할 때도 있다
- 포커 내부의 port를 외부에 노출시켜주어야한다.
	- 보통은 복잡도를 낮추기 위해 외부, 내부 포트를 같게 한다 xxxx:yyyy를 같에 설정한다
		- `8080:8080`
- `docker build -t test-docker-hello .`
	- `.` 
		- 현재 디렉토리에 있는 도커파일을 빌드하겠다
- `docker build -t test-docker-hello -f Dockerfile-dev`
	- `-f`: file
	- 해당 파일을 빌드하겠다
- 로컬과 docker를 왔다갔다 하다보면 포트가 겨치는 경우가 있다
	- `kill $(lsof -t -i:{port})`
	- 이렇게 한 줄로 줄여서 닫을 수 있다


## MSA에서의 docker compose
- docker compose 실행 환경과 intellij 실행 환경은 분리되어 있다
- properties에서는 localhost가 가능하다
	- 로컬에서 띄우기 때문에
- 도커 컴포즈에 있는 것은 도커에 있는것이다.

[!Note] application.properties를 나누자
- 로컬용
	- application-dev.properties
		- edit에서 environment에서 dev를 바라보게 해준다.
	- Dockerfile-dev
		- 로컬에서 쓰이는
		- `ENV SPRING_PROFILES_ACTIVE = dev`
- 도커용
	- application.properties
	- Dockerfile
