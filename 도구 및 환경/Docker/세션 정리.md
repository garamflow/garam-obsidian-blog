# 세션 정리
- 이미지 = CD
	- 실행 가능한 애플리케이션과 그 환경 정의 파일.
	- 변경 불가능.
	- 코드, 런타임, 라이브러리 등 포함
- 컨테이너
	- 프로그램
	- 이미지 실행 상태
- 버전 관리가 쉽다
- MSA 에서 쓰이기 좋다
	- 관리 서버가 많으므로

- 빌드를 항상 해줘야된다
	- 빌드까지 하는 스크립트를 Dockerfile에도 적어준다
- alpine 혹은 -slim 이 붙은 이미지를 사용하자
	- 아주 가끔 풀버전을 사용할 때도 있다
- 포커 내부의 port를 외부에 노출시켜주어야한다.
	- 보통은 복잡도를 낮추기 위해 외부, 내부 포트를 같게 한다 xxxx:yyyy를 같에 설정한다
		- `8080:8080`
- `docker build -t test-docker-hello .`
	- `.` 
		- 현재 디렉토리에 있는 도커파일을 빌드하겠다
- `docker build -t test-docker-hello -f Dockerfile-dev`
	- `-f`: file
	- 해당 파일을 빌드하겠다
- 로컬과 docker를 왔다갔다 하다보면 포트가 겨치는 경우가 있다
	- `kill $(lsof -t -i:{port})`
	- 이렇게 한 줄로 줄여서 닫을 수 있다


## MSA에서의 docker compose
- docker compose 실행 환경과 intellij 실행 환경은 분리되어 있다
- properties에서는 localhost가 가능하다
	- 로컬에서 띄우기 때문에
- 도커 컴포즈에 있는 것은 도커에 있는것이다.

>[!Note] application.properties를 나누자
- 로컬용
	- application-dev.properties
		- edit에서 environment에서 dev를 바라보게 해준다.
	- Dockerfile-dev
		- 로컬에서 쓰이는
		- `ENV SPRING_PROFILES_ACTIVE = dev`
- 도커용
	- application.properties
	- Dockerfile

- DB가 없으면 에러가 난다.
	- depens_on만 해서는 안된다
	- 그래서 condition: service_healthy을 쓴다
		- 리트라이 등을 시도할 수 있다
	- 혹시 depends_on + restart를 해도 된다.

- 네트워크를 이용해서 서로 다른 컨테이너를 연결시켜줄 수 있다
	- 아무것도 설정하지 않으면 default 네트워크로 잡혀서 연결이 자동으로 된다.

- MSA + docker
	- 로컬과 배포 상황에서의 docker compose는 많이 다르다
	- 개발 상황에서는 docker compose를 이용해서 여러 컨테이너를 하나의 컨테이너로 묶어서 사용했지만, 실무 배포상황에서는 서버가 모두 다르다

- CI/CD
	- 한 번 더 생각해보기
	- ci -> 테스트 자동화
	- cd -> 배포 자동화
- CI/CD를 썼습니다! 라고 쓰려면
	- CI 과정인 테스트 과정이 필요하다
	- 인프랜 CI/CD 규칙
		- 반드시 머지할 때마다 머지 후 테스트 커버리지가 머지 전 테스트 커버리지보다 높아야한다
		- -> 머지 규칙
		- 코드가 늘어났는데 
- 직접 CICD를 해봐야된다.

- tistory를 믿지 말아라
- 우리가 배포 시 필요한 것은 jar 파일밖에 없다
- 