# 5. 스프링 배치 실행 - Step
## 5.1 StepBuilderFactory










스프링 배치 5.x 버전에서는 **`StepBuilderFactory`** 와 **`JobBuilderFactory`** 의 사용이 더 이상 권장되지 않으며, **`StepBuilder`** 와 **`JobBuilder`** 를 **직접 사용하는 방식**이 기본적인 모범 사례로 자리잡고 있습니다. 이를 통해 설정을 더 명확하게 하고 의존성 주입의 복잡성을 줄일 수 있습니다. 아래에서는 스프링 배치에서 **Task 기반**과 **Chunk 기반** Step을 **빌더 방식**으로 설명하겠습니다.

### 5.1.1 기본 개념: Step과 Tasklet
- **Step**: 작업 단위로, 스프링 배치에서 제공하는 **Tasklet** 또는 **Chunk** 기반으로 작업을 정의합니다.
- **Tasklet**: 하나의 단위 작업을 정의하는 인터페이스로, **RepeatTemplate**을 통해 **반복 실행**할 수 있습니다.
- **Chunk 기반** Step은 대용량 데이터를 **Chunk 단위**로 나누어 처리하며, **ItemReader**, **ItemProcessor**, **ItemWriter**를 사용합니다.

### 5.1.2 Task 기반 vs Chunk 기반 비교
#### Task 기반
- **단일 작업**에 적합하며, **ItemReader/Processor/Writer**를 사용하지 않고 단순 작업을 수행합니다.
- **반복적인 작업**을 처리할 때는 **RepeatTemplate**을 통해 반복 실행합니다.
- 예를 들어, **디렉토리 정리**나 **파일 삭제**와 같은 작업에 적합합니다.

#### Chunk 기반
- 대량 데이터를 효율적으로 처리하기 위해 **Chunk 단위**로 작업을 나눠 실행합니다.
- **ItemReader**로 데이터를 읽고, **ItemProcessor**로 처리한 후, **ItemWriter**로 데이터를 저장하는 방식입니다.
- **대용량 데이터 처리**에 매우 적합하며, 예를 들어 **데이터 마이그레이션**이나 **파일의 대량 처리** 등에 활용됩니다.

### 5.1.3 Step 생성: 빌더 방식
스프링 배치 5.x에서는 **`StepBuilder`**와 **`JobBuilder`**를 직접 사용하여 **Step**과 **Job**을 생성합니다. 이를 통해 설정의 **명확성**과 **유연성**을 높일 수 있습니다.

#### Task 기반 Step 생성
- **Tasklet**을 사용하여 Step을 생성하는 방식입니다. 아래는 **Task 기반 Step**을 생성하는 예제입니다.

  ```java
  @Bean
  public Step taskStep() {
      StepBuilder stepBuilder = new StepBuilder("taskStep");
      return stepBuilder
              .tasklet(myTasklet())  // Tasklet 설정
              .startLimit(5)         // Step의 실행 횟수 제한
              .allowStartIfComplete(true) // 완료 후에도 재실행 허용
              .listener(new StepExecutionListener() { /* 콜백 로직 */ })
              .build();
  }
  ```
  - **`StepBuilder`**를 직접 생성하여 사용하며, **Tasklet**을 설정한 후 **Step**을 빌드합니다.
  - **`startLimit`**과 **`allowStartIfComplete`** 등의 설정을 통해 **Step**의 동작을 제어합니다.

#### Chunk 기반 Step 생성
- **Chunk 기반 Step**은 대용량 데이터를 처리하기 위해 데이터를 **Chunk 단위로 나누어** 처리합니다. 아래는 **Chunk 기반 Step**을 생성하는 예제입니다.

  ```java
  @Bean
  public Step chunkStep() {
      StepBuilder stepBuilder = new StepBuilder("chunkStep");
      return stepBuilder
              .<InputType, OutputType>chunk(100) // Chunk 크기 설정
              .reader(itemReader())              // ItemReader 설정
              .processor(itemProcessor())        // ItemProcessor 설정
              .writer(itemWriter())              // ItemWriter 설정
              .faultTolerant()                   // 오류 허용 설정 (옵션)
              .retryLimit(3)                     // 재시도 횟수 설정 (옵션)
              .build();
  }
  ```
  - **`StepBuilder`**를 사용하여 **Chunk 기반 Step**을 생성하며, **ItemReader**, **ItemProcessor**, **ItemWriter**를 설정하여 데이터를 처리합니다.
  - **`faultTolerant()`**와 **`retryLimit()`**을 통해 **오류 허용** 및 **재시도** 기능을 설정할 수 있습니다.

### 5.1.4 Job 생성: 빌더 방식
- **Job**은 하나 이상의 **Step**으로 구성됩니다. **JobBuilder**를 사용하여 **Job**을 생성하고, 각 **Step**을 연결하여 배치 작업의 흐름을 정의합니다.

  ```java
  @Bean
  public Job myJob() {
      JobBuilder jobBuilder = new JobBuilder("myJob");
      return jobBuilder
              .start(taskStep())      // 첫 번째 Step 설정
              .next(chunkStep())      // 다음 Step 설정
              .incrementer(new RunIdIncrementer()) // Job 실행 시마다 ID 증가
              .listener(new JobExecutionListener() { /* 콜백 로직 */ })
              .build();
  }
  ```
  - **`JobBuilder`**를 사용하여 **Job**을 생성하고, **Step**을 연결하여 **Job의 흐름**을 정의합니다.
  - **`incrementer()`**와 **`listener()`**를 통해 **Job**의 실행 방식을 제어할 수 있습니다.

### 5.1.5 스프링 배치 5.x 버전의 개선 사항
- **팩토리 사용 지양**: 기존의 **`StepBuilderFactory`**와 **`JobBuilderFactory`** 대신 **`StepBuilder`**와 **`JobBuilder`**를 직접 사용하여 명확하고 유연한 구성을 권장합니다.
- **확장성과 유지보수성 향상**: 빌더를 직접 사용함으로써 **의존성 주입의 복잡성**을 줄이고, **배치 구성의 명확성**과 **유지보수성**을 높일 수 있습니다.
- **빈 정의 방식** 권장: **XML 설정** 대신 **Java Configuration** 방식으로 **Job**과 **Step**을 설정하여 코드의 가독성을 높이고, 관리의 용이성을 제공합니다.

### 5.1.6 결론
- **Task 기반 Step**은 단일 작업을 처리하는 데 적합하며, 반복적인 작업은 **RepeatTemplate**을 사용해 반복합니다.
- **Chunk 기반 Step**은 대용량 데이터를 효율적으로 처리하는 데 적합하며, **ItemReader, ItemProcessor, ItemWriter**를 통해 데이터를 나누어 처리합니다.
- **스프링 배치 5.x**에서는 **팩토리 클래스 대신 직접 빌더**를 사용하는 방식이 권장되며, 이를 통해 **코드의 명확성**과 **유연성**을 높일 수 있습니다.



## 5.2 TaskletStep - 개념 및 API 소개
### 5.2.1 기본 개념
- 스프링 배치에서 제공하는 Step 구현체로서 Tasklet을 실행시키는 도메인 객체
- RepeatTemplate를 사용해서 Tasklet의 구문을 트랜잭션 경계 내에서 반복해서 실행함
- Task 기반과 Chunk 기반으로 나누어서 Tasklet을 실행함

### 5.2.2 Task vs Chunk 기반 비교
- 스프링 배치에서 Step의 실행 단위는 크게 2가지로 나누어짐
	- chunk 기반
		- 하나의 큰 덩어리를 n개씩 나눠서 실행한다는 의미로 대량 처리를 하는 경우 효과적으로 설계 됨
		- ItemReader, ItemProcessor, ItemWriter를 사용하며 청크 기반 전용 Tasklet인 ChunkOrientedTasklet 구현체가 제공된다.
	- Task 기반
		- ItemReader와 ItemWriter와 같은 청크 기반의 작업보다 단일 작업 기반으로 처리되는 것이 더 효율적인 경우
		- 주로 Tasklet 구현체를 만들어 사용
		- 대량 처리를 하는 경우 chunk 기반에 비해 더 복잡한 구현 필요



## 5.3 TaskletStep - tasklet()


## 5.4 TaskletStep - startLimit() / allowStartIfComplete()


## 5.5 TaskletStep 아키텍처


## 5.6 JobStep

