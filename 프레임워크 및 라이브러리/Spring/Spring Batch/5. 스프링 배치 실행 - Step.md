# 5. 스프링 배치 실행 - Step
## 5.1 StepBuilderFactory
스프링 배치 5.x 버전에서는 **`StepBuilderFactory`** 와 **`JobBuilderFactory`** 의 사용이 더 이상 권장되지 않으며, **`StepBuilder`** 와 **`JobBuilder`** 를 **직접 사용하는 방식**이 기본적인 모범 사례로 자리잡고 있습니다. 이를 통해 설정을 더 명확하게 하고 의존성 주입의 복잡성을 줄일 수 있습니다. 아래에서는 스프링 배치에서 **Task 기반**과 **Chunk 기반** Step을 **빌더 방식**으로 설명하겠습니다.

### 5.1.1 StepBuilderFactory
- **`StepBuilderFactory`** 는 **StepBuilder**를 생성하는 팩토리 클래스로, **`get(String name)`** 메서드를 제공합니다.
- **`StepBuilderFactory.get("stepName")`**: **`stepName`** 으로 **StepBuilder**를 생성하여 Step을 구성합니다.

### 5.1.2 StepBuilder
- **StepBuilder**는 Step을 구성하는 설정 조건에 따라 다섯 개의 하위 빌더 클래스를 생성하고 실제 Step 생성을 위임합니다.
  - **TaskletStepBuilder**: **TaskletStep**을 생성하는 기본 빌더 클래스입니다.
  - **SimpleStepBuilder**: **TaskletStep**을 생성하며, 내부적으로 청크 기반의 작업을 처리하는 **ChunkOrientedTasklet** 클래스를 생성합니다.
  - **PartitionStepBuilder**: **PartitionStep**을 생성하며, **멀티 스레드 방식**으로 Job을 실행합니다.
  - **JobStepBuilder**: **JobStep**을 생성하여 **Step** 안에서 **Job**을 실행합니다.
  - **FlowStepBuilder**: **FlowStep**을 생성하여 **Step** 안에서 **Flow**를 실행합니다.

### 5.1.3 기본 개념: Step과 Tasklet
- **Step**: 작업 단위로, 스프링 배치에서 제공하는 **Tasklet** 또는 **Chunk** 기반으로 작업을 정의합니다.
- **Tasklet**: 하나의 단위 작업을 정의하는 인터페이스로, **RepeatTemplate**을 통해 **반복 실행**할 수 있습니다.
- **Chunk 기반** Step은 대용량 데이터를 **Chunk 단위**로 나누어 처리하며, **ItemReader**, **ItemProcessor**, **ItemWriter**를 사용합니다.

### 5.1.4 Task 기반 vs Chunk 기반 비교
#### **Task 기반**
- **단일 작업**에 적합하며, **ItemReader/Processor/Writer**를 사용하지 않고 단순 작업을 수행합니다.
- **반복적인 작업**을 처리할 때는 **RepeatTemplate**을 통해 반복 실행합니다.
- 예를 들어, **디렉토리 정리**나 **파일 삭제**와 같은 작업에 적합합니다.

#### **Chunk 기반**
- 대량 데이터를 효율적으로 처리하기 위해 **Chunk 단위**로 작업을 나눠 실행합니다.
- **ItemReader**로 데이터를 읽고, **ItemProcessor**로 처리한 후, **ItemWriter**로 데이터를 저장하는 방식입니다.
- **대용량 데이터 처리**에 매우 적합하며, 예를 들어 **데이터 마이그레이션**이나 **파일의 대량 처리** 등에 활용됩니다.

### 5.1.5 Step 생성: 빌더 방식
스프링 배치 5.x에서는 **`StepBuilder`**와 **`JobBuilder`**를 직접 사용하여 **Step**과 **Job**을 생성합니다. 이를 통해 설정의 **명확성**과 **유연성**을 높일 수 있습니다.

#### Task 기반 Step 생성
- **Tasklet**을 사용하여 Step을 생성하는 방식입니다. 아래는 **Task 기반 Step**을 생성하는 예제입니다.

  ```java
  @Bean
  public Step taskStep() {
      StepBuilder stepBuilder = new StepBuilder("taskStep");
      return stepBuilder
              .tasklet(myTasklet())  // Tasklet 설정
              .startLimit(5)         // Step의 실행 횟수 제한
              .allowStartIfComplete(true) // 완료 후에도 재실행 허용
              .listener(new StepExecutionListener() { /* 콜백 로직 */ })
              .build();
  }
  ```
  - **`StepBuilder`** 를 직접 생성하여 사용하며, **Tasklet**을 설정한 후 **Step**을 빌드합니다.
  - **`startLimit`** 과 **`allowStartIfComplete`** 등의 설정을 통해 **Step**의 동작을 제어합니다.

#### Chunk 기반 Step 생성
- **Chunk 기반 Step**은 대용량 데이터를 처리하기 위해 데이터를 **Chunk 단위로 나누어** 처리합니다. 아래는 **Chunk 기반 Step**을 생성하는 예제입니다.

  ```java
  @Bean
  public Step chunkStep() {
      StepBuilder stepBuilder = new StepBuilder("chunkStep");
      return stepBuilder
              .<InputType, OutputType>chunk(100) // Chunk 크기 설정
              .reader(itemReader())              // ItemReader 설정
              .processor(itemProcessor())        // ItemProcessor 설정
              .writer(itemWriter())              // ItemWriter 설정
              .faultTolerant()                   // 오류 허용 설정 (옵션)
              .retryLimit(3)                     // 재시도 횟수 설정 (옵션)
              .build();
  }
  ```
  - **`StepBuilder`**를 사용하여 **Chunk 기반 Step**을 생성하며, **ItemReader**, **ItemProcessor**, **ItemWriter**를 설정하여 데이터를 처리합니다.
  - **`faultTolerant()`**와 **`retryLimit()`**을 통해 **오류 허용** 및 **재시도** 기능을 설정할 수 있습니다.

### 5.1.6 Job 생성: 빌더 방식
- **Job**은 하나 이상의 **Step**으로 구성됩니다. **JobBuilder**를 사용하여 **Job**을 생성하고, 각 **Step**을 연결하여 배치 작업의 흐름을 정의합니다.

  ```java
  @Bean
  public Job myJob() {
      JobBuilder jobBuilder = new JobBuilder("myJob");
      return jobBuilder
              .start(taskStep())      // 첫 번째 Step 설정
              .next(chunkStep())      // 다음 Step 설정
              .incrementer(new RunIdIncrementer()) // Job 실행 시마다 ID 증가
              .listener(new JobExecutionListener() { /* 콜백 로직 */ })
              .build();
  }
  ```
  - **`JobBuilder`** 를 사용하여 **Job**을 생성하고, **Step**을 연결하여 **Job의 흐름**을 정의합니다.
  - **`incrementer()`** 와 **`listener()`** 를 통해 **Job**의 실행 방식을 제어할 수 있습니다.

### 5.1.7 스프링 배치 5.x 버전의 개선 사항
- **팩토리 사용 지양**: 기존의 **`StepBuilderFactory`** 와 **`JobBuilderFactory`** 대신 **`StepBuilder`** 와 **`JobBuilder`** 를 직접 사용하여 명확하고 유연한 구성을 권장합니다.
- **확장성과 유지보수성 향상**: 빌더를 직접 사용함으로써 **의존성 주입의 복잡성**을 줄이고, **배치 구성의 명확성**과 **유지보수성**을 높일 수 있습니다.
- **빈 정의 방식** 권장: **XML 설정** 대신 **Java Configuration** 방식으로 **Job**과 **Step**을 설정하여 코드의 가독성을 높이고, 관리의 용이성을 제공합니다.

### 5.1.8 결론
- **Task 기반 Step**은 단일 작업을 처리하는 데 적합하며, 반복적인 작업은 **RepeatTemplate**을 사용해 반복합니다.
- **Chunk 기반 Step**은 대용량 데이터를 효율적으로 처리하는 데 적합하며, **ItemReader, ItemProcessor, ItemWriter**를 통해 데이터를 나누어 처리합니다.
- **스프링 배치 5.x**에서는 **팩토리 클래스 대신 직접 빌더**를 사용하는 방식이 권장되며, 이를 통해 **코드의 명확성**과 **유연성**을 높일 수 있습니다.

## 5.2 TaskletStep - 개념 및 API 소개
스프링 배치 5.x 버전에서는 **`StepBuilderFactory`** 와 **`JobBuilderFactory`** 의 사용이 더 이상 권장되지 않으며, **`StepBuilder`** 와 **`JobBuilder`** 를 **직접 사용하는 방식**이 기본적인 모범 사례로 자리잡고 있습니다. 이를 통해 설정을 더 명확하게 하고 의존성 주입의 복잡성을 줄일 수 있습니다. 아래에서는 스프링 배치에서 **Task 기반**과 **Chunk 기반** Step을 **빌더 방식**으로 설명하겠습니다.

### 5.2.1 기본 개념: Step과 Tasklet
- **Step**: 작업 단위로, 스프링 배치에서 제공하는 **Tasklet** 또는 **Chunk** 기반으로 작업을 정의합니다.
- **Tasklet**: 하나의 단위 작업을 정의하는 인터페이스로, **RepeatTemplate**을 통해 **반복 실행**할 수 있습니다.
- **Chunk 기반** Step은 대용량 데이터를 **Chunk 단위**로 나누어 처리하며, **ItemReader**, **ItemProcessor**, **ItemWriter**를 사용합니다.

### 5.2.2 Task 기반 vs Chunk 기반 비교
#### Task 기반
- **단일 작업**에 적합하며, **ItemReader/Processor/Writer**를 사용하지 않고 단순 작업을 수행합니다.
- **반복적인 작업**을 처리할 때는 **RepeatTemplate**을 통해 반복 실행합니다.
- 예를 들어, **디렉토리 정리**나 **파일 삭제**와 같은 작업에 적합합니다.

#### Chunk 기반
- 대량 데이터를 효율적으로 처리하기 위해 **Chunk 단위**로 작업을 나눠 실행합니다.
- **ItemReader**로 데이터를 읽고, **ItemProcessor**로 처리한 후, **ItemWriter**로 데이터를 저장하는 방식입니다.
- **대용량 데이터 처리**에 매우 적합하며, 예를 들어 **데이터 마이그레이션**이나 **파일의 대량 처리** 등에 활용됩니다.

### 5.2.3 Step 생성: 빌더 방식
스프링 배치 5.x에서는 **`StepBuilder`**와 **`JobBuilder`**를 직접 사용하여 **Step**과 **Job**을 생성합니다. 이를 통해 설정의 **명확성**과 **유연성**을 높일 수 있습니다.

#### Task 기반 Step 생성
- **Tasklet**을 사용하여 Step을 생성하는 방식입니다. 아래는 **Task 기반 Step**을 생성하는 예제입니다.

  ```java
  @Bean
  public Step taskStep() {
      StepBuilder stepBuilder = new StepBuilder("taskStep");
      return stepBuilder
              .tasklet(myTasklet())  // Tasklet 설정
              .startLimit(5)         // Step의 실행 횟수 제한
              .allowStartIfComplete(true) // 완료 후에도 재실행 허용
              .listener(new StepExecutionListener() { /* 콜백 로직 */ })
              .build();
  }
  ```
  - **`StepBuilder`**를 직접 생성하여 사용하며, **Tasklet**을 설정한 후 **Step**을 빌드합니다.
  - **`startLimit`**과 **`allowStartIfComplete`** 등의 설정을 통해 **Step**의 동작을 제어합니다.

#### Chunk 기반 Step 생성
- **Chunk 기반 Step**은 대용량 데이터를 처리하기 위해 데이터를 **Chunk 단위로 나누어** 처리합니다. 아래는 **Chunk 기반 Step**을 생성하는 예제입니다.

  ```java
  @Bean
  public Step chunkStep() {
      StepBuilder stepBuilder = new StepBuilder("chunkStep");
      return stepBuilder
              .<InputType, OutputType>chunk(100) // Chunk 크기 설정
              .reader(itemReader())              // ItemReader 설정
              .processor(itemProcessor())        // ItemProcessor 설정
              .writer(itemWriter())              // ItemWriter 설정
              .faultTolerant()                   // 오류 허용 설정 (옵션)
              .retryLimit(3)                     // 재시도 횟수 설정 (옵션)
              .build();
  }
  ```
  - **`StepBuilder`**를 사용하여 **Chunk 기반 Step**을 생성하며, **ItemReader**, **ItemProcessor**, **ItemWriter**를 설정하여 데이터를 처리합니다.
  - **`faultTolerant()`**와 **`retryLimit()`**을 통해 **오류 허용** 및 **재시도** 기능을 설정할 수 있습니다.

### 5.2.4 Job 생성: 빌더 방식
- **Job**은 하나 이상의 **Step**으로 구성됩니다. **JobBuilder**를 사용하여 **Job**을 생성하고, 각 **Step**을 연결하여 배치 작업의 흐름을 정의합니다.

  ```java
  @Bean
  public Job myJob() {
      JobBuilder jobBuilder = new JobBuilder("myJob");
      return jobBuilder
              .start(taskStep())      // 첫 번째 Step 설정
              .next(chunkStep())      // 다음 Step 설정
              .incrementer(new RunIdIncrementer()) // Job 실행 시마다 ID 증가
              .listener(new JobExecutionListener() { /* 콜백 로직 */ })
              .build();
  }
  ```
  - **`JobBuilder`** 를 사용하여 **Job**을 생성하고, **Step**을 연결하여 **Job의 흐름**을 정의합니다.
  - **`incrementer()`** 와 **`listener()`**를 통해 **Job**의 실행 방식을 제어할 수 있습니다.

### 5.2.5 스프링 배치 5.x 버전의 개선 사항
- **팩토리 사용 지양**: 기존의 **`StepBuilderFactory`** 와 **`JobBuilderFactory`** 대신 **`StepBuilder`** 와 **`JobBuilder`** 를 직접 사용하여 명확하고 유연한 구성을 권장합니다.
- **확장성과 유지보수성 향상**: 빌더를 직접 사용함으로써 **의존성 주입의 복잡성**을 줄이고, **배치 구성의 명확성**과 **유지보수성**을 높일 수 있습니다.
- **빈 정의 방식** 권장: **XML 설정** 대신 **Java Configuration** 방식으로 **Job**과 **Step**을 설정하여 코드의 가독성을 높이고, 관리의 용이성을 제공합니다.

### 5.2.6 결론
- **Task 기반 Step**은 단일 작업을 처리하는 데 적합하며, 반복적인 작업은 **RepeatTemplate**을 사용해 반복합니다.
- **Chunk 기반 Step**은 대용량 데이터를 효율적으로 처리하는 데 적합하며, **ItemReader, ItemProcessor, ItemWriter**를 통해 데이터를 나누어 처리합니다.
- **스프링 배치 5.x**에서는 **팩토리 클래스 대신 직접 빌더**를 사용하는 방식이 권장되며, 이를 통해 **코드의 명확성**과 **유연성**을 높일 수 있습니다.

## 5.3 TaskletStep - tasklet()
### 5.3.1 기본 개념
- **Tasklet** 타입의 클래스를 설정하여 **TaskletStep**을 생성합니다.
- **Tasklet**은 **Step** 내에서 구성되고 실행되는 도메인 객체로서 주로 **단일 태스크**를 수행하기 위한 것입니다.
- **TaskletStep**에 의해 반복적으로 수행되며, 반환값에 따라 계속 수행되거나 종료됩니다.

### 5.3.2 RepeatStatus와 반복 실행
- **RepeatStatus**: **Tasklet**의 반복 여부 상태를 나타내는 값입니다.
  - **`RepeatStatus.FINISHED`**: **Tasklet** 종료. **`null`**로 반환하면 **`RepeatStatus.FINISHED`**로 해석됩니다.
  - **`RepeatStatus.CONTINUABLE`**: **Tasklet**이 반복되어야 함을 나타냅니다.
- **`RepeatStatus.FINISHED`**가 리턴되거나 실패 예외가 던져지기 전까지 **TaskletStep**에 의해 **while**문 안에서 반복적으로 호출됩니다. (무한루프 주의)

### 5.3.3 Tasklet 설정과 사용
- **익명 클래스**나 **구현 클래스를 만들어서** 사용할 수 있습니다.
- 이 메소드를 실행하게 되면 **TaskletStepBuilder**가 반환되어 관련 API를 설정할 수 있습니다.
- **Step**에는 오직 하나의 **Tasklet**만 설정 가능하며, 두 개 이상 설정할 경우 **마지막에 설정한 객체**가 실행됩니다.

### 5.3.4 Tasklet의 구조:
- `RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext)` 메서드를 통해 실행됩니다.

#### TaskletStep 예제 코드
```java
public Step batchStep() {
    StepBuilder stepBuilder = new StepBuilder("batchStep");
    return stepBuilder
            .tasklet(new Tasklet() {
                @Override
                public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
                    // To do Business Logic
                    return RepeatStatus.FINISHED;
                }
            })
            .startLimit(10)  // Step의 실행 횟수 제한
            .allowStartIfComplete(true)  // Step 완료 후 재실행 허용
            .listener(new StepExecutionListener() { /* 콜백 로직 */ })
            .build();
}
```
- 위 예제에서는 **익명 클래스**로 **Tasklet**을 정의하고, 비즈니스 로직을 수행한 후 **`RepeatStatus.FINISHED`** 를 반환합니다.
- **`startLimit(10)`** 을 통해 Step의 최대 실행 횟수를 설정하고, **`allowStartIfComplete(true)`** 로 완료 후에도 재실행을 허용합니다.
- **`StepExecutionListener`** 를 설정하여 Step의 실행 전후에 특정 로직을 수행할 수 있습니다.

### 5.3.5 결론
- **Tasklet**은 단일 작업을 반복 수행하기 위한 방식으로, 주로 단순하고 반복적인 작업에 적합합니다.
- **RepeatStatus**를 통해 Tasklet의 반복 여부를 제어하며, **익명 클래스**나 **구현 클래스**로 정의할 수 있습니다.
- **TaskletStep**을 구성할 때, **빌더 패턴**을 사용하여 각종 설정을 유연하게 추가할 수 있습니다.
- **Task 기반 Step**은 **Chunk 기반 Step**과는 달리 **단일 작업**에 집중하며, 반복적인 로직의 경우 **`RepeatStatus`**를 통해 제어합니다.


## 5.4 TaskletStep - startLimit() / allowStartIfComplete()


## 5.5 TaskletStep 아키텍처


## 5.6 JobStep

