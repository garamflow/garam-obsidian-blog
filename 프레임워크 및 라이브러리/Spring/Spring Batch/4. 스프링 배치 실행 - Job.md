# 4. 스프링 배치 실행 - Job
## 4.1 배치 초기화 설정
### 4.1.1 JobLauncherApplicationRunner
- **JobLauncherApplicationRunner**는 **Spring Batch** 작업을 시작하는 **ApplicationRunner**의 구현체로, 애플리케이션이 구동된 후 **Spring Batch**의 모든 **Job**을 실행하는 역할을 합니다.
- **BatchAutoConfiguration**에서 생성되며, **Spring Boot** 애플리케이션이 정상적으로 시작되면 **JobLauncherApplicationRunner**가 자동으로 등록된 **Job**을 실행합니다.
- 기본적으로 **모든 Job**이 실행되지만, 특정 **Job**을 지정하여 실행할 수도 있습니다.

### 4.1.2 BatchProperties
- **BatchProperties**는 **Spring Batch**의 환경 설정을 관리하는 구성 클래스입니다. 이를 통해 **Job**의 이름, 스키마 초기화, 테이블 접두사 등 배치 관련 설정을 할 수 있습니다.
- **application.properties** 또는 **application.yml** 파일에서 설정합니다.

- **설정 가능한 항목**:
	- **job.names**: 실행할 **Job**의 이름을 지정합니다. 여러 **Job**을 실행할 경우 쉼표로 구분합니다.
	- **initialize-schema**: 배치 테이블 스키마를 초기화할지 여부를 설정합니다. 기본값은 `NEVER`이며, 필요 시 `ALWAYS`, `EMBEDDED` 등으로 설정할 수 있습니다.
	- **tablePrefix**: 배치 메타데이터 테이블의 접두사를 설정합니다. 기본값은 `BATCH_`입니다.

- **application.yml** 예시:
```yaml
batch:
	job:
	  names: ${job.name:NONE}
	initialize-schema: NEVER
	tablePrefix: SYSTEM
```

### 4.1.3 Job 실행 옵션
- 기본적으로 **JobLauncherApplicationRunner**는 모든 등록된 **Job**을 실행하지만, 특정 **Job**만 실행하도록 설정할 수 있습니다.
- **Program arguments**로 실행할 **Job**의 이름을 지정합니다.
- 여러 **Job**을 실행하려면 쉼표로 구분합니다.
- **명령어 예시**:
```bash
--job.name=helloJob
--job.name=helloJob,simpleJob
```

**application.yml**에서 설정된 값이 없으면 **Job**은 실행되지 않습니다:
```yaml
batch:
	job:
	  names: NONE
```

### 4.1.4 동기 및 비동기 실행
- **JobLauncher**의 실행 방식은 동기 및 비동기로 설정할 수 있습니다:
	- **동기적 실행**: 기본적으로 **SyncTaskExecutor**를 사용하며, 배치 작업이 완료된 후 **JobExecution**을 반환합니다.
	- **비동기적 실행**: **SimpleAsyncTaskExecutor**를 사용해 작업을 백그라운드에서 처리하고, 즉시 **JobExecution**을 반환합니다. 이는 HTTP 요청 기반의 배치 처리에 적합합니다.

### 4.1.5 최신 버전 기준으로 **Job Name** 설정과 **YAML** 연동을 설명하는 예시입니다.
#### 1. YAML 설정 파일 (application.yml)
```yaml
batch:
  job:
    names: ${job.name:NONE}  # 실행할 Job 이름을 환경변수나 CLI 인자로 받아옴
```
- **`${job.name:NONE}`**: 환경변수나 **CLI 인자**로 전달된 **job.name** 값이 있으면 그 값을 사용하고, 없으면 기본값으로 `NONE`을 사용한다는 의미입니다.

#### 2. 실제 코드 (최신 버전 기준)
```java
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.PlatformTransactionManager;

@Configuration
@EnableBatchProcessing
public class BatchJobConfig {

    private final JobRepository jobRepository;
    private final PlatformTransactionManager transactionManager;

    public BatchJobConfig(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
        this.jobRepository = jobRepository;
        this.transactionManager = transactionManager;
    }

    @Bean
    public Job myJob() {
        return new JobBuilder("myJob", jobRepository)
            .start(step1())
            .build();
    }

    @Bean
    public Job simpleJob() {
        return new JobBuilder("simpleJob", jobRepository)
            .start(step2())
            .build();
    }

    @Bean
    public Step step1() {
        return new StepBuilder("step1", jobRepository)
            .tasklet(myTasklet(), transactionManager)
            .build();
    }

    @Bean
    public Step step2() {
        return new StepBuilder("step2", jobRepository)
            .tasklet(myTasklet(), transactionManager)
            .build();
    }

    @Bean
    public Tasklet myTasklet() {
        return (contribution, chunkContext) -> {
            System.out.println("Tasklet executed");
            return RepeatStatus.FINISHED;
        };
    }
}
```

#### 3. 코드 설명
- **JobBuilder**와 **StepBuilder**는 **JobRepository**와 함께 사용하여 배치 작업을 설정합니다. 이는 5.x 버전에서 권장되는 방식입니다.
- **JobRepository**는 배치 실행 중 메타데이터를 저장하고, **PlatformTransactionManager**를 사용하여 트랜잭션을 관리합니다.
- 각 **Step**은 **Tasklet**을 사용하여 작업을 정의하고 실행합니다.

#### 4. CLI 명령어로 Job Name 설정 및 실행
```bash
java -jar your-spring-batch-app.jar --job.name=myJob
```
- 위 명령어로 **YAML 파일**의 `${job.name}`에 `myJob` 값을 전달하여 **myJob**이 실행됩니다.

## 4.2 JobBuilderFactory / JobBuilder
Spring Batch 5.x 버전에서는 **JobBuilderFactory**와 관련된 일부 변경사항이 있으며, 더 이상 사용되지 않는 메서드나 클래스도 존재합니다. 5.x 이후 버전에서는 새로운 방식으로 **Job**과 **Step**을 설정하며, **JobRepository**를 기반으로 메타데이터를 관리하는 방식이 강조됩니다. 이를 기반으로 질문하신 내용을 최신 버전으로 변환하여 설명하겠습니다.

### 4.2.1 최신 버전에서의 JobBuilder 및 StepBuilder
Spring Batch 5.x 이후, **JobBuilderFactory**와 **StepBuilderFactory**는 더 이상 권장되지 않으며, 대신 **JobRepository**를 활용한 **JobBuilder** 및 **StepBuilder**를 직접 사용하는 방식으로 변경되었습니다.

### 4.2.2 JobBuilderFactory (Deprecated)
이전 버전에서는 **JobBuilderFactory**를 사용하여 **JobBuilder**를 생성하였으며, **get(String name)** 메서드를 통해 **Job**을 생성했습니다. 그러나, 5.x 버전 이후에는 **JobBuilderFactory** 대신 **JobBuilder**를 직접 사용하여 **Job**을 구성합니다.

#### 이전 버전 (4.x):
```java
// Deprecated 방식
@Autowired
private JobBuilderFactory jobBuilderFactory;

@Bean
public Job myJob() {
    return jobBuilderFactory.get("myJob")
            .start(step1())
            .build();
}
```

#### 최신 버전 (5.x):
```java
@Bean
public Job myJob(JobRepository jobRepository) {
    return new JobBuilder("myJob", jobRepository)
            .start(step1(jobRepository))
            .build();
}
```
- **JobRepository**는 배치 작업 실행에 필요한 메타데이터를 저장하고 관리합니다.
- **JobBuilder**는 **JobRepository**와 함께 사용되어 **Job**을 설정하고, 배치 작업 중 실행 정보를 기록합니다.

### 4.2.3 JobBuilder 및 하위 클래스 (SimpleJobBuilder, FlowJobBuilder)
**JobBuilder**는 **Job**을 설정하는 주요 클래스입니다. 5.x 이후에도 이 클래스는 그대로 사용되며, **SimpleJobBuilder**와 **FlowJobBuilder**로 나뉘어 **Job**을 구성합니다.

#### 1. SimpleJobBuilder:
- **SimpleJob**을 생성하는 빌더 클래스입니다. 배치 작업에서 가장 일반적인 형태의 **Job**을 설정하는 데 사용됩니다.
- **start(Step)**, **next(Step)** 와 같은 메서드를 통해 **Step** 간의 순차적 흐름을 설정할 수 있습니다.

```java
@Bean
public Job simpleJob(JobRepository jobRepository) {
    return new JobBuilder("simpleJob", jobRepository)
            .start(step1(jobRepository))
            .next(step2(jobRepository))
            .build();
}
```

#### 2. FlowJobBuilder:
- **FlowJob**을 생성하는 빌더 클래스입니다. **Flow** 기반으로 **Job**을 구성할 때 사용되며, 복잡한 흐름을 설정할 수 있습니다.
- 내부적으로 **FlowBuilder**를 반환하여, **Flow**의 조건에 따른 **Step** 실행을 정의할 수 있습니다.

```java
@Bean
public Job flowJob(JobRepository jobRepository) {
    return new JobBuilder("flowJob", jobRepository)
            .start(flowStep1(jobRepository))
            .on("COMPLETED").to(flowStep2(jobRepository))
            .end()
            .build();
}
```
- **on("COMPLETED")**: 특정 **Step**이 성공했을 때 다음 **Step**으로 넘어가는 흐름을 정의합니다.
- **FlowJob**은 복잡한 배치 흐름을 제어할 때 유용합니다.

### 4.2.4 JobRepository 사용
5.x 버전에서 **JobRepository**는 **Job**과 **Step**의 실행 메타데이터를 저장하는 핵심 컴포넌트로, **JobBuilder**와 **StepBuilder**에 필수로 제공되어야 합니다. **JobRepository**를 통해 각 배치 작업의 실행 상태 및 메타데이터를 관리합니다.

```java
@Bean
public JobRepository jobRepository(DataSource dataSource, PlatformTransactionManager transactionManager) {
    return new JobRepositoryFactoryBean()
            .setDataSource(dataSource)
            .setTransactionManager(transactionManager)
            .getObject();
}
```

### 4.2.5 StepBuilder
- **StepBuilder**는 각 **Step**을 설정하는 데 사용되며, **Tasklet** 기반의 **Step**이나 **Chunk** 기반의 **Step**을 정의할 수 있습니다.

#### StepBuilder 최신 버전 (5.x):
```java
@Bean
public Step step1(JobRepository jobRepository) {
    return new StepBuilder("step1", jobRepository)
            .tasklet(myTasklet(), transactionManager)
            .build();
}
```
- **JobRepository**와 **TransactionManager**가 **StepBuilder**와 함께 사용됩니다.
- **Tasklet**을 통해 단순한 배치 작업을 수행하거나, **Chunk**를 통해 대량 데이터를 처리하는 작업을 설정할 수 있습니다.


### 4.2.6 JobBuilder 클래스 및 하위 클래스
#### 1. JobBuilder
- **JobBuilder**는 **Job**을 생성하는 빌더 클래스입니다. **Job**을 설정하고 실행 흐름을 정의할 때 사용되며, **SimpleJobBuilder** 또는 **FlowJobBuilder**를 반환합니다.
- **JobBuilder**는 두 가지 주요 하위 클래스를 통해 **Job**을 생성합니다: **SimpleJobBuilder**와 **FlowJobBuilder**.

**JobBuilder 생성자**:
```java
public JobBuilder(String name, JobRepository jobRepository)
```
- **name**: 배치 작업의 이름을 지정합니다. 이 이름은 **JobRepository**에서 **Job**을 고유하게 식별하는 데 사용되며, 메타데이터에 저장됩니다.
- **jobRepository**: **JobRepository**는 **Job**의 실행 상태 및 메타데이터를 관리하는 객체입니다. **Job**이 실행될 때마다 해당 정보를 **JobRepository**에 기록합니다.

```java
// 예시
JobBuilder jobBuilder = new JobBuilder("myJob", jobRepository);
```

#### **1.2 SimpleJobBuilder**
- **SimpleJobBuilder**는 순차적으로 **Step**을 실행하는 **SimpleJob**을 생성하는 클래스입니다. 일반적인 배치 작업에서 가장 많이 사용됩니다.
  
**start(Step step)**:
```java
public SimpleJobBuilder start(Step step)
```
- **step**: 배치 작업에서 가장 먼저 실행될 **Step** 객체를 전달합니다. 이 메서드는 작업의 첫 번째 **Step**을 지정합니다.

**next(Step step)**:
```java
public SimpleJobBuilder next(Step step)
```
- **step**: 앞서 정의한 **Step**이 완료된 후 실행할 다음 **Step**을 정의합니다. 이 메서드를 사용하여 여러 **Step**을 순차적으로 연결할 수 있습니다.

```java
// SimpleJobBuilder 예시
@Bean
public Job myJob(JobRepository jobRepository) {
    return new JobBuilder("mySimpleJob", jobRepository)
        .start(step1(jobRepository))
        .next(step2(jobRepository))
        .build();
}
```
- **start** 메서드는 배치 작업의 첫 번째 **Step**을 설정하고, **next** 메서드는 그 다음 **Step**을 설정합니다. 이와 같이 여러 **Step**을 순차적으로 연결하여 **SimpleJob**을 구성할 수 있습니다.

#### **1.3 FlowJobBuilder**
- **FlowJobBuilder**는 **Step** 간의 흐름을 조건에 따라 제어할 수 있는 **FlowJob**을 생성하는 클래스입니다.

**start(Step step)**:
```java
public FlowJobBuilder start(Step step)
```
- **step**: **FlowJob**에서 첫 번째로 실행할 **Step**을 설정합니다. **FlowJob**의 흐름은 조건에 따라 달라질 수 있습니다.

**on(String exitCode)**:
```java
public FlowJobBuilder on(String exitCode)
```
- **exitCode**: 이전 **Step**의 종료 코드에 따라 다음 흐름을 결정합니다. 예를 들어, 이전 **Step**이 정상적으로 완료되면 `"COMPLETED"`를 설정하여 특정 **Step**을 실행하도록 할 수 있습니다.

**to(Step step)**:
```java
public FlowJobBuilder to(Step step)
```
- **step**: 이전 조건에 맞는 경우 실행할 **Step**을 지정합니다.

```java
// FlowJobBuilder 예시
@Bean
public Job myFlowJob(JobRepository jobRepository) {
    return new JobBuilder("myFlowJob", jobRepository)
        .start(step1(jobRepository))
        .on("COMPLETED").to(step2(jobRepository))
        .on("FAILED").to(step3(jobRepository))
        .end()
        .build();
}
```
- 위 예시는 **Step1**이 완료되면 **Step2**를 실행하고, 실패하면 **Step3**로 흐름을 제어하는 조건 기반의 **FlowJob** 설정입니다.

### **2. StepBuilder 클래스 및 하위 클래스**

#### **2.1 StepBuilder**
- **StepBuilder**는 **Step**을 생성하는 빌더 클래스입니다. 배치 작업에서 각각의 **Step**을 구성하는 데 사용됩니다.
  
**StepBuilder 생성자**:
```java
public StepBuilder(String name, JobRepository jobRepository)
```
- **name**: 이 **Step**의 이름을 지정합니다. **JobRepository**에서 **Step**을 고유하게 식별하는 데 사용됩니다.
- **jobRepository**: **JobRepository**는 **Step**의 실행 상태와 메타데이터를 저장하고 관리하는 역할을 합니다.

```java
// 예시
StepBuilder stepBuilder = new StepBuilder("step1", jobRepository);
```

#### **2.2 TaskletStepBuilder**
- **TaskletStepBuilder**는 **Tasklet**을 실행하는 **Step**을 설정하는 클래스입니다. **Tasklet**은 단순 작업을 처리할 때 사용됩니다.

**tasklet(Tasklet tasklet, PlatformTransactionManager transactionManager)**:
```java
public TaskletStepBuilder tasklet(Tasklet tasklet, PlatformTransactionManager transactionManager)
```
- **tasklet**: 실제로 실행할 **Tasklet** 객체를 전달합니다. **Tasklet**은 배치에서 단일 작업을 처리하는 역할을 합니다.
- **transactionManager**: **Tasklet**이 실행되는 동안 트랜잭션을 관리하는 객체입니다. 배치 작업이 성공하거나 실패할 때 트랜잭션을 커밋하거나 롤백합니다.

```java
// TaskletStepBuilder 예시
@Bean
public Step step1(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
    return new StepBuilder("step1", jobRepository)
        .tasklet(myTasklet(), transactionManager)
        .build();
}
```

#### **2.3 ChunkStepBuilder**
- **ChunkStepBuilder**는 **Chunk** 단위로 데이터를 처리하는 **Step**을 설정하는 클래스입니다. **ItemReader**, **ItemProcessor**, **ItemWriter**를 사용하여 데이터를 청크 단위로 처리할 수 있습니다.

**chunk(int chunkSize)**:
```java
public ChunkStepBuilder<I, O> chunk(int chunkSize)
```
- **chunkSize**: 한 번에 처리할 데이터의 양(청크 크기)을 지정합니다. 예를 들어, `chunk(100)`은 한 번에 100개의 데이터를 읽고 처리하고 쓰는 단위를 의미합니다.

**reader(ItemReader<? extends I> reader)**:
```java
public ChunkStepBuilder<I, O> reader(ItemReader<? extends I> reader)
```
- **reader**: 데이터를 읽어오는 **ItemReader** 객체를 전달합니다.

**writer(ItemWriter<? super O> writer)**:
```java
public ChunkStepBuilder<I, O> writer(ItemWriter<? super O> writer)
```
- **writer**: 처리된 데이터를 쓰는 **ItemWriter** 객체를 전달합니다.

```java
// ChunkStepBuilder 예시
@Bean
public Step chunkStep(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
    return new StepBuilder("chunkStep", jobRepository)
        .<InputType, OutputType>chunk(100)   // 청크 단위로 처리할 데이터 크기
        .reader(myItemReader())
        .processor(myItemProcessor())
        .writer(myItemWriter())
        .transactionManager(transactionManager)
        .build();
}
```

### **3. JobRepository**
- **JobRepository**는 배치 작업의 모든 실행 정보를 저장하고 관리하는 데이터 저장소입니다. **Job** 및 **Step** 실행 메타데이터를 기록하고, 재실행 시 해당 데이터를 바탕으로 복구할 수 있습니다.

#### 주요 메서드
- **createJobExecution(String jobName, JobParameters jobParameters)**:
  - 새로운 **JobExecution**을 생성하고 저장합니다.
  
- **update(StepExecution stepExecution)**:
  - **StepExecution**의 상태를 업데이트하고 저장합니다.

---

### **정리**
- **JobBuilder**는 **JobRepository**와 함께 사용되며, **SimpleJobBuilder**와 **FlowJobBuilder**를 통해 각각 순차적 **Job**과 흐름 제어 기반 **Job**을 설정합니다.
- **StepBuilder**는 **TaskletStepBuilder**와 **ChunkStepBuilder**로 나뉘며, 각각 **Tasklet**과 **Chunk** 단위로 **Step**을 구성합니다.
- **JobRepository**는 **Job**과 **Step** 실행 정보를 저장하고 관리하며, 배치 작업의 실행 상태를 기록하는 중요한 역할을 합니다.

