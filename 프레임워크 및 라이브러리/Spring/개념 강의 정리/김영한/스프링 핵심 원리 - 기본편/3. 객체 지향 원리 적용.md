# 1. 새로운 할인 정책 개발
- 할인 정책을 갑자기 `주문 금액 당 %` 로 바꾸려고 한다.
## 1) `RateDiscountPolicy` 추가
![RateDiscountPolicy 추가](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/3/RateDiscountPolicy%20추가.png)

## 2) `RateDiscountPolicy` 코드 추가
```java
package hello.core.discount;  
  
import hello.core.member.Grade;  
import hello.core.member.Member;  
  
public class RateDiscountPolicy implements DiscountPolicy {  
    private int discountPercent = 10;  
    @Override  
    public int discount(Member member, int price) {  
        if (member.getGrade() == Grade.VIP) {  
            return price * discountPercent / 100;  
        } else {  
            return 0;  
        }  
    }  
}
```

## 3) `RateDiscountPolicy` 테스트
```java
package hello.core.discount;  
  
import hello.core.member.Grade;  
import hello.core.member.Member;  
import org.assertj.core.api.Assertions;  
import org.junit.jupiter.api.DisplayName;  
import org.junit.jupiter.api.Test;  
  
import static org.assertj.core.api.Assertions.*;  
import static org.junit.jupiter.api.Assertions.*;  
  
class RateDiscountPolicyTest {  
    RateDiscountPolicy discountPolicy = new RateDiscountPolicy();  
  
    @Test  
    @DisplayName("VIP는 10% 할인이 적용되어야 한다")  
    void vip_o() {  
        //given  
        Member member = new Member(1L, "memberVIP", Grade.VIP);  
  
        //when  
        int discount = discountPolicy.discount(member, 10000);  
  
        //then  
        assertThat(discount).isEqualTo(1000);  
    }  
  
    @Test  
    @DisplayName("VIP가 아니면 할인이 적용되지 않아야 한다")  
    void vip_x() {  
        //given  
        Member member = new Member(2L, "memberVIP", Grade.BASIC);  
  
        //when  
        int discount = discountPolicy.discount(member, 10000);  
  
        //then  
        assertThat(discount).isEqualTo(1000);  
    }  
}
```


# 2. 새로운 할인 정책 적용과 문제점
- 할인 정책을 변경하려면 클라이언트는 `OrderServiceImpl`에 대한 코드를 고쳐야한다.
```java
// OrderServiceImpl.java

private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
```

## 1) 문제점 발견
- 역할과 구현을 분리했다. -> OK
- 다형성도 활용하고 인터페이스와 구현 객체를 분리했다. -> OK
- OCP, DIP 같은 객체지향 설계 원칙을 충실히 준수했다. -> 그렇게 보이지만 아니다.
	- DIP : 주문 서비스 클라이언트 (`OrderServiceImpl`)은 `DiscountPolicy` 인터페이스에 의존하면서 DIP를 지킨 것 같다.
		- 클래스 의존관계를 분석해보면, 추상(인터페이스)뿐만 아니라 **구체(구현) 클래스에도 의존**하고 있다.
			- 추상(인터페이스) 의존 : `DiscountPolicy`
			- 구체(구현) 클래스 : `FixDiscountPolicy` , `RateDiscountPolicy`
	- OCP : 변경하지 않고 확장할 수 있다?
		- 지금 코드는 기능을 확장해서 변경하면, 클라이언트 코드에 영향을 주므로 **OCP 위반**

## 2) 왜 클라이언트 코드를 변경해야 할까?
![새로운 할인 정책 변경 시 문제점](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/3/새로운%20할인%20정책%20변경%20시%20문제점.png)
- **DIP 위반!**
- 인터페이스뿐만 아니라 구현체 클래스에도 의존하고 있다.

![정책 변경 (OCP 위반)](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/3/정책%20변경%20(OCP%20위반).png)
- 실제로 정책 변경을 위해서는 `RateDiscountPolicy`로 변경해야 하는데, 그러면 `OrderServiceImpl`의 코드도 변경된다. 즉, **OCP 위반!**

## 3) 그럼 어떻게 해당 문제를 해결할 수 있을까?
- 현재 클라이언트 코드인 `OrderServiceImpl`은 `DiscountPolicy`의 인터페이스 뿐만 아니라 구현 클래스도 함께 의존하고 있다.
- 그래서 구현 클래스를 변경할 때 클라이언트 코드도 변경해야 한다.

### DIP 위반 
- 추상에만 의존하도록 변경 (인터페이스에만 의존하도록)
```java
// OrderServiceImpl.java

private DiscountPolicy discountPolicy;
```
- 인터페이스에만 의존하도록 코드가 변경되었다.
- 그런데 구현체가 없으니 실행하면 NPE가 발생한다.
- 이 문제를 해결하기 위해서는 누군가가 클라이언트인 `OrderServiceImpl`에 `DiscountPolicy`의 **구현 객체를 대신 생성해서 주입해줘야한다.**


# 3. 관심사의 분리
- 이전 코드는 배우(구현체)가 직접 다른 배우를 섭외하는 것과 같은 것이다.
	- 배우가 공연도 하고 초빙도 하는 상황이다.
- 초빙하고 기획하는 것은 공연 기획자가 따로 필요하고 배우는 배우의 역할만 해야한다.

## 1) AppConfig
- 애플리케이션 전체 동작 방식을 구성(설정, config)하는 **"구현 객체"** 를 생성하고 **"연결"** 하는 책임을 가지는 별도의 설정 클래스를 만든다.

```java
package hello.core;

public class AppConfig {
	public MemberService memberService() {
		return new MemberServiceImpl(new MemoryMemberRepository());
	}

	public OrderService orderService() {
		return new OrderServiceImpl(
			new MemoryMemberRepository(),
			new FixDiscountPolicy());
	}
}
```
- AppConfig는 애플리케이션의 실제 동작에 필요한 구현 객체를 생성한다.
	- `MemberServiceImpl`
	- `MemoryMembeerRepository`
	- `OrderServiceImpl`
	- `FixDiscountPolicy`
- AppConfig는 생성한 객체 인스턴스의 참조를 생성자를 통해서 주입(연결)해준다.
	- `MemberServiceImpl` -> `MemoryMemberRepository`
	- `OrderServiceImpl` -> `MemoryMemberRepository`, `FixDiscountPolicy`

## 2) 생성자 주입

![생성자 주입 클래스 다이어그램](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/3/생성자%20주입%20클래스%20다이어그램.png)
- 객체의 생성과 연결은 `AppConfig`가 담당한다.
- **DIP 완성** : `MemberServiceImpl`은 `MemberRepository`인 추상에만 의존하면 된다. 이제 구체 클래스를 몰라도 된다.
- **관심사의 분리** : 객체를 생성하고 연결하는 역할과 실행하는 역할이 명확히 분리된다.

- `appConfig` 객체는 `memoryMemberRepsoitory` 객체를 생성하고 그 참조값을 `memberServiceImpl`을 생성하면서 생성자로 전달한다.
- 클라이언트인 `memberServiceImpl` 입장에서 의존관계를 마치 외부에서 주입해주는 것 같다고 해서 **DI(Dependency Injection) 의존관계 주입 또는 의존성 주입**이라고 한다.


# 4. AppConfig 리팩토링
```java
public class AppConfig {
	public MemberService memberService() {
		return new MemberServiceImpl(new memberRepository());
	}

	private MemberRepository memberRepository() {
		return new MemoryMemberRepository();
	}

	public OrderService orderService() {
		return new OrderServiceImpl(
			new memberRepository(),
			new discountPolicy());
	}

	private DiscountPolicy discountPolicy() {
		return new FixDiscountPolicy();
	}
}
```
- 중복이 제거되었고 다른 구현체로 변경할 때 한 부분만 변경하면 된다.
- 역할과 구현 클래스가 한눈에 들어온다.


# 5. 새로운 구조와 할인 정책 적용
- `AppConfig` 로 인해 사용 영역과 구성 영역이 나뉘게 되었다.
- 할인 정책을 바꿀 때 구성 영역에 있는 `AppConfig` 만 변경하면 되고, 사용 영역은 아무것도 바꾸지 않아도 된다.
![AppConfig를 이용해서 할인 정책 변경하기](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/3/AppConfig를%20이용해서%20할인%20정책%20변경하기.png)
- 구성 영역의 코드만 고치면 되고 사용 영역의 코드는 건들지 않아도 된다.


# 6. 전체 흐름 정리
1. 새로운 할인 정책을 개발하려고 한다.
2. 새로운 할인 정책 적용과 문제점이 생겼다.
	1. 클라이언트 코드인 서비스 구현체도 함께 변경이 되어서 **OCP를 위반**하게 된다.
	2. 추상화뿐만 아니라 구체 클래스도 의존하게 되어서 **DIP도 위반**하게 된다.
3. 관심사의 분리를 통해 해결을 한다.
	1. 애플리케이션을 하나의 공연이라고 생각했을 때, 공연기획자를 따로 만든다.
	2. 공연 기획자인 AppConfig가 등장한다. 애플리케이션 전체 동작 구성을 위해 구현 객체 생성 및 연결하는 책임을 가지고 있다.
4. AppConfig 리팩토링을 한다.
	1. 역할과 구현을 명확하게 분리하고 중복을 제거한다.
5. 새로운 구조에 할인 정책을 적용한다.


# 7. IoC, DI, 그리고 컨테이너
## 1) 제어의 역전 IoC (Inversion of Control)
- 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고, 실행했다. 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다.
- 반면에 AppConfig가 등장하면서 구현 객체는 자신의 흐름을 실행하는 역할만 담당한다. 프로그램 제어 흐름은 이제 AppConfig가 담당한다.
- 프로그램에 대한 제어 흐름에 대한 권한을 모두 AppConfig가 가지게 된다.
- 이렇듯 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것은 **제어의 역전(IoC)이라 한다.**

### 프레임워크 vs 라이브러리
- 내가 작성한 코드를 제어하고, 대신 실행하면 프레임워크 (ex. JUnit)
- 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 라이브러리

## 2) 의존관계 주입 DI (Dependency Injection)
- 의존관계는 **정적인 클래스 의존관계와 실행 시점에 결정되는 동적인 객체(인스턴스) 의존관계 들을 분리해서 생각**해야 한다.

### (1) 정적인 클래스 의존관계
- 클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단 가능하다.
- 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석할 수 있다.
![주문 도메인 클래스 다이어그램](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/2/주문%20도메인%20클래스%20다이어그램.png)

### (2) 동적인 객체(인스턴스) 의존관계
- 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존관계이다.
![주문 도메인 객체 다이아그램1](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/2/주문%20도메인%20객체%20다이아그램1.png)

### (3) 정리
- 애플리케이션 **실행 시점(런타임)** 에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존 관계가 연결 되는 것을 의존관계 주입이라고 한다.
- 객체 인스턴스를 생성하고 그 참조값을 전달해서 연결된다.
- 의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
- 의존관계 주입을 사용하면 **정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.**

## 3) IoC 컨테이너, DI 컨테이너
- AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC 컨테이너 또는 **DI 컨테이너**라 한다.
- 의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라고 한다.
- 또는 어셈블러, 오브젝트 팩토리 등으로 불리기도 한다.


# 8. 스프링으로 전환하기
- AppConfig
	- `@Configuration` 를 붙이기
	- 각 메서드에 `@Bean` 붙이기

## 스프링 컨테이너
- `ApplicationContext`를 스프링 컨테이너라 한다.
- 기존에는 개발자가 AppConfig를 사용해서 객체를 생성하고 DI를 했지만, 이제는 스프링 컨테이너를 통해서 사용한다.
- 스프링 컨테이너는 `@Configuration`이 붙은 AppConfig를 설정(구성)정보로 사용한다. 여기서 `@Bean`이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 이렇게 스프링 컨테이너에 등록된 객체를 **스프링 빈**이랑 한다.
- 스프링 빈은 `@Bean`이 붙은 메서드 이름을 스프링 빈 이름으로 사용한다.
- 이전에는 개발자가 필요한 객체를 `AppConfig`를 사용해서 직접 조회했지만 이제부터는 스프링 컨테이너를 통해서 필요한 스피링 빈(객체)를 찾아야 한다. 스프링 빈은 `applicationContext.getBean()`메서드를 사용해서 찾을 수 있다.
- 기존에는 개발자가 직접 자바코드로 모든 것을 했다면 이제부터는 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경되었다.