## 1) 빈 스코프란?
- 스프링 빈은 기본적으로 싱글톤이기 때문에 스프링 컨테이너 시작과 함께 생성되고 종료될 때 까지 유지된다.
- 스코프는 빈이 존재할 수 있는 범위를 뜻한다.

### (1) 스프링이 지원하는 스코프
- **싱글톤** : 기본 스코프로 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.
- **프로토타입** : 스프링 컨테이너가 프로토타입 빈의 생성과 의존관계 주입까지 관여하고 더이상 관리하지 않는 매우 짧은 범위의 스코프이다.
- **웹 관련 스코프**
	- **request** : 웹 요청이 들어오고 나갈 때 까지 유지되는 스코프이다.
	- **session** : 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프이다.
	- **application** : 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프이다.

### (2) 빈 스코프 지정하기
#### 컴포넌트 스캔 자동 등록
```java
@Scope("prototype")
@Component
public class HelloBean {}
```
#### 수동 등록
```java
@Scope("prototype")
@Bean
public class HelloBean {
	return new HelloBean();
}
```

## 2) 프로토타입 스코프
- 싱글톤 스코프의 빈을 조회하면 스프링 컨테이너는 항상 같은 인스턴스의 스프링 빈을 반환한다.
- 반면 프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴를 생성해서 반환한다.

### (1) 싱글톤 스코프
![싱글톤 빈 요청](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/9/싱글톤%20빈%20요청.svg)
1. 싱글톤 스코프의 빈을 스프링 컨테이너에 요청한다.
2. 스프링 컨테이너는 본인이 관리하는 스프링 빈을 반환한다.
3. 이후에 스프링 컨테이너에 같은 요청이 와도 같은 객체 인스턴스의 스프링 빈을 반환한다.

### (2) 프로토타입 빈 요청 1
![프로토타입 빈 요청 1](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/9/프로토타입%20빈%20요청%201.svg)
1. 프로토타입 스코프의 빈을 스프링 컨테이너에 요청한다.
2. 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성하고, 필요한 의존관계를 주입한다.

### (3) 프로토타입 빈 요청 2
![프로토타입 빈 요청 2](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/9/프로토타입%20빈%20요청%202.svg)
1. 스프링 컨테이너는 생성한 프로토타입 빈을 클라이언트에 반환한다.
2. 이후에 스프링 컨테이너에 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성해서 반환한다.

### (4) 정리
- 핵심은 **스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 것**이다.
- 프로토타입 빈을 관리할 책임은 프로토타입 빈을 받은 클라이언트에 있다.
- 그래서 `@PreDestroy` 같은 종료 메서드가 호출되지 않는다.
	- 종료 메서드 호출도 클라이언트가 직접 해야한다.

## 3)프로토타입 스코프 - 싱글톤 빈과 함께 사용 시 문제점
- 스프링 컨테이너에 프로토타입 스코프의 빈을 요청하면 항상 새로운 인스턴스를 생성해서 반환한다.
- 그러나 싱글톤 빈과 함께 사용하면 의도한 대로 동작하지 않을 수 있다.

### (1) 프로토타입 빈 직접 요청 1
 ![프로토타입 빈 직접 요청 1](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/9/프로토타입%20빈%20직접%20요청%201.svg)
1. 클라이언트A는 스프링 컨테이너에 프로토타입 빈을 요청한다.
2. 스프링 컨테이너는 프로토타입 빈을 새로 생성해서 반환(x01)한다. 해당 빈의 count 필드 값은 0이다.
3. 클라이언트는 조회한 프로토타입 빈에 `addCount()` 를 호출해서 count 필드를 +1 한다.
4. 결과는 프로토타입 빈(x01)의 count는 1이 된다.

### (2) 프로토타입 빈 직접 요청 2
![프로토타입 빈 직접 요청 2](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/9/프로토타입%20빈%20직접%20요청%202.svg)
1. 클라이언트B는 스프링 컨테이너에 프로토타입 빈을 요청한다.
2. 스프링 컨테이너는 프로토타입 빈을 새로 생성해서 반환(x02)한다. 해당 빈의 count 필드 값은 0이다.
3. 클라이언트는 조회한 프로토타입 빈에 `addCount()` 를 호출해서 count 필드를 +1 한다.
4. 결과는 프로토타입 빈(x02)의 count는 1이 된다.

### (3) 싱글톤에서 프로토타입 빈 사용 1
![싱글톤에서 프로토타입 빈 사용 1](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/9/싱글톤에서%20프로토타입%20빈%20사용%201.svg)
- `clientBean`은 싱글톤이라서, 스프링 컨테이너 생성 시점에 함께 생성되고, 의존관계 주입도 발생한다.
- `clientBean`은 의존관계 자동 주입을 사용하고, 주입 시점에 스프링 번테이너에 프로토타입 빈을 요청한다.
- 스프링 컨테이너는 프로토타입 빈을 생성해서 `clientBean`에 반환한다. 프로토타입 빈의 count 필드 값은 0이다.
- `clientBean`은 프로토타입 빈을 내부 필드에 보관한다.

### (3) 싱글톤에서 프로토타입 빈 사용 2
![싱글톤에서 프로토타입 빈 사용 2](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/9/싱글톤에서%20프로토타입%20빈%20사용%202.svg)
- 클라이언트A는 `clientBean`을 스프링 컨테이너에 요청해서 받는다. 싱글톤이므로 항상 같은 `clientBean`이 반환된다.
- 클라이언트A는 `clientBean.logic()`을 호출한다.
- `clientBean`은 prototypeBean의 `addCount()`를 호출해서 프로토타입 빈의 count 를 증가시킨다. count 값이 1이 된다.

### (4) 싱글톤에서 프로토타입 빈 사용 3
![싱글톤에서 프로토타입 빈 사용 3](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/9/싱글톤에서%20프로토타입%20빈%20사용%203.svg)
- 클라이언트B는 `clientBean`을 스프링 컨테이너에 요청해서 받는다. 싱글톤이므로 항상 같은 `clientBean`이 반환된다.
- <span style="background:#ff4d4f">여기서 `clientBean`이 내부에 가지고 있는 프로토타입 빈은 이미 과거에 주입이 끝난 빈이다. 주입 시점에 스프링 컨테이너에 요청해서 프로토타입 빈이 새로 생성이 된 것인지, 사용 할 때마다 새로 생성되는 것이 아니다.</span>
- 클라이언트B는 `clientBean.logic()`을 호출한다.
- `clientBean`은 prototypeBean의 `addCount()`를 호출해서 프로토타입 빈의 count를 증가시킨다. count 값이 1에서 2가 된다.

### (5) 정리
- 스프링은 일반적으로 싱글톤 빈을 사용한다.
- 싱글톤 빈이 프로토타입 빈을 사용하게 된다.
- 싱글톤 빈은 생성 시점에만 의존관계 주입을 받기에 프로토타입 빈이 새로 생성되어도, 싱글톤 빈과 함께 계속 유지된다.
- 사용할 때 마다 새로 생성해서 사용하는 것을 원하면 수정이 필요하다.

## 4) 프로토타입 스코프 - 싱글톤 빈과 함께 사용 시 Provider로 문제 해결
- 가장 간단한 방법은 싱글톤 빈이 프로토타입을 사용할 때 마다 스프링 컨테이너에 새로 요청하는 것이다.
- 의존관계를 외부에서 주입(DI) 받는게 아니라 직접 필요한 의존관계를 찾는 것을 <span style="background:#d3f8b6">Dependency Lookup(DL) 의존관계 조회(탐색)</span> 이라고 한다.
- 그러나 스프링의 애플리케이션 컨텍스트 전체 주입은 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트가 어렵다는 단점이 있다.
- 지정한 프로토타입 빈을 컨테이너에서 대신 찾아주는 DL 정도의 기능만 제공하는 것이 필요하다.

### (1) `ObjectFactory`, `ObjectProvider`
- 지정한 빈을 컨테이너에서 찾아주는 DL 서비스를 제공하는 것이 `ObjectProvider`이다.
	- `ObjectFactory`는 과거에 쓰였지만, 편의 기능이 추가된 것이 `ObjectProvider` 이다.
```java
@Autowired
 private ObjectProvider<PrototypeBean> prototypeBeanProvider;

 public int logic() {
     PrototypeBean prototypeBean = prototypeBeanProvider.getObject();
     prototypeBean.addCount();
     int count = prototypeBean.getCount();
     return count;
}
```
- `prototypeBeanProvider.getObject()`을 통해 항상 새로운 프로토타입 빈이 생성된다.
- `ObjectProvider`의 `getObject()`를 호출하면 <span style="background:#fff88f">내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환해준다. (DL)</span>

#### 특징
- `ObjectFactory` : 단순 기능, 별도 라이브러리 필요 없음, 스프링에 의존적이다.
- `ObjectProvider` : `ObjectFactory`을 상속하고 옵션, 스트림 처리 등 편의 기능이 많고, 별도의 라이브러리가 필요 없으나 스프링에 의존적이다.

### (2) JSR-330 Provider
- `javax.inject.Provider` 라는 JSR-330 자바 표준을 사용하는 방법이다.
	- 스프링 부트 3.0은 `jakarta.inject.Provider` 를 사용한다.
- 사용하려면 라이브러리를 gradle에 추가해야 한다.
#### 스프링 3.0 미만
- `javax.inject:javax.inject:1` 라이브러리를 gradle에 추가한다.
#### 스프링 3.0 이상
- `jakarta.inject:jakarta.inject-api:2.0.1` 라이브러리를 gradle에 추가한다.
#### 스프링부트 3.0 미만 예시 코드
```java
package javax.inject;
	public interface Provider<T> {
	T get();
}
```
```java
 @Autowired private Provider<PrototypeBean> provider;

 public int logic() {
     PrototypeBean prototypeBean = provider.get();
     prototypeBean.addCount();
     int count = prototypeBean.getCount();
     return count;
}
```
- `provider.get()`을 통해 새로운 프로토타입 빈이 생성된다.
- `provider`의 `get()` 을 호출하면 <span style="background:#fff88f">내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환해준다. (DL)</span>
- 자바 표준이며 기능이 단순해서 단위테스트를 만들거나 mock 코드 만들기가 쉽다.
- `Provider`는 딱 필요한 DL 정도의 기능만을 제공한다.
#### 특징
- `get()` 메서드 하나로 기능이 매우 단순하다.
- 별도 라이브러리가 필요하다.
- 자바 표준이여서 스프링이 아닌 다른 컨테이너에서도 사용 가능하다.

### (3) 정리
- 프로토타입 빈은 매번 사용할 때 마다 의존관계 주입이 완료된 새로운 객체가 필요할 때 사용하면 된다.
	- 하지만 실무에서 싱글톤 빈으로 대부분의 문제를 해결할 수 있다.
- `ObjectProvider`, `JSR330 Provider` 등은 프로토타입 뿐 아니라 DL이 필요한 다른 경우에도 사용할 수 있다.

## 5) 웹 스코프
### (1) 웹 스코프 특징
- 웹 스코프는 웹 환경에서만 동작한다.
- 웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리한다.
	- 종료 메서드가 호출된다.

### (2) 웹 스코프 종류
- request : HTTP 요청 하나가 들어오고 나갈  때 까지 유지되는 스코프이다. 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리된다.
- session : HTTP Session과 동일한 생명주기를 가지는 스코프이다.
- application : 서블릿 컨텍스트 (ServletContext)와 동일한 생명주기를 가지는 스코프이다.
- websocket : 웹 소켓과 동일한 생명주기를 가지는 스코프이다.

#### HTTP request 요청 당 각각 할당되는 request 스코프
![HTTP request 요청 당 각각 할당되는 request 스코프](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/9/HTTP%20request%20요청%20당%20각각%20할당되는%20request%20스코프.svg)

## 6) request 스코프 예제 만들기
- 동시에 여러 HTTP 요청이 오면 남겨진 로그를 구분하기 어려운데, 이 때 request 스코프를 사용하면 좋다.


## 7) 스코프와 Provider


## 8) 스코프와 프록시
```java
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class MyLogger {
}
```
- `proxyMode = ScopedProxyMode.TARGET_CLASS` 를 추가한다.
	- 적용 대상이 인터페이스가 아닌 클래스면 `TARGET_CLASS` 를 선택  
	- 적용 대상이 인터페이스면 `INTERFACES` 를 선택
- 이렇게 하면 MyLogger의 가짜 프록시 클래스를 만들어두고 HTTP request와 상관 없이 가짜 프록시 클래스를 다른 빈에 미리 주입해 둘 수 있다.

### 웹 스코프와 프록시 동작 원리
#### CGLIB라는 라이브러리로 내 클래스를 상속 받은 가짜 프록시 객체를 만들어서 주입한다.
- `@Scope` 의 `proxyMode = ScopedProxyMode.TARGET_CLASS)` 를 설정하면 스프링 컨테이너는 CGLIB라는 바이트코드를 조작하는 라이브러리를 사용해서, MyLogger를 상속받은 가짜 프록시 객체를 생성한다.
- 결과를 확인해보면 우리가 등록한 순수한 MyLogger 클래스가 아니라 `MyLogger$$EnhancerBySpringCGLIB` 이라는 클래스로 만들어진 객체가 대신 등록된 것을 확인할 수 있다.
- 그리고 스프링 컨테이너에 "myLogger"라는 이름으로 진짜 대신에 이 가짜 프록시 객체를 등록한다.
- `ac.getBean("myLogger", MyLogger.class)` 로 조회해도 프록시 객체가 조회되는 것을 확인할 수 있 다.  
- 그래서 의존관계 주입도 이 가짜 프록시 객체가 주입된다.

![가짜 프록시 객체](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/9/가짜%20프록시%20객체.png)
#### 가짜 프록시 객체는 요청이 오면 그때 내부에서 진짜 빈을 요청하는 위임 로직이 들어있다. 
- 가짜 프록시 객체는 내부에 진짜 `myLogger` 를 찾는 방법을 알고 있다.  
- 클라이언트가 `myLogger.log()` 을 호출하면 사실은 가짜 프록시 객체의 메서드를 호출한 것이다.  
- 가짜 프록시 객체는 request 스코프의 진짜 `myLogger.log()` 를 호출한다.  
- 가짜 프록시 객체는 원본 클래스를 상속 받아서 만들어졌기 때문에 이 객체를 사용하는 클라이언트 입장에서는 사 실 원본인지 아닌지도 모르게, 동일하게 사용할 수 있다(다형성)
#### 동작 정리
- CGLIB라는 라이브러리로 내 클래스를 상속 받은 가짜 프록시 객체를 만들어서 주입한다.  
- 이 가짜 프록시 객체는 실제 요청이 오면 그때 내부에서 실제 빈을 요청하는 위임 로직이 들어있다.  
- 가짜 프록시 객체는 실제 request scope와는 관계가 없다. 그냥 가짜이고, 내부에 단순한 위임 로직만 있고, 싱 글톤 처럼 동작한다.
#### 특징 정리
- 프록시 객체 덕분에 클라이언트는 마치 싱글톤 빈을 사용하듯이 편리하게 request scope를 사용할 수 있다. 사실 Provider를 사용하든, 프록시를 사용하든 핵심 아이디어는 진짜 객체 조회를 꼭 필요한 시점까지 지연처리 한다는 점이다.
- 단지 애노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다. 이것이 바로 다형성과 DI 컨테이너 가 가진 큰 강점이다.  
- 꼭 웹 스코프가 아니어도 프록시는 사용할 수 있다.
#### 주의점  
- 마치 싱글톤을 사용하는 것 같지만 다르게 동작하기 때문에 결국 주의해서 사용해야 한다.  
- 이런 특별한 scope는 꼭 필요한 곳에만 최소화해서 사용하자, 무분별하게 사용하면 유지보수하기 어려워진다.