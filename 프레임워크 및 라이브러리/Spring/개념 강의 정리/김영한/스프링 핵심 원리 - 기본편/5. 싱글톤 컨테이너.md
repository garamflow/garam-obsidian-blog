## 1) 웹 애플리케이션과 싱글톤
- 스프링은 기업용 온라인 서비스 기술을 지원하기 위해 탄생했다.
- 스프링 애플리케이션은 대부분은 여러 고객이 동시에 요청하는 웹 애플리케이션이다.
![스프링 - 고객의 동시 요청](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/5/스프링%20-%20고객의%20동시%20요청.svg)
- 스프링 없는 순수 DI 컨테이너인 `AppConfig`는 요청을 받을 때 마다 객체를 계속 새롭게 생성한다.
- 요청이 100개 -> 100개의 객체가 생성되고 소멸된다. -> 메모리 낭비가 심해진다.
- 해결방안으로는 해당 **객체가 1개만 생성되고, 공유하도록 설계**하면 된다. -> **싱글톤 패턴**

## 2) 싱글톤 패턴
- 클래스의 인스턴스가 1개만 생성되는 것을 보장하는 디자인 패턴이다.
- 객체 인스턴스가 2개 이상 생성하지 못하게 막아야한다.
	- **`private` 생성자를 사용해서 외부에서 임의로 `new`키워드를 사용하지 못하도록 막는다.**
```java
public class SingletonService {
	// 1. static 영역에 객체를 딱 1개만 생성한다.
    private static final SingletonService instance = new SingletonService();

	// 2. public으로 열어서 객체 인스턴스가 필요하면 이 static 메서드를 통해서 조회되도록 허용한다.
    public static SingletonService getInstance() {  
        return instance;  
    }  

	// 3. 생성자를 private으로 선언해서 외부에서 new 키워드를 사용한 객체 생성을 못하게 막는다.
    private SingletonService() {  
    }  
      
    public void logic() {  
        System.out.println("logic");  
    }  
}
```
1. static 영역에 객체 instance를 미리 하나 생성해서 올려둔다.
2. 이 객체 인스턴스가 필요하면 오직 `getInstance()` 메서드를 통해서만 조회할 수 있다. 이 메서드를 호출하면 항상 같은 인스턴스가 반환된다.
3. 딱 1개의 객체 인스턴스만 존재해야 하므로, 생성자를 `private`으로 막아서 외부에서 `new` 키워드로 객체 인스턴스가 생성되는 것을 막는다.

> [!note] 참고사항
> 싱글톤 패턴을 구현하는 방법은 여러가지 있으며, 위에서는 단순하고 안전한 방법을 선택한 것이다.
### 싱글톤 패턴 문제점
- 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
- 의존관계상 클라이언트가 구체 클래스에 의존한다. -> <span style="background:#9254de">DIP를 위반</span>한다.
- 클라이언트가 구체 클래스에 의존해서 <span style="background:#9254de">OCP 원칙을 위반</span>할 가능성이 높다.
- 테스트가 어렵다.
- 내부 속성을 변경 및 초기화가 쉽지 않다.
- `private` 생성자로 자식 클래스 생성이 어렵다.
- 유연성이 떨어지고 안티패턴으로 불리기도 한다.

## 3) 싱글톤 컨테이너
- 스프링 컨테이너는 싱글톤 패턴 문제점을 해결하면서 객체 인스턴스를 싱글톤(1개만 생성)으로 관리할 수 있다.
- 스프링 빈은 싱글톤으로 관리된다.
### (1) 싱글톤 컨테이너
- 스프링 컨테이너는 객체 인스턴스를 싱글톤으로 관리한다.
- 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다.
	- 싱글톤 레지스트리 : 싱글톤 객체를 생성 및 관리하는 기능
- 스프링 컨테이너의 기능을 통해 지저분한 코드가 들어가지 않고, DIP, OCP, 테스트, `private` 생성자로 부터 자유롭게 싱글톤 사용이 가능하다.
### (2) 싱글톤 컨테이너 적용 후
![싱글톤 컨테이너 적용 후](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/5/싱글톤%20컨테이너%20적용%20후.png)
- 이미 만들어진 객체를 공유해서 효율적으로 재사용 가능하다.

> [!note] 참고사항
> 스프링은 기본 빈 등록 방식이 싱글톤이지만, 요청할 때 마다 새로운 객체를 생성해서 반환하는 기능도 제공한다.

## 4) ❗싱글톤 방식의 주의점❗
- 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 객체 상태를 유지(stateful)하게 설계해서는 안된다.
- <span style="background:#ff4d4f">무상태(stateless)로 설계</span>해야 한다.
	- 특정 클라이언트에 의존적인 필드가 있으면 안된다.
	- 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
	- 되도록 읽기만 가능해야한다.
	- 필드 대신 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.
- 스프링 빈의 필드에 공유 값을 설정하면 장애가 발생할 수 있다.
### (1) 자주 발생하는 에러 - 상태를 유지할 경우 발생하는 문제
```java
public class StatefulService {
	private in price; // 상태를 유지하는 필드

	public void order() {
		System.out.println("name = " + name + " price = " + price);
		this.price = price; // 여기서 문제가 발생한다.
	}

	public int getPrice() {
		return price;
	}
}
```
- `StatefulService`의 `price` 필드는 공유되는 필드인데, 특정 클라이언트가 값을 변경한다고 생각해보자.
	- 클라이언트A가 10000원을 주문하고 금액을 조회하는 사이에 클라이언트B가 20000원을 주문한다.
	- `getPrice()` 메서드를 통해 클라이언트A의 주문 금액을 조회할 때, 기댓값은 10000원이지만 결과는 20000원이 출력된다.
### (2) 무상태로 설계 예시
```java
public class StatefulService {
	public void order() {
		System.out.println("name = " + name + " price = " + price);
		return price; // 지역변수로 바꿔버린다.
	}
}
```
- 공유되는 필드를 없애고 지역변수로 바꿔버린다.

## 5) @Configuration과 싱글톤, 바이트코드 조작의 마법
- 스프링 컨테이너는 싱글톤 레지스트리다. 그러므로 스프링 빈도 싱글톤이 되도록 보장해주어야 한다.
- 하지만 @Configuration의 자바 코드를 보면 여러번 호출되는 상황으로 보인다.
- 그래서 스프링은 클래스의 바이트코드를 조작하는 라이브러리를 사용한다.
	- `@Configuration`과 `AppConfig` 에 정답이 있다.
### (1) AppConfig의 클래스 정보
```java
@Test
void configurationDeep() {
	ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);

	// AppConfig도 스프링 빈으로 등록된다.
	AppConfig bean = ac.getBean(AppConfig.class);

	System.out.println("bean = " + bean.getClass());
	// 출력 : bean = class hello.core.AppConfig$$EnhancerBySpringCGLIB$$bd479d70
}
```
- `AnnotationConfigApplicationContext`에 파라미터로 넘긴 값은 스프링 빈으로 등록되므로, `AppConfig`도 스프링 빈이 된다.
- `AppConfig` 스프링 빈을 조회해서 클래스 정보를 출력해보면 클래스명이 복잡해진 것을 볼 수 있다.
- 이것은 내가 만든 클래스가 아니라 **스프링이 CGLIB 라는 바이트코드 조작 라이브러리**를 사용해서 `AppConfig` 클래스를 상속받은 임의의 다른 클래스를 만들고, 그 클래스를 스프링 빈으로 등록한 것이다.

![CGLIB](/media/Spring/개념%20강의%20정리/김영한/스프링%20핵심%20원리%20-%20기본편/5/CGLIB.svg)
- 임의의 다른 클래스가 바로 싱글톤이 보장되도록 해준다.
- @Bean이 붙은 메서드마다 스프링 빈이 이미 존재하면 존재하는 빈을 반환하고, 없으면 생성해서 스프링 빈으로 등록하고 반환하는 코드가 내장되어 있다. 그래서 싱글톤이 보장된다.

### `@Configuration`을 안붙이고 `@Bean`만 적용하면 어떻게 될까?
- 붙이지 않아도 스프링 빈으로 등록이 된다.
- 대신 `@Configuration`을 붙이지 않으면 CGLIB 기술을 사용하지 않기 때문에 싱글톤이 깨지게된다.
- 