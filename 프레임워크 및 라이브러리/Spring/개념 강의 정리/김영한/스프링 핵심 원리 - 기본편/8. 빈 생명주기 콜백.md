## 1) 빈 생명주기 콜백 시작
- 애플리케이션 시작 시점에 연결을 미리 하고 종료 시점에 연결을 종료하는 작업을 하려면 객체 초기화와 종료 작업이 필요하다.
- 스프링 빈은 **"객체 생성 ➡️ 의존관계 주입"** 이라는 라이프사이클을 가지고 있다.
- 객체 생성 이후 의존관계 주입이 끝나고 나서야 필요한 데이터를 사용할 수 있는 준비가 완료된다.
- 즉, 초기화 작업은 의존관계 주입 완료 이후 호출해야 한다.
- 하지만 개발자가 의존관계 주입 완료 시점을 알기 어려우므로, 스프링이 제공해주는 기능을 이용해야한다.
	- 스프링은 의존관계 주입 완료 시, 스프링 빈에게 콜백 메서드를 통해 초기화 시점을 알려주는 기능을 제공한다.
	- 스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 제공한다
### (1) 스프링 빈 이벤트 라이프사이클 (싱글톤)
1. 스프링 컨테이너 생성
2. 스프링 빈 생성
3. 의존관계 주입
4. 초기화 콜백
5. 사용
6. 소멸전 콜백
7. 스프링 종료

> [!NOTE] 참고 - 객체의 생성과 초기화를 분리하자.
> 생성자는 필수 정보(파라미터)를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가지고 있다. 반명 초기화는 생성된 값을 활용해서 외부 커넥션을 연결하는 동작을 수행한다.
> 생성자 안에서 무거운 초기화 작업을 하는 것 보다는 객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 유지보수 관점에서 좋다. (초기화 작업이 간단하다면 생성자에서 한 번에 다 처리하는 게 좋을수도 있다.)

> [!NOTE] 참고사항
> 싱글톤 빈들은 스프링 컨테이너가 종료될 때 싱글톤 빈들도 함께 종료된다. 그래서 스프링 컨테이너 종료되기 직전에 소멸전 콜백이 일어난다. 싱글톤처럼 컨테이너 시작과 종료까지 생존하는 빈들도 있고 생명주기가 짧은 빈들도 있는데, 이런 빈들은 컨테이너와 무관하게 소멸전 콜백이 일어난다.
### (2) 스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 지원한다.
1. 인터페이스 (InitializingBean, DisposableBean)
2. 설정 정보에 초기화 메서드, 종료 메서드 지정
3. `@PostConstruct`, `@PreDestroy` 애노테이션 지원

## 2) 인터페이스 `InitializingBean`, `DisposableBean`
- `InitializingBean`은 `afterPropertiesSet()` 메서드로 초기화를 지원한다.
- `DisposableBean`은 `destroy()` 메서드로 소멸을 지원한다.

### (1) 예시 코드
```java
package hello.core.lifecycle;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;

public class NetworkClient implements InitializingBean, DisposableBean {
	private String url;

	public NetworkClient() {
		System.out.println("생성자 호출, url = " + url);
	}

	public void setUrl(String url) {
		this.url = url;
	}

	// 서비스 시작 시 호출
	public void connect() {
		System.out.println("connect: " + url);
	}

	public void call(String message) {
		System.out.println("call: " + url + " message = " + message);
	}

	// 서비스 종료 시 호출
	public void disConnect() {
		System.out.println("close + " + url);
	}

	@Override
	public void afterPropertiseSet() throws Exception {
		conenct();
		call("초기화 연결 메시지");
	}

	@Override
	public void destroy() throws Exception {
		disConenct();
	}
}
```

### (2) 예시 코드 출력 결과
```text
생성자 호출, url = null
NetworkClient.afterPropertiesSet
connect: http://hello-spring.dev
call:http://hello-spring.dev message = 초기화 연결 메시지
13:24:29.043 [main] DEBUG
org.springframework.context.annotation.AnnotationConfigApplicationContext - 
Closing NetworkClient.destroy
close + http://hello-spring.dev
```
- 초기화 메서드가 주입 완료 후 호출 되었다.
- 스프링 컨테이너 종료가 호출되자 소멸 메서드가 호출 되었다.

### (3) 인터페이스를 이용한 초기화, 소멸 단점
- 해당 인터페이스는 스프링 전용 인터페이스라서 코드가 스프링 전용 인터페이스에 의존하게 된다.
- 초기화 및 소멸 메서드의 이름 변경이 불가능하다.
- 코드를 고칠 수 없는 외부 라이브러리에 적응이 불가능하다.

> [!NOTE] 참고사항
> 해당 초기화, 소멸 방법은 스프링 초창기에 나온 방법들로, 지금은 다른 더 나은 방법들을 사용하고 있다.

## 3) 빈 등록 초기화, 소멸 메서드 지정
- 설정 정보에 `@Bean(initMethod = "init", destroyMethod = "close")` 처럼 초기화, 소멸 메서드를 지정할 수 있다.

```java
package hello.core.lifecycle;

public class NetworkClient {
	private String url;

	public NetworkClient() {
		System.out.println("생성자 호출, url = " + url);
	}

	public void setUrl(String url) {
		this.url = url;
	}

	// 서비스 시작 시 호출
	public void connect() {
		System.out.println("connect: " + url);
	}

	public void call(String message) {
		System.out.println("call: " + url + " message = " + message);
	}

	// 서비스 종료 시 호출
	public void disConnect() {
		System.out.println("close + " + url);
	}

	public void init() {
		System.out.println("NetworkClient.init");
		conenct();
		call("초기화 연결 메시지");
	}

	public void close() {
		System.out.println("NetworkClient.close");
		disConenct();
	}
}
```

```java
@Configuration
static class LifeCycleConfig {
	@Bean(initMethod = "init", destroyMethod = "close")
	public NetworkClient networkClient() {
		NetworkClient networkClient = new NetworkClient();
		networkClient.setUrl("http://hello-spring.dev");
		return networkClient;
	}
}
```

### (1) 설정 정보 사용 특징
- 메서드 이름을 자유롭게 줄 수 있다.
- 스프링 빈이 스프링 코드에 의존적이지 않다.
- 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용할 수 있다.

### (2) 종료 메서드의 추론
- `@Bean`의 `destroyMethod` 속성에는 특별한 기능이 있다.
- 라이브러리 대부분이 `close`, `shutdown` 이라는 이름으로 종료 메서드를 사용한다.
- 그래서 `@Bean` 의 `destroyMethod`는 기본값이 `(inferred)`(추론)으로 등록되어 있다.
- 해당 기능은 `close`, `shutdown` 라는 이름의 메서드를 자동으로 호출해준다. 즉, 종료 메서드를 추론해서 호출해준다.
- 그러므로 직접 스프링 빈으로 등록하면 종료 메서드는 따로 적어주지 않아도 작동한다.
- 추론 기능을 사용하기 싫다면 `destroyMethod=""` 처럼 빈 공백을 지정하면 된다.

## 4) 애노테이션 `@PostConstruct`, `@PreDestroy`
```java
package hello.core.lifecycle;

import java's.annotation.PostConstruct;
import java's.annotation.PreDestroy;

public class NetworkClient {
	private String url;

	public NetworkClient() {
		System.out.println("생성자 호출, url = " + url);
	}

	public void setUrl(String url) {
		this.url = url;
	}

	// 서비스 시작 시 호출
	public void connect() {
		System.out.println("connect: " + url);
	}

	public void call(String message) {
		System.out.println("call: " + url + " message = " + message);
	}

	// 서비스 종료 시 호출
	public void disConnect() {
		System.out.println("close + " + url);
	}

	@PostConstruct
	public void init() {
		System.out.println("NetworkClient.init");
		conenct();
		call("초기화 연결 메시지");
	}

	@PreDestroy
	public void close() {
		System.out.println("NetworkClient.close");
		disConenct();
	}
}
```

```java
@Configuration
static class LifeCycleConfig {
	@Bean
	public NetworkClient networkClient() {
		NetworkClient networkClient = new NetworkClient();
		networkClient.setUrl("http://hello-spring.dev");
		return networkClient;
	}
}
```

### 애노테이션 `@PostConstruct`, `@PreDestroy`특징
- 최신 스프링에서 가장 권장하는 방법이다.
- 애노테이션 하나만 붙이면 되므로 편하다.
- 패키지가 `java's.annotation.PostConstruct` 이다. 스프링에 종속적이지 않고 자바 표준이므로 다른 컨테이너에서도 동작한다.
- 컴포넌트 스캔과 잘 어울린다.
- 외부 라이브러리에는 적용할 수 없다.
	- 외부 라이브러리 초기화, 소멸의 경우 `@Bean` 기능을 사용해야 한다.

## 5) 정리
- 애노테이션 `@PostConstruct`, `@PreDestroy`을 사용하자.
- 코드를 고칠 수 없는 외부 라이브러리 초기화, 소멸의 경우 `@Bean`의 `initMethod`, `destroyMethod`를 사용하자.