## 1) 다양한 의존관계 주입 방법
- 크게 4가지 의존관계 주입 방법이 있다. 
1. 생성자 주입
2. 수정자 주입 (setter 주입)
3. 필드 주입
4. 일반 메서드 주입

### (1) 생성자 주입
- 생성자를 통해서 의존 관계를 주입받는 방법이다.
- 특징
	- 생성자 호출 시점에 <span style="background:#ff4d4f">딱 한 번만 호출되는 것이 보장</span>된다.
	- <span style="background:#ff4d4f">"불변, 필수" 의존 관계에 사용</span>한다.
	- 생성자가 딱 한 개이면 `@Autowired`를 생략해도 자동 주입된다. (스프링 빈에서만)

### (2) 수정자 주입 (setter 주입)
- `setter`라 불리는 필드 값을 변경하는 수정자 메서드를 통해서 의존 관계를 주입받는다.
- 특징
	- "선택, 변경" 가능성이 있는 의존 관계에 사용한다.
	- 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용한다.

#### 자바빈 프로퍼티 규약
- 자바는 필드 값을 직접 변경하지 않고, setXxx, getXxx 라는 메서드를 통해서 값을 읽거나 수정하는 규칙이 있다. 해당 사항이 자바빈 프로퍼티 규약이다.
```java
class Data {
	private int age;
	public void setAge(int age) {
		this.age = age;
	}

	public int getAge() {
		return age;
	}
}
```

### (3) 필드 주입
- 필드에다가 주입받는 방식이다.
- 특징
	- 코드가 간결하지만 외부에서 변경이 불가능해서 테스트가 어렵다.
	- DI 프레임워크가 없으면 아무것도 못한다.
	- 사용하지 말자.
		- `@Configuration` 같은 곳에서 특별한 용도로 사용한다.
		- 애플리케이션과 관계없는 테스트 코드에서는 사용한다.

### (4) 일반 메서드 주입
- 일반 메서드를 통해서 주입받는 방식이다.
- 특징
	- 한 번에 여러 필드를 주입받을 수 있다.
	- 거의 사용하지 않는다.

> [!NOTE] 주의사항
> 의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈이어야 동작한다. 스프링 빈이 아니면 `@Autowired` 코드를 적용해도 아무것도 동작하지 않는다.

## 2) 옵션 처리
- 스프링 빈이 없어도 동작해야 할 때, 옵션을 통해서 처리하게 된다.
	- `Autowired(required = false)` : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출되지 않는다.
	- `org.springframework.lang.@Nullable` : 자동 주입할 대상이 없으면 null이 입력된다.
	- `Optional<>` : 자동 주입할 대상이 없으면 `Optional.empty`가 입력된다.
```java
@Autowired(required = false)
public void setNoBean1(Member member) {
	System.out.prinln("setNoBean1 = " + member); // 호출 안됨
}

@Autowired
public void setNoBean2(@Nullable Member member) {
	System.out.prinln("setNoBean2 = " + member); // setNoBean2 = null
}

@Autowired(required = false)
public void setNoBean3(Optional<Member> member) {
	System.out.prinln("setNoBean3 = " + member); // setNoBean3 = Optional.empty
}
```

## 3) 생성자 주입을 선택해라!
- 최근에는 스프링을 포함한 DI 프레임워크 대부분이 생성자 주입을 권장한다.
- 이유는 아래와 같다.
### (1) 불변
- 대부분 의존관계 주입을 한 번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다. (오히려 대부분은 변하면 안된다.)
- 누군가 실수로 변경하거나 변경하면 안되는 메서드를 열어두는 것은 좋은 방식이 아니다.
- <span style="background:#d4b106">생성자 주입은 객체 생성 시 딱 한 번만 호출되므로 불변하게 설계가 가능</span>하다.

### (2) 누락
- 프레임워크 없이 순수한 자바 코드로 단위 테스트 시, 생성자 주입이 아닌 경우는 누락되는 경우가 생긴다.
- <span style="background:#d4b106">생성자 주입의 경우 "컴파일 오류"가 발생해서 어떤 값을 필수로 주입해야 하는 지 알 수 있다</span>.

### (3) `final` 키워드
- 생성자 주입을 사용하면 필드에 `final` 키워드를 사용 가능하다.
- 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막을 수 있다.

> [!NOTE] 참고사항
> 수정자 주입을 포함한 다른 주입 방식은 모두 생성자 이후 호출되므로, `final` 키워드를 사용할 수 없다.

### (4) 정리
- 생성자 주입 방식은 프레임워크를 의존하지 않고 자바 언어 특징을 잘 살리는 방식이다.
- 기본으로 생성자 주입 방식을 사용하고, 필수 값이 아니라면 수정자 주입 방식을 옵션으로 사용하면 된다.

## 4) 롬복과 최신 트랜드
- 개발 시 대부분이 불변이고 생성자에 final을 사용하게 된다.
- `getter`, `setter` 등을 하나하나 적기는 리소스가 많이 든다.
- 그래서 최근에는 **Lombok** 이라는 라이브러리를 많이 사용한다.
	- Lombok은 자바의 애노테이션 프로세서라는 기능을 이용해서 컴파일 시점에 생성자 코드 등을 자동으로 생성해준다.
	- `@RequiredArgsConstructor` : `final` 이 붙은 필드를 모아서 생성자를 자동으로 만들어준다.

### 정리
- 생성자를 딱 한 개만 두고 `@Autowired`를 생략하고, Lombok 라이브러리의 `@RequiredArgsConstructor` 와 함께 사용하면 기능이 다 제공되고 코드도 깔끔해진다.

### Lombok 라이브러리 적용 방법
```
// bundle.gradle
plugins {
     id 'org.springframework.boot' version '2.3.2.RELEASE'
     id 'io.spring.dependency-management' version '1.0.9.RELEASE'
     id 'java'
}

group = 'hello'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '11'

//lombok 설정 추가 시작
configurations {
    compileOnly {
         extendsFrom annotationProcessor
	}
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'

//lombok 라이브러리 추가 시작  
compileOnly 'org.projectlombok:lombok' annotationProcessor 'org.projectlombok:lombok'

testCompileOnly 'org.projectlombok:lombok' testAnnotationProcessor 'org.projectlombok:lombok'

//lombok 라이브러리 추가 끝

    testImplementation('org.springframework.boot:spring-boot-starter-test') {
        exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
	}
}

test {
    useJUnitPlatform()
}
```
1. Preferences - File - plugin - lombok 검색 설치 실행 (재시작)
2. Preferences - Annotation Processors 검색 - Enable annotation processing 체크 (재시작)

## 5) 조회 빈이 2개 이상 - 문제
- `@Autowired`는 타입(Type)으로 조회한다.
- 스프링 빈 조회와 마찬가지로 타입으로 조회 시, 선택한 빈이 2개 이상인 문제가 발생할 수 있다.
	- `NoUniqueBeanDefinitionException` 오류가 발생한다.
- 하위 타입을 지정해도 되지만, DIP를 위배하고 유연성이 떨어진다.
- 해당 문제를 해결하는 다른 여러 방법이 있다.

## 6) `@Autowired` 필드 명, `@Quilifier`, `@Primary`
- 조회 대상 빈이 2개 이상일 때 해결 방법은 아래와 같다.
	- `@Autowired` 필드 명 매칭
	- `@Quilifier` -> `@Qualifier` 끼리 매칭 -> 빈 이름 매칭
	- `@Primary` 사용

### (1) `Autowired` 필드 명 매칭
- `Autowired`는 타입 매칭을 시도하고, 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭시킨다.
- <span style="background:#d4b106">필드 명 매칭은 타입 매칭 시도 후, 여러 빈이 있을 때 추가로 동작하는 기능</span>이다.

### (2) `@Quilifier` 사용
- `@Quilifier`는 추가 구분자를 붙여주는 방식이다.
- 빈 이름 변경이 아니라 주입시에 추가적인 옵션을 제공하는 것이다.
```java
@Component
@Quilifier("mainDiscountPolicy")
public class RateDiscountPolicy implements DiscountPolicy {}
```
```java
@Component
@Quilifier("fixDiscountPolicy")
public class FixDiscountPolicy implements DiscountPolicy {}
```
```java
@Autowired
public OrderServiceImpl(MemberRepository memberRepository, 
						@Quilifier("mainDiscountPolicy") DiscountPolicy discountPolicy) {
...
}
```
1. `@Quilifier` 끼리 매칭이 된다. 없다면?
2. 빈 이름끼리 매칭된다. 없다면?
3. `NoUniqueBeanDefinitionException` 예외 발생한다.

### (3) `@Primary` 사용
- 우선 순위를 정하는 방법이다.
- `@Autowired` 시 여러 빈이 매칭되면 `@Primary`가 우선권을 가진다.

### (4) `@Quilifier`, `@Primary` 활용
- 코드에서 자주 사용하는 메인 데이터베이스 커넥션은 `@Primary`를 적용하고, 서브 데이터베이스 커넥션 빈을 획득 할 때는 `@Quilifier`를 지정해서 명시적으로 획득 하는 방식을 사용한다.
- 둘 중에 `@Quilifier`가 우선권이 높다.
	- 스프링은 자동보다는 수동, 넓은 선택 범위 보다는 좁은 범위의 선택권이 우선 순위가 높다.

## 7) 애노테이션 직접 만들기
- `@Quilifier("mainDiscountPolicy")` 라는 식으로 적으면 타입 체크가 안된다.
- 애노테이션을 통해 문제를 해결할 수 있다.
```java
package hello.core.annotation;

import java.lang.annotation.*;

@Taget({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
@Quilifier("mainDiscountPolicy")
public @interface MainDiscountPolicy {
}
```

```java
@Component
@MainDiscountPolicy
public class RateDiscountPolicy implements DiscountPolicy {
}
```

```java
@Autowired
public OrderServiceImpl(MemberRepository memberRepository, 
						@MainDiscountPolicy DiscountPolicy discountPolicy) {
...
}
```

## 8) 조회한 빈이 모두 필요할 때, List, Map
- 해당 타입의 스프링 빈 전부가 필요한 경우에 List, Map을 사용하면 된다.
	- `Map<String, DiscountPolicy>` : map의 키에 스프링 빈 이름을 넣고, 해당 값으로 `DiscountPolicy` 타입으로 조회한 모든 스프링 빈을 담는다.
	- `List<DiscountPolicy>` : `DiscountPolicy` 타입으로 조회한 모든 스프링 빈을 담는다.

## 9) 자동, 수동의 올바른 실무 운영 기준
### (1) 편리한 자동 기능을 기본으로 사용한다.
- 스프링은 `@Component` 뿐만 아니라 계층에 맞게 `@Repository`, `@Service`, `@Controller` 처럼 자동으로 스캔할 수 있게 도와주고 있다.
- 게다가 스프링 부트는 컴포넌트 스캔을 기본으로 사용하고 있다.
- 결정적으로 자동 빈 등록을 사용해도 OCP, DIP를 모두 지킬 수 있으므로 자동 등록을 기본으로 사용한다.

### (2) 언제 수동 빈 등록을 사용할까?
- 애플리케이션을 나누면 업무 로직과 기술 지원 로직으로 나눌 수 있다.
	- **업무 로직 빈** : 비즈니스 요구사항을 개발할 때 추가 및 변경된다.
		- 웹을 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 리포지토리 등
	- **기술 지원 빈** : 업무 로직을 지원하기 위한 하부 기술 및 공통 기술들이다.
		- 기술적 문제 및 공통 관심사(AOP)를 처리할 때 주로 사용
		- 데이터베이스 연결 및 공통 로그 처리 등
- **업무 로직**은 숫자도 많고 어느정도 유사한 패턴이 있다. 이런 경우 자동 기능을 적극 사용한다. 문제가 생겨도 어디서 생겼는 지 명확하게 파악하기 쉽다.
- **기술 지원 로직**은 상대적으로 수가 적고 애플리케이션 전반에 걸쳐 영향을 끼친다. 적용이 잘 되고 있는지 문제가 발생했을 때 파악하기가 힘들다. 그래서 이런 기술 지원 로직들은 가급적 수동 빈 등록을 사용해서 명확하게 드러내는 게 좋다.

### (3) 비즈니스 로직에서 다형성을 적극 활용할 때
- 해당 상황의 경우 한 눈에 파악하기 쉽지 않으므로 수동 빈 등록을 이용하거나 자동으로 이용하려면 특정 패키지에 같이 묶어두는 게 좋다.
```java
// 자동 등록 이용 시, 한 눈에 보기 쉽게 패키지로 묶어두기
@Configuration
public class DiscountPolicyConfig {
	@Bean
	public DiscountPolicy rateDiscountPolicy {
		return new RateDiscountPolicy();
	}

	@Bean
	public DiscountPolicy fixDiscountPolicy {
		return new FixDiscountPolicy();
	}
}
```
