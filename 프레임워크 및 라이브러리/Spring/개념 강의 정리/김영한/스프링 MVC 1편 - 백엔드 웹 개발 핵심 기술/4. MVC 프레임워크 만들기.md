> [!note] 참고사항
> - 해당 페이지는 기존에 있던 코드(서블릿+JSP+MVC)를 순차적으로 수정하는 것에 대한 기록이다.
> - 보통 개발을 하다보면 개선을 해야되는 일들이 자주 생기는데, 레벨이 다른 부분을 같이 개선하면 안된다.
> - 같은 레벨끼리 개선을 하고 문제가 없으면 그 때, 다른 레벨의 개선사항을 개선해야한다.
> - 예시) 구조 개선 -> 문제가 없음을 확인 -> 디테일 개선

## 1) 프론트 컨트롤러 패턴 소개
### (1) 프론트 컨트롤러 도입 전
![프론트 컨트롤러 도입 전](/media/Spring/개념%20강의%20정리/김영한/스프링%20MVC%201편%20-%20백엔드%20웹%20개발%20핵심%20기술/4/프론트%20컨트롤러%20도입%20전.svg)

### (2) 프론트 컨트롤러 도입 후
![프론트 컨트롤러 도입 후](/media/Spring/개념%20강의%20정리/김영한/스프링%20MVC%201편%20-%20백엔드%20웹%20개발%20핵심%20기술/4/프론트%20컨트롤러%20도입%20후.svg)

### (3) FrontController 패턴 특징
- 프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받는다.
- 프론트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호출한다.
- 입구를 하나로 만든다.
- 공통 처리 가능하다.
- 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 된다.

### (4) 스프링 웹 MVC와 프론트 컨트롤러
- 스프링 웹 MVC의 핵심도 바로 **FrontController**이다.
- 스프링 웹 MVC의 **DispatcherServlet**이 FrontController 패턴으로 구현되어 있다.

## 2) 프론트 컨트롤러 도입 - v1
- 클라이언트가 요청을 하면 매핑 정보를 뒤져서 어떤 컨트롤러를 호출해야될지 찾은 다음에 호출한다.
- 컨트롤러는 자기자신의 로직을 수행하고 JSP forward 로직으로 JSP를 호출해서 MVC가 되서 응답이 나가게된다. 클라이언트는 HTTP 응답을 받게 된다.
![프론트 컨트롤러 도입 - v1 구조](/media/Spring/개념%20강의%20정리/김영한/스프링%20MVC%201편%20-%20백엔드%20웹%20개발%20핵심%20기술/4/프론트%20컨트롤러%20도입%20-%20V1%20구조.svg)
### (1) 코드 살펴보기 - ControllerV1 (컨트롤러 인터페이스)
- 서블릿과 비슷한 모양의 컨트롤러 인터페이스를 도입한다.
- 각 컨트롤러들은 이 인터페이스를 구현하면 된다.
- 프론트 컨트롤러는 해당 인터페이스를 호출해서 구현과 관계없이 로직의 일관성을 가질 수 있다.

### (2) 코드 살펴보기 - MemberFormControllerV1, MemberSaveControllerV1, MemberListControllerV1 (회원 등록, 저장, 목록 컨트롤러)
- 내부 로직은 기존 서블릿 코드와 거의 같다.

### (3) 코드 살펴보기 - FrontControllerServletV1 (프론트 컨트롤러)
#### `urlPatterns`
- `urlPatterns = "/front-controller/v1/*` : `urlPattens = "/front-controller/v1`를 포함한 하위 모든 요청을 이 서블릿에서 받아들인다.
	- `/front-controller/v1`, `.front-controller/v1/a`
#### `controllerMap`
- key: 매핑 URL
- value : 호출될 컨트롤러
#### `service()`
- `requestURI`를 조회해서 실제 호출할 컨트롤러를 `controllerMap`에서 찾는다.
	- 없다면 `404(SC_NOT_FOUND)` 상태 코드를 반환한다.
- 컨트롤러를 찾고 `controller.process(request, response);`를 호출해서 해당 컨트롤러를 실행한다.
#### JSP
- JSP는 이전 MVC에서 사용했던 것을 그대로 사용한다.

## 3) View 분리 - v2
- 모든 컨트롤러에서 뷰로 이동하는 부분에 중복이 있다.
- 해당 부분을 깔끔하게 분리하기 위해 별도로 뷰를 처리하는 객체를 만든다.
![View 분리 - v2 구조](/media/Spring/개념%20강의%20정리/김영한/스프링%20MVC%201편%20-%20백엔드%20웹%20개발%20핵심%20기술/4/View%20분리%20-%20v2%20구조.svg)
- 컨트롤러가 JSP forward 를 신경쓰지 않고 MyView만 반환해주면 된다.

### MyView (뷰 객체)
- 뷰 객체는 이후 버전에서도 사용하므로 패키지 위치는 `frontController`에 둔다.
- 프론트 컨트롤러 도입으로 `MyView` 객체의 `render()`를 호출하는 부분을 모두 일관되게 처리가능하다.
- 각각의 컨트롤러는 `MyView` 객체를 생성만 해서 반환하게 된다.

## 4) Model 추가 - v3
![Model 추가 - v3 구조](/media/Spring/개념%20강의%20정리/김영한/스프링%20MVC%201편%20-%20백엔드%20웹%20개발%20핵심%20기술/4/Model%20추가%20-%20v3%20구조.svg)

### (1) v3 목표 - 서블릿 종속성 제거하기
- 컨트롤러 입장에서 `HttpServletRequest`, `HttpServletResponse`가 꼭 필요하지 않다.
- 요청 파라미터 정보는 자바의 Map으로 대신 넘기도록 하면 지금 구조에서 컨트롤러가 서블릿 기술을 몰라도 동작이 가능하다. 또한 `request` 객체를 Model 로 사용하는 대신 별도의 Model 객체를 만들어서 반환하면 된다.
- 컨트롤러가 서블릿 기술을 전혀 사용하지 않게 변경할 수 있다. 그러면 구현 코드가 단순해지고 테스트 코드 작성이 쉬워진다.

### (2) v3 목표 - 뷰 이름 중복 제거
- 컨트롤러에서 지정하는 뷰 이름에 중복이 있는 것을 확인 가능하다.
- 컨트롤러는 **뷰의 논리 이름**을 반환하고, 실제 물리 위치의 이름은 프론트 컨트롤러에서 처리하도록 단순화하면 된다.
- 이러면 향후 뷰의 폴더 위치가 함께 이동해서 프론트 컨트롤러만 고쳐도 된다.
	- `/WEB-INF/views/new-form.jsp` ▶️ `new-form`
	- `/WEB-INF/views/save-result.jsp` ▶️ `save-result`
	- `/WEB-INF/views/members.jsp` ▶️ `members`

### (3) 코드 살펴보기 - ModelView
- 컨트롤러에서 서블릿에 종속적인 `HttpServletRequest`를 사용했고, Model도 `request.setAttribute()`를 통해 데이터를 저장하고 뷰에 전달했다.
- 서블릿의 종속성을 제거하기 위해 Model을 직접 만들고, View 이름까지 전달하는 객체를 만들어준다.

### (4) 코드 살펴보기 - 뷰 리졸버
- `MyView view = viewResolver(viewName)`
	- 컨트롤러가 반환하는 논리 뷰 이름을 실제 물리 뷰 경로로 변경한다.
	- 실제 물리 경로가 있는 `MyView` 객체를 반환한다.
- `view.render(mv.getModel(), request, response)`
	- 뷰 객체를 통해 HTML 화면을 렌더링한다.
	- 뷰 객체의 `render()` 는 모델 정보도 함께 받는다.
	- JSP는 `reuqest.getAttribute()`로 데이터를 조회하기 때문에, 모델 데이터를 꺼내서 `request.setAttribute()`로 담아둔다.
	- JSP로 포워드해서 JSP를 렌더링한다.
- 


## 5) 단순하고 실용적인 컨트롤러 - v4
- 서블릿 종속성을 제거하고 뷰 경로의 중복을 제거했지만, 항상 `ModelView` 객체를 생성하고 반환하는 부분이 번거롭다.
- 좋은 프레임워크는 아키텍처도 중요하지만 실제 개발하는 개발자가 단순하고 편리하게 사용할 수 있어야 한다.
- 기존 구조에서 모델을 파라미터로 넘기고, 뷰의 논리 이름을 반환하는 아이디어를 적용하면 된다.
![단순하고 실용적인 컨트롤러 - v4 구조](/media/Spring/개념%20강의%20정리/김영한/스프링%20MVC%201편%20-%20백엔드%20웹%20개발%20핵심%20기술/4/단순하고%20실용적인%20컨트롤러%20-%20v4%20구조.svg)

## 6) 유연한 컨트롤러 - v5
- 만약 개발자에 따라 다른 방식의 컨트롤러 인터페이스를 사용하고 싶다면 **어댑터 패턴**을 적용하면 된다.
- 어댑터 패턴을 사용해서 프론트 컨트롤러가 다양한 방식의 컨트롤러를 처리할 수 있도록 변경한다.
![유연한 컨트롤러 (어댑터 패턴) - v5 구조](/media/Spring/개념%20강의%20정리/김영한/스프링%20MVC%201편%20-%20백엔드%20웹%20개발%20핵심%20기술/4/유연한%20컨트롤러%20(어댑터%20패턴)%20-%20v5%20구조.svg)
- **핸들러 어댑터** : 중간에 어댑터 역할을 하는 어댑터가 추가되어 다양한 종류의 컨트롤러를 호출할 수 있다.
- **핸들러** : 컨트롤러의 이름을 더 넓은 범위인 핸들러로 변경한다. 이제 어댑터가 있으므로 컨트롤러의 개념 뿐 아니라 어떠한 것이든 해당하는 종류의 어댑터만 있으면 처리할 수 있기 때문이다.

### 코드 살펴보기 - MyHandlerAdapter (어댑터 인터페이스)
- `boolean supperts(Object handler)`
	- `handler`는 컨트롤러를 말한다.
	- 어댑터가 해당 컨트롤러를 처리할 수 있는지 판단하는 메서드이다.
- `ModelView handle(HttpServletRequest request, HttpServletResponse response, Object handler)`
	- 어댑터는 실제 컨트롤러를 호출하고, 결과로 `ModelView`를 반환해야 한다.
	- 실제 컨트롤러가 `ModelView`를 반환하지 못하면, 어댑터가 `ModelView`를 직접 생성해서라도 반환한다.
	- 프론트 컨트롤러가 실제 컨트롤러를 호출하는게 아니라 어댑터를 통해 실제 컨트롤러가 호출된다.
