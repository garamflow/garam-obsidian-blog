## 1) 프로젝트 생성 시 주의사항
- Packaging는 War가 아니라 **Jar를 선택**한다. JSP를 사용하지 않기 때문에 Jar를 사용하는 것이 좋다.
- Jar를 사용하면 항상 내장 서버(톰캣등)를 사용하고, `webapp` 경로도 사용하지 않는다.
	- 내장 서버 사용에 최적화 되어 있는 기능이다.
- War를 사용하면 내장 서버도 사용가능 하지만, 주로 외부 서버에 배포하는 목적으로 사용합니다.
- 스프링 부트에 `Jar` 를 사용하면 `/resources/static/` 위치에 `index.html` 파일을 두면 Welcome 페이지로 처리해준다. (스프링 부트가 지원하는 정적 컨텐츠 위치에 `/index.html` 이 있으면 된다.

## 2) 로깅 간단히 알아보기
- 운영 시스템에서는 `System.out.println()` 같은 시스템 콘솔을 사용해서 필요한 정보를 출력하지 않고, 별도의 로 깅 라이브러리를 사용해서 로그를 출력한다.

### (1) 로깅 라이브러리
- SLF4J - http://www.slf4j.org
- Logback - http://logback.qos.ch
- 로그 라이브러리는 Logback, Log4J, Log4J2 등등 수 많은 라이브러리가 있는데, 그것을 통합해서 인터페이스로 제공하는 것이 바로 SLF4J 라이브러리다.
- 쉽게 이야기해서 SLF4J는 인터페이스이고, 그 구현체로 Logback 같은 로그 라이브러리를 선택하면 된다. 실무에서는 스프링 부트가 기본으로 제공하는 Logback을 대부분 사용한다.

### (2) 테스트하기
- 로그가 출력되는 포멧 확인
	- 시간, 로그 레벨, 프로세스 ID, 쓰레드 명, 클래스명, 로그 메시지 로그 레벨 설정을 변경해서 출력 결과를 보자.
- LEVEL: `TRACE > DEBUG > INFO > WARN > ERROR`
	- 개발 서버는 debug 출력
	- 운영 서버는 info 출력
- `@Slf4j` 로 변경

#### 로그 레벨 설정하기
```
// main/resources/application.properties

#전체 로그 레벨 설정(기본 info)
logging.level.root=info

#hello.springmvc 패키지와 그 하위 로그 레벨 설정
logging.level.hello.springmvc=debug
```

```java
package hello.springmvc.basic;  
  
import org.slf4j.Logger;  
import org.slf4j.LoggerFactory;  
import org.springframework.web.bind.annotation.RequestMapping;  
import org.springframework.web.bind.annotation.RestController;  
  
@RestController  
public class LogTestController {  
    private final Logger log = LoggerFactory.getLogger(getClass());  
  
    @RequestMapping("/log-test")  
    public String logTest() {  
        String name = "Spring";  
  
        System.out.println("name = " + name);  
        log.trace("trace log={}", name);  
        log.debug("debug log={}", name);  
        log.info(" info log={}", name);  
        log.warn(" warn log={}", name);  
        log.error("error log={}", name);  
  
        return "ok";  
    }  
}
```
- `@RestController`
	- `@Controller` 는 반환 값이 `String` 이면 뷰 이름으로 인식된다. 그래서 **뷰를 찾고 뷰가 랜더링** 된다.
	- `@RestController` 는 반환 값으로 뷰를 찾는 것이 아니라, **HTTP 메시지 바디에 바로 입력**한다. 따라서 실행 결과로 ok 메세지를 받을 수 있다. `@ResponseBody` 와 관련있다.


### (3) 올바른 로그 사용법
- `log.debug("data="+data)`
	- 로그 출력 레벨을 info로 설정해도 해당 코드에 있는 "data="+data가 실제 실행이 되어 버린다.
	- 결과적으로 문자 더하기 연산이 발생한다.
-  `log.debug("data={}", data)`
	- 로그 출력 레벨을 info로 설정하면 아무일도 발생하지 않는다.
	- 따라서 앞과 같은 의미없는 연산이 발생하지 않는다.

### (4) 로그 사용시 장점
- 쓰레드 정보, 클래스 이름 같은 부가 정보를 함께 볼 수 있고, 출력 모양을 조정할 수 있다.
- 로그 레벨에 따라 개발 서버에서는 모든 로그를 출력하고, 운영서버에서는 출력하지 않는 등 로그를 상황에 맞게 조절할 수 있다.
- 시스템 아웃 콘솔에만 출력하는 것이 아니라, 파일이나 네트워크 등, 로그를 별도의 위치에 남길 수 있다. 특히 파 일로 남길 때는 일별, 특정 용량에 따라 로그를 분할하는 것도 가능하다.
- 성능도 일반 System.out보다 좋다. (내부 버퍼링, 멀티 쓰레드 등등) 그래서 실무에서는 꼭 로그를 사용해야 한다.

## 3) 요청 매핑
- 요청 매핑이란 요청이 왔을 때, 어떤 컨트롤러가 호출되는지에 대해 매핑하는 것이다.

```java
package hello.springmvc.basic.requestmapping;  
  
import org.slf4j.Logger;  
import org.slf4j.LoggerFactory;  
import org.springframework.web.bind.annotation.RequestMapping;  
import org.springframework.web.bind.annotation.RestController;  
  
@RestController  
public class MappingController {  
    private Logger log = LoggerFactory.getLogger(getClass());  
  
    @RequestMapping("/hello-basic")  
    public String helloBasic() {  
        log.info("helloBasic");  
        return "ok";  
    }  
}
```

### (1) `@RestController`
- `@Controller` 는 반환 값이 `String` 이면 뷰 이름으로 인식된다. 그래서 **뷰를 찾고 뷰가 랜더링** 된다.
- `@RestController` 는 반환 값으로 뷰를 찾는 것이 아니라, **HTTP 메시지 바디에 바로 입력**한다. 따라서 실행 결과로 ok 메세지를 받을 수 있다. `@ResponseBody` 와 관련이 있다.

### (2) `@RequestMapping("/hello-basic")`
- `/hello-basic` URL 호출이 오면 이 메서드가 실행되도록 매핑한다.
- 대부분의 속성을 `배열[]` 로 제공하므로 다중 설정이 가능하다.
	- `{"/hello-basic", "/hello-go"}`
- **둘다 허용 - 스프링 부트 3.0 이전**
	- 다음 두가지 요청은 다른 URL이지만, 스프링은 다음 URL 요청들을 같은 요청으로 매핑한다.
		- 매핑: `/hello-basic`
		- URL 요청: `/hello-basic` , `/hello-basic/`
- **둘다 허용 - 스프링 부트 3.0 이후**
	- 스프링 부트 3.0 부터는 `/hello-basic` , `/hello-basic/` 는 서로 다른 URL 요청을 사용해야 한다. 기존에는 마지막에 있는 `/` (slash)를 제거했지만, 스프링 부트 3.0 부터는 마지막의 `/` (slash)를 유지한다. 따라서 다음과 같이 다르게 매핑해서 사용해야 한다.
		- 매핑: `/hello-basic` ▶️ URL요청: `/hello-basic`
		- 매핑: `/hello-basic/` ▶️ URL요청: `/hello-basic/`

### (3) HTTP 메서드
- `@RequestMapping` 에 `method` 속성으로 HTTP 메서드를 지정하지 않으면 HTTP 메서드와 무관하게 호출된다.
	- GET, HEAD, POST, PUT, PATCH, DELETE 모두 허용
#### HTTP 메서드 매핑
```java
/**  
* method 특정 HTTP 메서드 요청만 허용  
* GET, HEAD, POST, PUT, PATCH, DELETE
* */

@RequestMapping(value = "/mapping-get-v1", method = RequestMethod.GET)
public String mappingGetV1() {

 log.info("mappingGetV1");

 return "ok";
}
```
- 만약 여기에 POST 요청을 하면 스프링 MVC는 **HTTP 405 상태코드(Method Not Allowed)를 반환**한다.

#### HTTP 메서드 매핑 축약
```java
/**  
* 편리한 축약 애노테이션 (코드보기)
* @GetMapping  
* @PostMapping  
* @PutMapping  
* @DeleteMapping  
* @PatchMapping  
*/

@GetMapping(value = "/mapping-get-v2")
public String mappingGetV2() {
	log.info("mapping-get-v2");
	return "ok";
}
```
- HTTP 메서드를 축약한 애노테이션을 사용하는 것이 더 직관적이다.
- 코드를 보면 내부에서 `@RequestMapping` 과 `method` 를 지정해서 사용하는 것을 확인할 수 있다.

#### ❗PathVariable(경로 변수) 사용 ❗
```java
/**  
* PathVariable 사용  
* 변수명이 같으면 생략 가능  
* @PathVariable("userId") String userId -> @PathVariable String userId
* */

@GetMapping("/mapping/{userId}")
public String mappingPath(@PathVariable("userId") String data) {
	log.info("mappingPath userId={}", data);
	return "ok";
}
```
- 최근 HTTP API는 다음과 같이 리소스 경로에 식별자를 넣는 스타일을 선호한다.
- `@RequestMapping` 은 URL 경로를 템플릿화 할 수 있는데, `@PathVariable` 을 사용하면 매칭 되는 부분을 편리하게 조회할 수 있다.
- `@PathVariable` 의 이름과 파라미터 이름이 같으면 생략할 수 있다.
```java
@GetMapping("/mapping/{userId}")  
public String mappingPath(@PathVariable String userId) {  
    log.info("mappingPath userId={}", userId);  
    return "ok";  
}
```

#### PathVariable 사용 - 다중
```java
@GetMapping("/mapping/users/{userId}/orders/{orderId}")
public String mappingPath(@PathVariable String userId, @PathVariable Long orderId) {
	log.info("mappingPath userId={}, orderId={}", userId, orderId);
	return "ok";
}
```

#### 특정 파라미터 조건 매핑
```java
/**  
* 파라미터로 추가 매핑  
* params="mode",  
* params="!mode"  
* params="mode=debug"  
* params="mode!=debug" (! = )  
* params = {"mode=debug","data=good"}
* */

 @GetMapping(value = "/mapping-param", params = "mode=debug")
 public String mappingParam() {
     log.info("mappingParam");
     return "ok";
 }
```
- 실행
	- http://localhost:8080/mapping-param?mode=debug
- 특정 파라미터가 있거나 없는 조건을 추가할 수 있다. 잘 사용하지는 않는다.

#### 특정 헤더 조건 매핑, 미디어 타입 조건 매핑
- 특정 헤더 조건과 미디어 타입 조건에 대해서도 매핑이 가능하다.

## 4) 요청 매핑 - API 예시
- 회원 관리를 HTTP API로 만든다면 매핑을 어떻게 하는지 알아본다.
	- URL 매핑만

### (1) 회원 관리 API
- 회원 목록 조회 - GET - `/users`
- 회원 등록 - POST - `/users`
- 회원 조회 - GET - `/users/{userId}`
- 회원 수정 - PATCH - `/users/{userId}`
- 회원 삭제 - DELETE - `/users/{userId}`

### (2) 코드 예시
```java
package hello.springmvc.basic.requestmapping;  
  
import org.springframework.web.bind.annotation.*;  
  
@RestController  
@RequestMapping("/mapping/users")  
public class MappingClassController {  
    @GetMapping()  
    public String user() {  
        return "get users";  
    }  
  
    @PostMapping()  
    public String addUser() {  
        return "post user";  
    }  
  
    @GetMapping("/{userId}")  
    public String findUser(@PathVariable String userId) {  
        return "get userId = " + userId;  
    }  
  
    @PatchMapping("/{userId}")  
    public String updateUser(@PathVariable String userId) {  
        return "update userId = " + userId;  
    }  
  
    @DeleteMapping("/{userId}")  
    public String deleteUser(@PathVariable String userId) {  
        return "delete userId = " + userId;  
    }  
}
```
- `@RequestMapping("/mapping/users")`
	- 클래스 레벨에 매핑 정보를 두면 메서드 레벨에서 해당 정보를 조합해서 사용한다.

## 5) HTTP 요청 - 기본, 헤더 조회
- 애노테이션 기반의 스프링 컨트롤러는 다양한 파라미터를 지원한다.
```java
package hello.springmvc.basic.request;  
  
import jakarta.servlet.http.HttpServletRequest;  
import lombok.extern.slf4j.Slf4j;  
import org.springframework.http.HttpMethod;  
import org.springframework.util.MultiValueMap;  
import org.springframework.web.bind.annotation.CookieValue;  
import org.springframework.web.bind.annotation.RequestHeader;  
import org.springframework.web.bind.annotation.RequestMapping;  
import org.springframework.web.bind.annotation.RestController;  
  
import java.util.Locale;  
  
@Slf4j  
@RestController  
public class RequestHeaderController {  
    @RequestMapping("/headers")  
    public String headers(HttpServletRequest request,  
                          HttpServletRequest response,  
                          HttpMethod httpMethod,  
                          Locale locale,  
                          @RequestHeader MultiValueMap<String, String> headerMap,  
                          @RequestHeader("host") String host,  
                          @CookieValue(value = "myCookie", required = false) String cookie) {  
  
        log.info("request={}", request);  
        log.info("response={}", response);  
        log.info("httpMethod={}", httpMethod);  
        log.info("locale={}", locale);  
        log.info("headerMap={}", headerMap);  
        log.info("header host={}", host);  
        log.info("myCookie={}", cookie);  
  
        return "ok";  
    }  
}
```
- `HttpServletRequest`
- `HttpServletResponse`
- `HttpMethod` : HTTP 메서드를 조회한다. `org.springframework.http.HttpMethod`
- `Locale` : Locale 정보를 조회한다.  
- `@RequestHeader MultiValueMap<String, String> headerMap`
	- 모든 HTTP 헤더를 MultiValueMap 형식으로 조회한다.
- `@RequestHeader("host") String host`
	- 특정 HTTP 헤더를 조회한다.
	- 속성
		- 필수 값 여부: `required`
		- 기본 값 속성: `defaultValue`  
- `@CookieValue(value = "myCookie", required = false) String cookie`
	- 특정 쿠키를 조회한다.
	- 속성
		- 필수 값 여부: `required`
		- 기본 값: `defaultValue`
- `MultiValueMap`
	- MAP과 유사한데, 하나의 키에 여러 값을 받을 수 있다.
	- HTTP header, HTTP 쿼리 파라미터와 같이 하나의 키에 여러 값을 받을 때 사용한다.
		- keyA=value1&keyA=value2
- `@Slf4j`
	- 다음 코드를 자동으로 생성해서 로그를 선언해준다. 개발자는 편리하게 `log` 라고 사용하면 된다.
```java
private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(RequestHeaderController.class);
```

## 6) HTTP 요청 파라미터 - 쿼리 파라미터, HTML Form
### (1) HTTP 요청 데이터 조회 - 개요
- 클라이언트에서 서버로 요청 데이터를 전달할 때 주로 다음 3가지 방법을 사용한다.
#### GET - 쿼리 파라미터
- `/url?username=hello&age=20`
- 메시지 바디 없이 URL 쿼리 파라미터에 데이터를 포함해서 전달한다.
- 예) 검색, 필터, 페이징 등에서 많이 사용
#### POST - HTML Form
- content-type: application/x-www-form-urlencoded
- 메시지 바디에 쿼리 파라미터 형식으로 전달한다.
	- `username=hello&age=20`
- 예) 회원 가입, 상품 주문, HTML Form 사용
#### HTTP message body에 데이터 직접 담아서 요청
- HTTP API에서 주로 사용한다.
	- JSON, XML, TEXT
- 데이터 형식을 주로 JSON을 사용한다.
- POST, PUT, PATCH

### (2) 요청 파라미터 - 쿼리 파라미터, HTML Form
- `HttpServletRequest`의 `request.getParameter()`를 사용하면 다음 두 가지 요청 파라미터를 조회할 수 있다.
	- GET - 쿼리 파라미터
		- `http://localhost:8080/request-param?username=hello&age=20`
	- POST - HTML Form
```
POST /request-param ...
content-type: application/x-www-form-urlencoded

username=hello&age=20
```
- 두 방식 모두 형식이 같으므로 구분없이 조회할 수 있다.
- 이것을 **요청 파라미터 (request parameter) 조회**라 한다.

## 7) HTTP 요청 파라미터 - @RequestParam
### (1) `@RequestParam`
```java
@ResponseBody  
@RequestMapping("/request-param-v2")  
public String requestParamV2(  
        @RequestParam("username") String memberName,  
        @RequestParam("age") int memberAge) {  
    log.info("username={}, age={}", username, age);  
    return "ok";  
}
```
- `@RequestParam` : 파라미터 이름으로 바인딩된다.
	- `@RequestParam("username") String memberName`
	- = `request.getParameter("username")`
	- URL 예시 :  `...?usename=test&...`
	- `("username")` 부분을 생략할 수 있는데, 그러려면 파라미터와 변수명이 같아야한다.
	- 또한, `String`, `int`, `Integer` 등 단순 타입이면 `@RequestParam`도 생략할 수 있다.
- `@ResponseBody` : View 조회를 무시하고, HTTP message body에 직접 해당 내용을 입력한다.
	- 해당 코드에서는 `"ok"`

### (2) 필수 파라미터 설정 
- `@RequestParam(required = true)`
	- 기본값이다.
- `@RequestParam(required = false)`
- int에는 null이 들어갈 수 없으므로 Integer를 사용하거나 defaultValue를 설정해줘야한다.
- `""` 는 빈문자로 정상작동한다.

### (3) Map, MultiValueMap
```java
@ResponseBody  
@RequestMapping("/request-param-map")  
public String requestParamMap(@RequestParam Map<String, Object> paramMap) {  
    log.info("username={}, age={}", paramMap.get("username"),  
            paramMap.get("age"));  
    return "ok";  
}
```
- `@RequestParam Map`
	- `Map(key=value)`
- `@RequestParam MultiValueMap`
	- `MultiValueMap(key=[value1, value2, ...] ex) (key=userIds, value=[id1, id2])`
- 파라미터의 값이 1개가 확실하다면 `Map` 을 사용해도 되지만, 그렇지 않다면 `MultiValueMap` 을 사용하자.

## 8) HTTP 요청 파라미터 - `@ModelAttribute`
- 실제 개발 시 요청 파라미터를 받아서 필요한 객체를 만들고 그 객체에 값을 넣어줘야한다.
- 스프링은 해당 과정을 자동화해주는 `@ModelAttribute`가 있다.
```java
@ResponseBody  
@RequestMapping("/model-attrivute-v1")  
public String modelAttributeV1(@ModelAttribute HelloData helloData) {  
    log.info("username={}, age={}", helloData.getUsername(), helloData.getAge());  
    return "ok";  
}
```
- 스프링MVC는 `@ModelAttribute`가 있으면 다음과 같이 실행한다.
	- `HelloData` 객체를 생성한다.
	- 요청 파라미터의 이름으로 `HelloData` 객체의 프로퍼티를 찾는다.
	- 해당 프로퍼티의 setter를 호출해서 파라미터의 값을 입력한다.
### (1) 프로퍼티
- 객체에 `getUsername()`, `setUsername()` 메서드가 있으면, 해당 객체는 `username`이라는 프로퍼티를 가지고 있다.
- `username` 프로퍼티 값을 변경하면  `setUsername()`이 호출되고, 조회하면 `getUsername()`이 호출된다.

### (2) 바인딩 오류
- `age=abc` 처럼 숫자가 들어가야 할 곳에 문자를 넣으면 `BindException`이 발생한다.

## 9) HTTP 요청 메시지 - 단순 텍스트
- 요청 파라미터와 달리 HTTP message body를 통해 데이터가 직접 넘어오는 경우에는 `@RequestParam`, `@ModelAttribute`를 사용할 수 없다.

### (1) Input, Output 스트림, Reader
```java
@PostMapping("/request-body-string-v2")  
public void requestBodyStringV2(InputStream inputStream, Writer responseWriter)  
        throws IOException {  
    String messageBody = StreamUtils.copyToString(inputStream,  
            StandardCharsets.UTF_8);  
    log.info("messageBody={}", messageBody);  
    responseWriter.write("ok");  
}
```
- InputStream(Reader): HTTP 요청 메시지 바디의 내용을 직접 조회
- OutputStream(Writer): HTTP 응답 메시지의 바디에 직접 결과 출력

### (2) `HttpEntity`
```java
@PostMapping("/request-body-string-v3")
public HttpEntity<String> requestBodyStringV3(HttpEntity<String> httpEntity) {
	String messageBody = httpEntity.getBody();
	log.info("messageBody={}", messageBody);
	return new HttpEntity<>("ok");
}
```
- 스프링 MVC는 다음 파라미터를 지원한다.
	- HttpEntity: HTTP header, body 정보를 편리하게 조회
		- 메시지 바디 정보를 직접 조회
		- 요청 파라미터를 조회하는 기능과 관계 없음
			- 쿼리파라미터 혹은 Form을 통한 POST 외에는 요청 파라미터 조회 X
			- `@RequestParam` X
			- `@ModelAttribute` X
	- HttpEntity는 응답에도 사용 가능
		- 메시지 바디 정보 직접 반환
		- 헤더 정보 포함 가능
		- view 조회 X

- `HttpEntity` 를 상속받은 다음 객체들도 같은 기능을 제공한다.
- **RequestEntity**
	- HttpMethod, url 정보가 추가, 요청에서 사용
- **ResponseEntity**
	- HTTP 상태 코드 설정 가능, 응답에서 사용
	- `return new ResponseEntity<String>("Hello World", responseHeaders, HttpStatus.CREATED)`

### (3) `@RequestBody`
```java
@ResponseBody
@PostMapping("/request-body-string-v4")
	public String requestBodyStringV4(@RequestBody String messageBody) {

	log.info("messageBody={}", messageBody);

	return "ok";
}
```
- @RequestBody
	- `@RequestBody` 를 사용하면 HTTP 메시지 바디 정보를 편리하게 조회할 수 있다.
	- 참고로 헤더 정보가 필요하다면 `HttpEntity` 를 사용하거나 `@RequestHeader` 를 사용하면 된다.
	- 메시지 바디를 직접 조회하는 기능은 요청 파라미터를 조회하는 `@RequestParam` , `@ModelAttribute` 와 전혀 관계가 없다.
- @ResponseBody
	- `@ResponseBody` 를 사용하면 응답 결과를 HTTP 메시지 바디에 직접 담아서 전달할 수 있다.
	- 물론 이 경우에도 view를 사용하지 않는다.
- 요청 파라미터 vs HTTP 메시지 바디
	- 요청 파라미터를 조회하는 기능: `@RequestParam` , `@ModelAttribute`
	- HTTP 메시지 바디를 직접 조회하는 기능: `@RequestBody`

## 10) HTTP 요청 메시지 - JSON
### (1) `@RequestBody`
```java
@Slf4j  
@Controller  
public class RequestBodyJsonController {  
    @ResponseBody  
    @PostMapping("/request-body-json-v3")  
    public String requestBodyJsonV3(@RequestBody HelloData data) {  
        log.info("username={}, age={}", data.getUsername(), data.getAge());  
        return "ok";  
    }  
}
```
- @RequestBody 객체 파라미터
	- `@RequestBody HelloData data`
	- `@RequestBody` 에 직접 만든 객체를 지정할 수 있다.
- `HttpEntity` , `@RequestBody` 를 사용하면 HTTP 메시지 컨버터가 HTTP 메시지 바디의 내용을 우리가 원하는 문자나 객체 등으로 변환해준다.
- HTTP 메시지 컨버터는 문자 뿐만 아니라 JSON도 객체로 변환해준다.
- `HttpEntity`로도 처리가 가능하다.

### (2) `@ResponseBody`
```java
@ResponseBody
@PostMapping("/request-body-json-v5")
	public HelloData requestBodyJsonV5(@RequestBody HelloData data) {

	log.info("username={}, age={}", data.getUsername(), data.getAge());

	return data;
}
```
- `@ResponseBody`
	- 응답의 경우에도 `@ResponseBody` 를 사용하면 해당 객체를 HTTP 메시지 바디에 직접 넣어줄 수 있다.
	- 이 경우에도 `HttpEntity` 를 사용해도 된다.
- `@RequestBody` 요청
	- JSON 요청 ▶️ HTTP 메시지 컨버터 ▶️ 객체
- `@ResponseBody` 응답
	- 객체 ▶️ HTTP 메시지 컨버터 ▶️ JSON 응답

## 11) 응답 - 정적 리소스, 뷰 템플릿
- 스프링(서버)에서 응답 데이터를 만드는 방법은 크게 3가지이다.
- 정적 리소스
	- 예) 웹 브라우저에 정적인 HTML, css, js를 제공할 때는, **정적 리소스**를 사용한다.
- 뷰 템플릿 사용
	- 예) 웹 브라우저에 동적인 HTML을 제공할 때는 뷰 템플릿을 사용한다.
- HTTP 메시지 사용
	- HTTP API를 제공하는 경우에는 HTML이 아니라 데이터를 전달해야 하므로, HTTP 메시지 바디에 JSON 같은 형식으로 데이터를 실어 보낸다.

### (1) 정적 리소스
- 스프링 부트는 클래스패스 다음 디렉토리에 있는 정적 리소스를 제공한다.
	- `/static` , `/public` , `/resources` ,`/META-INF/resources`
- `src/main/resources` 는 리소스를 보관하는 곳이고, 또 클래스패스의 시작 경로이다.
#### 정적 리소스 경로
- `src/main/resources/static`
	- 다음 경로에 파일이 있으면 
		- `src/main/resources/static/basic/hello-form.html`
	- 다음과 같이 실행하면 된다.
		- `http://localhost:8080/basic/hello-form.html`

### (2) 뷰 템플릿
- 뷰 템플릿을 거쳐서 HTML이 생성되고, 뷰가 응답을 만들어서 전달한다.
- 일반적으로 HTML을 동적으로 생성하는 용도로 사용하지만, 다른 것들도 가능하다.
- 뷰 템플릿이 만들 수 있는 것이라면 뭐든지 가능하다.

#### 뷰 템플릿 경로
- `src/main/resources/templates`

### (3) HTTP 메시지
- `@ResponseBody` , `HttpEntity` 를 사용하면, 뷰 템플릿을 사용하는 것이 아니라, HTTP 메시지 바디에 직접 응답 데이터를 출력할 수 있다.

## 12) HTTP 메시지 컨버터
- 뷰 템플릿으로 HTML을 생성해서 응답하는게 아니라 HTTP API처럼 JSON 데이터를 HTTP 메시지 바디에 직접 읽거나 쓰는 경우 HTTP 메시지 컨버터를 사용하면 편하다.

### (1) `@ResponseBody` 사용 원리
![@ResponseBody 사용 원리](/media/Spring/개념%20강의%20정리/김영한/스프링%20MVC%201편%20-%20백엔드%20웹%20개발%20핵심%20기술/6/@ResponseBody%20사용%20원리.svg)
- `@ReponseBody` 사용
	- HTTP의 BODY에 문자 내용을 직접 반환한다.
	- `viewResolver`가 아니라 `HttpMessageConverter`가 동작한다.
	- 기본 문자처리 : `StringHttpMessageConverter`
	- 기본 객체처리 : `MappingJackson2HttpMessageConverter`
	- byte 처리 등 기타 여러 `HttpMessageConverter`가 기본으로 등록되어 있다.
- 스프링 MVC는 다음의 경우에 HTTP 메시지 컨버터를 적용한다.
	- HTTP 요청: `@RequestBody` , `HttpEntity(RequestEntity)`
	- HTTP 응답: `@ResponseBody` , `HttpEntity(ResponseEntity)`

### (1) HTTP 요청 데이터 읽기
1. HTTP 요청이 오고, 컨트롤러에서 `@RequestBody` , `HttpEntity` 파라미터를 사용한다.
2. 메시지 컨버터가 메시지를 읽을 수 있는지 확인하기 위해 `canRead()` 를 호출한다.
	- 대상 클래스 타입을 지원하는가.
		- 예) `@RequestBody` 의 대상 클래스 ( `byte[]` , `String` , `HelloData` )
	- HTTP 요청의 Content-Type 미디어 타입을 지원하는가.
		- 예) `text/plain` , `application/json` , `*/*`
3. `canRead()` 조건을 만족하면 `read()` 를 호출해서 객체 생성하고, 반환한다.

### (2) HTTP 응답 데이터 생성
1. 컨트롤러에서 `@ResponseBody` , `HttpEntity` 로 값이 반환된다.
2. 메시지 컨버터가 메시지를 쓸 수 있는지 확인하기 위해 `canWrite()` 를 호출한다.
	- 대상 클래스 타입을 지원하는가.
		- 예) return의 대상 클래스 ( `byte[]` , `String` , `HelloData` )
	- HTTP 요청의 Accept 미디어 타입을 지원하는가.(더 정확히는 `@RequestMapping` 의 `produces` )
		- 예) `text/plain` , `application/json` , `*/*`
3. `canWrite()` 조건을 만족하면 `write()` 를 호출해서 HTTP 응답 메시지 바디에 데이터를 생성한다.

## 13) 요청 매핑 핸들러 어댑터 구조
- HTTP 메시지 컨버터는 애노테이션 기반의 컨트롤러인 `@RequestMapping`을 처리하는 핸들러 어댑터인 `RequestMappingHandlerAdapter` 요청 매핑 헨들러 어댑터와 관련 있다.
- 요청의 경우
	- `@RequestBody` 를 처리하는 `ArgumentResolver` 가 있고, `HttpEntity` 를 처리하는 `ArgumentResolver` 가 있다.
	- 이 `ArgumentResolver` 들이 HTTP 메시지 컨버터를 사용해서 필요한 객체를 생성 하는 것이다.
- 응답의 경우
	- `@ResponseBody` 와 `HttpEntity` 를 처리하는 `ReturnValueHandler` 가 있다.
	- 그리고 여기에서 HTTP 메시지 컨버터를 호출해서 응답 결과를 만든다.