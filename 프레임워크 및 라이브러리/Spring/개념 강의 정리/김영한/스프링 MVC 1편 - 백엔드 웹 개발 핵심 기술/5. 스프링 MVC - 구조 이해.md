## 1) 스프링 MVC 전체 구조
![SpringMVC 구조](/media/Spring/개념%20강의%20정리/김영한/스프링%20MVC%201편%20-%20백엔드%20웹%20개발%20핵심%20기술/5/SpringMVC%20구조.svg)
- 직접 만든 프레임워크 ▶️ 스프링 MVC 비교
	- `FrontController` ▶️ `DispatcherServlet`
	- `handlerMappringMap` ▶️ `HandlerMapping`
	- `MyHandlerAdapter` ▶️ `HandlerAdapter`
	- `ModelView` ▶️ `ModelAndView`
	- `viewResolver` ▶️`ViewResolver`
	- `MyView` ▶️ `View`

### (1) `DispatcherServlet` 구조 살펴보기
- `org.springframework.web.servlet.DispatcherServlet`
	- 스프링 MVC도 프론트 컨트롤러 패턴으로 구현되어 있다.
	- 스프링 MVC의 프론트 컨트롤러가 디스패처 서블릿(`DispatcherServlet`)이다.
	- 스프링 MVC의 핵심이라고 할 수 있다.

#### `DispatcherServlet` 서블릿 등록하기
- `DispatcherServlet` 도 부모 클래스에서 `HttpServlet`을 상속받아 사용하고, 서블릿으로 동작한다.
	- `DispatcherServlet` ▶️ `FrameworkServlet` ▶️ `HttpServletBean` ▶️ `HttpServlet`
- 스프링 부트는 `DispatcherServlet`을 서블릿으로 자동등록하면서 **모든 경로**(`urlPatterns="/"`)에 대해서 매핑한다.
	- 더 자세한 경로 우선순위가 높다.
#### 요청 흐름
1. 서블릿이 호출되면 `HttpServlet`이 제공하는 `service()`가 호출된다.
2. 스프링 MVC는 `DispatcherServlet`의 부모인 `FrameworkServlet`에서 `service()`를 오버라이딩 해두었다.
3. `FrameworkServlet.service()`를 시작으로 여러 메서드가 호출되면서 `DispatcherServlet.doDispatch()` 가 호출된다.
	- `doDispatch()` 가 가장 중요한 기능을 담당한다.

#### `doDispatch()` 에 대해 알아보기
- 
```java
코드
```


### (2) SpringMVC 구조
![SpringMVC 구조](/media/Spring/개념%20강의%20정리/김영한/스프링%20MVC%201편%20-%20백엔드%20웹%20개발%20핵심%20기술/5/SpringMVC%20구조.svg)
#### 동작 순서
1. **핸들러 조회** : 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 조회한다.
2. **핸들러 어댑터 조회** : 핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다.
3. **핸들러 어댑터 실행** : 핸들러 어댑터를 실행한다.
4. **핸들러 실행** : 핸들러 어댑터가 실제 핸들러를 실행한다.
5. **ModelAndView 반환** : 핸들러 어댑터는 핸들러가 반환하는 정보를 `ModelAndView`로 변환해서 반환한다.
6. **viewResolver 호출** : 뷰 리졸버를 찾고 실행한다.
	1. JSP의 경우 : `InternalResourceViewResolver`가 자동 등록되고 사용된다.
7. **View 반환** : 뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 바꾸고, 렌더링 역할을 담당하는 뷰 객체를 반환한다.
	1. JSP의 경우 : `InternalResourceView(JstlView)`를 반환하는데, 내부에 `forward()` 로직이 있다.
8. **뷰 렌더링** : 뷰를 통해서 뷰를 렌더링 한다.

#### 인터페이스 살펴보기
- 스프링 MVC의 `DispatcherServlet` 코드의 변경 없이, 원하는 기능을 변경하거나 확장이 가능하다.
- 해당 인터페이스들만 구현해서 `DispatcherServlet`에 등록하면 자신만의 컨트롤러를 만들 수 있다.

#### 주요 인터페이스 목록
- 핸들러 매핑 : `org.springframework.web.servlet.HandlerMapping`
- 핸들러 어댑터 : `org.springframework.web.servlet.HandlerAdapter`
- 뷰 리졸버 : `org.springframework.web.servlet.ViewResolver`
- 뷰 : `org.springframework.web.servlet.View`

## 2) 스프링 MVC - 구조 이해하기
- 스프링이 제공하는 컨트롤러는 애노테이션 기반으로 동작해서 유연하고 실용적이다.

### `@RequestMapping`
- 스프링은 애노테이션을 이용해서 유연하고 실용적인 컨트롤러를 만들었는데, 바로 `@RequestMapping` 애노테이션을 사용하는 컨트롤러이다.
	- `RequestMappingHandlerMapping`
	- `RequestMappingHandlerAdapter`
		- 실무에서는 대부분 해당 애노테이션 기반의 컨트롤러를 사용한다.

```java
package hello.servlet.web.springvmc.v1;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

@Controller
public class SpringMemberFormControllerV1 {
	@RequestMapping("/springmvc/v1/members/new-form")
	public ModelAndView process() {
		return new ModelAndView("new-form");
	}
}
```
- `@Controller`
	- 스프링이 자동으로 스프링 빈으로 등록한다.
		- 내부에 `@Component` 애노테이션이 있어서 컴포넌트 스캔의 대상이 된다.
	- 스프링 MVC에서 애노테이션 기반 컨트롤러로 인식한다.
- `@RequestMapping`
	- 요청 정보를 매핑한다.
	- 해당 URL이 호출되면 해당 메서드가 호출된다.
	- 애노테이션을 기반으로 동작하기 때문에 메서드의 이름은 임의로 지으면 된다.
- `ModelAndView`
	- 모델과 뷰 정보를 담아서 반환하면 된다.

#### RequestMappingHandlerMapping
- 스프링 빈 중에서 `@RequestMapping` 또는 `@Controller`가 클래스 레벨에 붙어 있는 경우에 매핑 정보로 인식한다.
- 아래 두 가지 코드도 동일하게 동작한다.
```java
@Component // 컴포넌트 스캔을 통해 스프링 빈으로 등록
@RequestMapping
public class SpringMemberFormControllerV1 {
	@RequestMapping("/springmvc/v1/members/new-form")
	public ModelAndView process() {
		return new ModelAndView("new-form");
	}
}
```
```java
@RequestMapping // 직접 스프링 빈으로 등록
public class SpriongMemberFormControllerV1 {
	@RequestMapping("/springmvc/v1/members/new-form")
	public ModelAndView process() {
		return new ModelAndView("new-form");
	}
}
```

#### 주의 사항! 스프링 3.0 이상
- 스프링부트 3.0(스프링 프레임워크 6.0) 이상은 클래스 레벨에 `@RequestMapping`이 있어도 스프링 컨트롤러로 인식하지 않는다.
- 오직 `@Controller`가 있어야 스프링 컨트롤러로 인식한다.
	- `@RestController`는 해당 애노테이션 내부에 `@Controller`를 포함하므로 인식된다.

## 3) 스프링 MVC - 컨트롤러 통합
- `@RequestMapping`은 클래스 단위가 아니라 메서드 단위에도 적용된다.
- 그러므로 컨트롤러 클래스를 유연하게 하나로 통합할 수 있다.

### 컨트롤러 조합 결과
- 클래스 레벨 `@RequestMapping("/springmvc/v2/members)"`
	- 메서드 레벨 `@RequestMapping("/new-form")` ▶️ `/springmvc/v2/members/newform`
	- 메서드 레벨 `@RequestMapping("/save")` ▶️ `/springmvc/v2/members/save`
	- 메서드 레벨 `@RequestMapping` ▶️ `/springmvc/v2/members`

## 4) 스프링 MVC - 실용적인 방식

```java
/*
* v3
* Model 도입
* ViewName 직접 반환
* @RequestParam 사용
* @RequestMapping -> @GetMapping, @PostMapping
*/

@Controller
@ReqeustMapping("/springmvc/v3/members")
public class SpringMemberControllerV3 {
	private MemberRepository memberRepository = MemberRepository.getInstance();

	@GetMapping("/new-form")
	public String newForm() {
		return "new-Form()";
	}

	@PostMapping("/save")
	public String save(
		@RequestParam("username") String username,
		@RequestParam("age") int age,
		Medel model) {

			Member member = new Member(username, age);
			memberRepository.save(member);

			model.addAttribute("member", member);
			return "save-result";
	}

	@GetMapping
	public String members(Model model) {
		List<Member> members = memberRepository.findAll();
		model.addAttribute("members", members);
		return "members";
	}
}
```

### (1) Model 파라미터
- `save()`, `members()` 에서 Model을 파라미터로 받는 것을 확인 가능하다.
- 스프링 MVC에서 이런 편의 기능을 제공하고 있다.

### (2) ViewName 직접 반환
- 뷰의 논리 이름을 반환할 수 있다.

### (3) `@RequestParam` 사용
- 스프링은 HTTP 요청 파라미터를 `@RequestParam`으로 받을 수 있다.
- `@RequestParam("username")` 은 `request.getParameter("username")`와 거의 같은 코드이다.
- GET 쿼리 파라미터, POST form 방식 모두 지원한다.

### (4) @RequestMapping ▶️ @GetMapping, @PostMapping
- `@RequestMapping` 은 URL 매칭만 아니라 HTTP Method도 함께 구분할 수 있다.
	- `@RequestMapping(value = "/new-form", method = RequestMethod.GET)`
		- URL이 `/new-form`이고, HTTP Method가 GET인 경우이다.
- 이것은 `@GetMapping`, `@PostMapping`으로 편리하게 사용 가능하다.
	- Get, Post, Put, Delete, Patch 모두 애노테이션이 있다.
	- `@GetMapping` 를 살펴보면 `@RequestMapping` 애노테이션을 내부에 가지고 있다.