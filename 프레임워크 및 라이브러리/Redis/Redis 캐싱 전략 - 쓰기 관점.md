# 5. Redis 캐싱 전략 - 쓰기 관점
## 5.1 Write-Through 패턴
데이터와 캐시를 둘 다 DB에 동시 저장한다. 항상 레디스에서 DB와 동기화되어 있어서 데이터 일관성이 유지된다.
사용 시 Look Aside 패턴과 혼용해서 사용된다.


데이터 쓰기 작업을 할 때 관점에서 접근하는 아키텍처이다.

1. 애플리케이션이 데이터를 **쓰기** 요청함.
2. **캐시**에 먼저 쓰고, 동시에 **데이터베이스**에도 즉시 데이터를 기록함.
3. 데이터는 항상 최신 상태로 캐시와 데이터베이스에 동기화됨.

이 아키텍처의 장단점은 아래와 같다.

- 장점
	- 레디스 서버 내 캐시 데이터가 항상 최신 상태를 유지한다.
	- 읽기 작업 시 오버헤드가 적다.
- 단점
	- 사용하지 않는 캐시 데이터 생성 가능성이 있다.
	- 쓰기 작업 시 데이터베이스와 캐시에 모두 쓰기를 해야 하므로 오버헤드가 크다.

Write-Through 패턴은 쓰기 작업 시 지연 시간이 다소 증가해도 괜찮은 경우에 효과적이다. 하지만 데이터베이스가 변경될 때마다 Redis 서버에 쓰기 작업을 수행하므로 사용하지 않는 데이터가 저장될 수 있다.

## 5.2 Write-Back 패턴
조회 용도 보다는 지속적으로 DB에 대한 업데이트를 하기 위해서 인메모리 형식으로 레디스에 데이터를 저장하고 있다가 일정 데이터를 주기적으로 조회를 하고 DB에 Bulk해주는 전략이다.
대표적으로 좋아요 같은 경우가 있다. 해당 요청에 대해서 레디스를 통해서 처리하면 하나의 커넥션을 유지하면서 Bulk-Write 처리하기 때문에 데이터베이스 업데이트를 더 효율적으로 처리할 수 있다.
해당 방식이 인메모리 DB로 활용되는 대표적인 예시이다.

해당 패턴은 캐시에 저장 후, 일정 시간이 지연되면 데이터베이스를 비동기 방식으로 주기적인 업데이트를 하는 방식이다. 데이터베이스가 RDBMS인 경우, 데이터를 영구적으로 저장하는 시점에 정규화하여 테이블에 저장한다.

1. 애플리케이션이 데이터를 **쓰기** 요청함.
2. **캐시에만** 데이터를 먼저 쓰고, 데이터베이스에는 나중에 비동기적으로 쓰기를 수행함.
3. 캐시와 데이터베이스의 동기화는 **일정한 주기**나 **조건**에 따라 이루어짐.

Write-Back 패턴은 지연 읽기나 Write-Through 패턴과 같은 아키텍처에서 쓰기/읽기 작업 시 발생하는 오버헤드를 줄일 수 있어 쓰기 작업을 빠르게 처리할 수 있다. 하지만 그 사이, 레디스에 문제가 발생하는 경우 데이터 손실 위험이 있기 때문에 애플리케이션의 특성, 데이터의 특성, 복구 방법 등을 사전에 충분히 검토해야 합니다. 즉, Write-Back 패턴은 성능을 우선하지만 데이터 손실이 발생하는 상황을 가정해도 큰 문제없는 최악의 경우에 고려하는 패턴이다. 복구할 때는 사전에 계획적으로 생성한 스냅숏으로 데이터를 복워한다. 스냅숏 생성 이후에 저장된 데이터는 AOF를 사용하여 디스크에 플러시하지 않은 경우에는 손실을 감수해야 할 수도 있습니다.

- 장점
	- 레디스 서버 내의 캐시 데이터가 항상 최신 상태를 유지할 수 있다.
	- 쓰기 작업을 빠르게 처리할 수 있다.
- 단점
	- 일관성 문제가 발생할 수 있음
		- 데이터베이스에 쓰기 작업이 지연되므로, 캐시와 데이터베이스 간에 데이터 불일치가 발생할 수 있음.
	- 데이터 손실 위험이 높다.
		- 캐시에 저장된 데이터가 데이터베이스로 기록되기 전에 캐시 서버에 장애가 발생하면 데이터 손실 가능성이 있음.

## 5.3 Write-Around 패턴


## 5.4 패턴 비교
| **특징**        | **Write-Through**           | **Write-Back** (Write-Behind) | **Write-Around**            |
| ------------- | --------------------------- | ----------------------------- | --------------------------- |
| **캐시에 쓰기**    | 캐시와 DB에 동시에 기록              | 캐시에 먼저 쓰고, 나중에 비동기적으로 DB에 기록  | 캐시에 기록하지 않음                 |
| **DB에 쓰기**    | 캐시와 동시에 쓰기                  | 비동기적으로 나중에 기록                 | 직접 DB에만 기록                  |
| **읽기 성능**     | 항상 최신 데이터 반환                | 캐시에서 최신 데이터 반환, 빠름            | 캐시 미스 시 성능 저하 가능            |
| **쓰기 성능**     | 캐시와 DB 모두 기록하므로 쓰기 성능 저하 가능 | 빠름 (캐시에만 먼저 기록)               | 빠름 (캐시에 쓰지 않음)              |
| **데이터 일관성**   | 일관성 높음 (캐시와 DB 동기화됨)        | 일관성 낮음 (캐시와 DB 불일치 가능성 있음)    | 일관성 유지 (DB에만 기록하므로 일관성 유지됨) |
| **캐시 미스 발생**  | 거의 없음                       | 거의 없음                         | 빈번히 발생할 수 있음                |
| **데이터 손실 위험** | 없음                          | 캐시에서 DB로 기록 전 손실 가능성 있음       | 없음                          |

## 5.5 각 패턴의 적합한 사용 사례
- **Write-Through**:
    - **일관성**이 중요한 시스템에서 사용됨. 데이터가 항상 캐시와 데이터베이스에 동기화되어 있어야 하는 경우 적합.
    - 예: 금융 시스템, 트랜잭션이 중요한 애플리케이션.
- **Write-Back**:
    - **성능**이 중요한 경우에 적합. 쓰기 성능을 극대화해야 하는 경우 사용되며, 데이터 일관성이 아주 엄격하지 않은 시스템에 사용됨.
    - 예: 소셜 미디어, 비디오 스트리밍 서비스 등.
- **Write-Around**:
    - **읽기 빈도가 낮고 쓰기 빈도가 높은 경우**에 적합. 데이터를 직접 DB에 쓰고, 필요한 경우에만 캐시에 로드하는 전략.
    - 예: 로그 기록 시스템, 데이터 변경이 빈번하지만 일부 데이터만 자주 조회되는 시스템.
