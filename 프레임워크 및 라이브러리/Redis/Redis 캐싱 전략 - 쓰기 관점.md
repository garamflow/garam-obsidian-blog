# 5. Redis 캐싱 전략 - 쓰기 관점
## 5.1 Write-Through 패턴
Write-Through 패턴은 데이터 쓰기 작업에서 **데이터 일관성을 유지**하기 위해 사용되는 캐싱 전략입니다. 이 패턴의 특징은 **데이터를 캐시에 먼저 쓰고, 동시에 데이터베이스에도 즉시 쓰는** 방식입니다. 이로 인해 캐시와 데이터베이스의 **동기화가 보장**되며, 읽기 작업 시 항상 최신 데이터를 반환할 수 있습니다.

### 5.1.1 작동 방식
1. **쓰기 요청**: 애플리케이션이 데이터를 쓰기 요청합니다.
2. **캐시에 쓰기**: 요청된 데이터를 Redis 캐시에 먼저 기록합니다.
3. **데이터베이스에 쓰기**: 동일한 데이터를 동시에 데이터베이스에도 기록합니다.
4. 결과적으로, 캐시와 데이터베이스가 항상 최신 상태를 유지하게 됩니다.

### 5.1.2 장점
- **항상 최신 데이터 유지**: 캐시에 저장된 데이터는 항상 최신 상태이며, 데이터베이스와 동기화가 되어 있습니다. 따라서 읽기 요청 시 최신 데이터를 반환할 수 있습니다.
- **읽기 성능 향상**: 데이터를 매번 데이터베이스에서 읽지 않고, 캐시에서 바로 읽을 수 있으므로 읽기 작업 시 성능이 크게 향상됩니다.

### 5.1.3 단점
- **쓰기 오버헤드 증가**: 모든 쓰기 작업에서 캐시와 데이터베이스에 동시에 쓰기를 해야 하기 때문에, 쓰기 작업의 성능이 저하될 수 있습니다. 특히 쓰기 빈도가 높은 애플리케이션에서는 지연 시간이 증가할 수 있습니다.
- **불필요한 캐시 데이터**: 사용하지 않는 데이터도 캐시에 저장될 수 있습니다. 예를 들어, 데이터를 쓰기만 하고 조회하지 않는 경우, 캐시에 저장된 데이터는 쓸모없는 자원을 차지하게 됩니다.

### 5.1.4 사용 사례
- **일관성이 중요한 시스템**: 금융 시스템이나 재고 관리 시스템처럼 데이터 일관성이 매우 중요한 경우, Write-Through 패턴이 적합합니다. 데이터를 캐시와 데이터베이스에 즉시 동기화하기 때문에 항상 최신 데이터를 사용할 수 있습니다.
- **쓰기 빈도가 낮고, 읽기 빈도가 높은 경우**: 쓰기 작업이 자주 발생하지 않지만, 읽기 작업이 많은 경우 Write-Through 패턴을 통해 데이터베이스의 부하를 줄일 수 있습니다.

### 5.1.5 주의사항 및 개선점
- **불필요한 캐시 사용을 줄이는 전략**: 쓰기 작업에서 캐시에 저장되었지만 읽히지 않는 데이터가 많아지는 것을 방지하기 위해, TTL(Time to Live)을 설정하거나 LRU(Least Recently Used) 정책을 적용하여 자주 사용되지 않는 데이터를 캐시에서 자동으로 제거할 수 있습니다.
- **쓰기 작업의 지연 시간 최적화**: 쓰기 작업의 지연 시간을 최소화하기 위해, 비동기 처리를 통해 캐시에 먼저 쓰고, 데이터베이스 쓰기는 비동기적으로 처리하는 방법도 고려할 수 있습니다. 그러나 이 경우 일관성 문제가 발생할 수 있으므로 주의해야 합니다.

## 5.2 Write-Back 패턴
Write-Back 패턴은 데이터 쓰기 작업을 **성능 우선**으로 처리하는 캐싱 전략입니다. 이 패턴에서는 **캐시에 데이터를 먼저 쓰고**, **데이터베이스에는 비동기적으로 주기적인 업데이트를 수행**합니다. 즉, 데이터를 쓰는 순간에 즉시 데이터베이스에 기록하지 않고, 일정 시간이 지난 후에 Batch 또는 Bulk 형식으로 데이터베이스에 반영합니다.

이 패턴은 **조회보다 지속적인 업데이트**가 이루어지는 시스템에서 사용되며, 대표적인 예시로 "좋아요"와 같은 빈번한 업데이트가 요구되는 기능이 있습니다. 이러한 시스템에서 레디스를 통해 데이터베이스에 Bulk-Write 처리를 하여, 쓰기 성능을 극대화할 수 있습니다.

### 5.2.1 작동 방식
1. **쓰기 요청**: 애플리케이션이 데이터를 쓰기 요청합니다.
2. **캐시에 쓰기**: 요청된 데이터를 Redis 캐시에 먼저 저장합니다.
3. **비동기 쓰기**: 캐시에 저장된 데이터는 주기적으로 또는 조건이 충족될 때 비동기적으로 데이터베이스에 기록됩니다. 데이터베이스는 한 번에 Bulk Write를 수행하여, 효율적으로 데이터를 처리합니다.
4. **데이터베이스에 동기화**: 캐시와 데이터베이스 간의 동기화는 일정한 주기 또는 특정 조건에 따라 이루어집니다.

### 5.2.2 장점
- **빠른 쓰기 처리**: 애플리케이션에서 쓰기 작업을 캐시에 먼저 저장하므로, 쓰기 작업의 지연 시간이 매우 짧습니다. 데이터베이스에 즉시 쓰는 Write-Through 패턴에 비해 쓰기 속도가 훨씬 빠릅니다.
- **Batch 처리로 성능 향상**: 데이터를 Bulk로 처리하기 때문에, 데이터베이스에 대한 부하를 줄이고 성능을 극대화할 수 있습니다. Cron 작업을 이용해 일정 시간마다 데이터를 저장하거나, 특정 조건을 만족할 때 데이터를 데이터베이스에 반영할 수 있습니다.
- **캐시 서버의 효율적 활용**: 데이터베이스에 즉시 쓰지 않고 캐시에 저장해두므로, 많은 쓰기 작업을 캐시에서 처리할 수 있습니다.

### 5.2.3 단점
- **데이터 일관성 문제**: 데이터가 캐시에만 저장되어 있고 데이터베이스에 즉시 반영되지 않으므로, 일관성 문제가 발생할 수 있습니다. 예를 들어, 캐시와 데이터베이스 간에 동기화가 이루어지기 전에 데이터를 읽는다면, 불일치가 발생할 수 있습니다.
- **데이터 손실 위험**: 캐시에만 데이터를 저장하고 있으므로, 캐시 서버에 장애가 발생하면 데이터베이스에 쓰여지지 않은 데이터 손실이 발생할 수 있습니다. 특히, Redis와 같은 인메모리 캐시는 장애 발생 시 메모리에 저장된 데이터가 사라질 위험이 큽니다.
- **복구 복잡성**: Write-Back 패턴에서는 Redis에 저장된 데이터를 주기적으로 스냅숏(Snapshot)으로 생성하고, 장애 시 복구 전략이 필요합니다. 스냅숏 생성 이후의 데이터는 손실될 가능성이 있기 때문에, 추가적으로 AOF(Append Only File)와 같은 로그 기반 복구 방식을 사용하여 데이터를 복구할 수 있습니다. 하지만, 이러한 복구 절차가 복잡할 수 있습니다.

### 5.2.4 Write-Back 패턴의 사용 사례
- 좋아요 기능: 빈번한 업데이트가 발생하는 '좋아요' 기능과 같은 경우, Write-Back 패턴을 사용하여 빠르게 데이터를 캐시에 저장한 후, 일정 주기마다 데이터베이스에 반영하는 방식이 적합합니다.
- 로그 처리: 대량의 로그 데이터를 Redis에 저장한 후, 주기적으로 데이터베이스에 Batch Write를 수행하는 방식에서 사용될 수 있습니다.
- 상태 데이터: 게임 서버에서의 플레이어 상태, 임시 결과 저장과 같은 빈번한 쓰기 작업을 캐시에 처리하고, 주기적으로 영구 저장소에 반영하는 방식으로 활용할 수 있습니다.

### 5.2.5 주의 사항 및 개선점
- **TTL 설정**: 일관성 문제를 줄이기 위해, 캐시 데이터에 TTL(Time to Live)을 설정할 수 있습니다. 이를 통해 일정 시간이 지나면 데이터가 자동으로 만료되며, 주기적으로 데이터를 데이터베이스에 반영하여 일관성을 유지할 수 있습니다.
- **데이터 복구 전략**: 데이터 손실을 방지하기 위해, Redis의 AOF(Append Only File) 기능을 통해, 모든 쓰기 작업을 로그로 기록하고, 장애 발생 시 복구할 수 있는 시스템을 구축할 수 있습니다.
- **분산 락**: 쓰기 작업이 동시에 여러 클라이언트에서 발생하는 경우, 분산 락을 적용하여 동시성 문제를 해결할 수 있습니다.


## 5.3 Write-Around 패턴


## 5.4 패턴 비교
| **특징**        | **Write-Through**           | **Write-Back** (Write-Behind) | **Write-Around**            |
| ------------- | --------------------------- | ----------------------------- | --------------------------- |
| **캐시에 쓰기**    | 캐시와 DB에 동시에 기록              | 캐시에 먼저 쓰고, 나중에 비동기적으로 DB에 기록  | 캐시에 기록하지 않음                 |
| **DB에 쓰기**    | 캐시와 동시에 쓰기                  | 비동기적으로 나중에 기록                 | 직접 DB에만 기록                  |
| **읽기 성능**     | 항상 최신 데이터 반환                | 캐시에서 최신 데이터 반환, 빠름            | 캐시 미스 시 성능 저하 가능            |
| **쓰기 성능**     | 캐시와 DB 모두 기록하므로 쓰기 성능 저하 가능 | 빠름 (캐시에만 먼저 기록)               | 빠름 (캐시에 쓰지 않음)              |
| **데이터 일관성**   | 일관성 높음 (캐시와 DB 동기화됨)        | 일관성 낮음 (캐시와 DB 불일치 가능성 있음)    | 일관성 유지 (DB에만 기록하므로 일관성 유지됨) |
| **캐시 미스 발생**  | 거의 없음                       | 거의 없음                         | 빈번히 발생할 수 있음                |
| **데이터 손실 위험** | 없음                          | 캐시에서 DB로 기록 전 손실 가능성 있음       | 없음                          |

## 5.5 각 패턴의 적합한 사용 사례
- **Write-Through**:
    - **일관성**이 중요한 시스템에서 사용됨. 데이터가 항상 캐시와 데이터베이스에 동기화되어 있어야 하는 경우 적합.
    - 예: 금융 시스템, 트랜잭션이 중요한 애플리케이션.
- **Write-Back**:
    - **성능**이 중요한 경우에 적합. 쓰기 성능을 극대화해야 하는 경우 사용되며, 데이터 일관성이 아주 엄격하지 않은 시스템에 사용됨.
    - 예: 소셜 미디어, 비디오 스트리밍 서비스 등.
- **Write-Around**:
    - **읽기 빈도가 낮고 쓰기 빈도가 높은 경우**에 적합. 데이터를 직접 DB에 쓰고, 필요한 경우에만 캐시에 로드하는 전략.
    - 예: 로그 기록 시스템, 데이터 변경이 빈번하지만 일부 데이터만 자주 조회되는 시스템.
