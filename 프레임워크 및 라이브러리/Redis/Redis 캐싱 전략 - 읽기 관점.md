# 4. Redis 캐싱 전략 - 읽기 관점
## 4.1 지연 로딩 (Look Aside)
**Look Aside Cache**, 또는 **Lazy Loading** 방식은 캐시를 먼저 확인하고, 캐시에 데이터가 없는 경우 데이터베이스에서 데이터를 가져와 캐시에 저장하는 방식입니다. 이 전략은 읽기 작업에서 **성능 향상**과 **데이터베이스 부하 감소**를 목적으로 합니다. 주로 **일관성이 절대적이지 않은** 데이터에서 유용하게 사용됩니다.

### 4.1.1 작동 방식
1. 클라이언트가 데이터를 요청합니다.
2. Redis 캐시를 먼저 확인합니다.
3. 캐시에 데이터가 없으면(cache miss), 데이터베이스에서 데이터를 가져옵니다.
4. 데이터베이스에서 가져온 데이터를 Redis에 저장하고 클라이언트에 반환합니다.


### 4.1.2 문제점 및 해결방안
#### 1) 데이터 일관성 문제 (캐시와 데이터베이스 간 불일치)
캐시에 저장된 값과 데이터베이스에 저장된 값이 동기화되지 않을 수 있습니다. 데이터베이스의 값이 변경되어도 캐시의 값은 여전히 이전 데이터를 유지할 수 있습니다. 이는 데이터가 빈번하게 갱신되는 경우에 특히 문제가 될 수 있으며, 예를 들어 상품의 재고나 가격 같은 데이터에서는 지연 로딩을 사용하지 않는 것이 좋습니다.
- **해결 방법**:
	- TTL 설정: 캐시에 데이터가 일정 시간이 지나면 자동으로 만료되도록 설정하여, 정기적으로 캐시를 갱신합니다.
	- 데이터베이스 업데이트 시 캐시 무효화: 데이터베이스의 값이 변경될 때, Redis 캐시에서도 해당 데이터를 삭제하거나 갱신하여 일관성을 유지합니다.

#### 2. Thundering Herd 문제
Thundering Herd는 특정 시점에 캐시에 저장된 값이 만료되어, 동시에 많은 요청이 한꺼번에 데이터베이스로 몰리는 현상입니다. 캐시 미스가 발생하면 모든 클라이언트 요청이 데이터베이스에 도달하게 되어, 데이터베이스에 과부하가 발생할 수 있습니다.
- **해결 방법:**
	- 캐시 미리 갱신 (Cache Warming): TTL이 만료되기 전에 캐시를 미리 갱신하는 전략을 사용할 수 있습니다. 캐시된 데이터가 만료되기 직전에 백그라운드에서 미리 갱신하여, Thundering Herd 상황을 방지합니다.
	- 분산 락 사용: Redis의 **SETNX**와 같은 분산 락을 사용하여 캐시 미스 시 여러 요청이 동시에 데이터베이스에 접근하지 않도록 제어할 수 있습니다. 첫 번째 요청만 데이터베이스에서 데이터를 가져오고, 나머지 요청은 그 결과를 기다리게 합니다.

## 4.2 Read-Through 패턴
지연 읽기 패턴의 변형이라고 할 수 있다.
Redis에 데이터를 요청하고 캐시 미스가 발생했을 때 데이터베이스에서 캐시로 데이터를 읽어오는 방식을 사용한다. 차이점이라면 데이터베이스에서 읽어오는 작업을 애플리케이션에서 직접 처리할 필요가 없다는 점이다. 대신 라이브러리 등을 사용해 데이터베이스에서 Redis로 데이터를 읽어오는 과정을 처리한다.

### 4.2.1 작동 방식
1. 클라이언트가 캐시 계층에 데이터를 요청합니다.
2. 캐시 계층이 Redis를 확인합니다.
3. 캐시에 데이터가 없으면, 캐시 계층이 자동으로 데이터베이스에서 데이터를 가져와 Redis에 저장합니다.
4. 캐시 계층이 데이터를 클라이언트에 반환합니다.

## 4.3 주요 차이점
- 구현 위치: 지연 로딩은 주로 애플리케이션 코드에서 구현되고, Read-Through는 별도의 캐시 계층에서 구현됩니다.
- 추상화 수준: Read-Through는 캐시 동작을 더 추상화하여 애플리케이션 로직과 분리합니다.
- 유연성: Read-Through는 캐시 계층에서 더 복잡한 로직을 구현할 수 있어 유연성이 높습니다.

| **특징**        | **지연 로딩(Lazy Loading)**                | **Read-Through**                   |
| ------------- | -------------------------------------- | ---------------------------------- |
| **데이터 조회 방식** | 요청이 있을 때만 캐시에 없는 데이터를 DB에서 로드하고 캐시에 저장 | 캐시에 없으면 자동으로 DB에서 데이터를 조회 후 캐시에 저장 |
| **초기 캐시 상태**  | 초기에는 비어 있음                             | 필요에 따라 캐시가 자동으로 채워짐                |
| **캐시 히트율**    | 사용 빈도가 높은 데이터만 캐시에 저장됨                 | 모든 데이터가 캐시에 저장될 가능성이 있음            |
| **DB 부하**     | 캐시 미스 시에만 DB 접근                        | 캐시 미스 시 DB 접근                      |
| **일관성**       | 캐시와 DB 일관성 문제 발생 가능성 있음                | 캐시와 DB 일관성 유지가 쉬움                  |
| **응답 지연**     | 캐시 미스 시 첫 요청에서 지연 발생 가능                | 캐시 미스 발생 시에도 자동 처리                 |
| **사용 예시**     | 특정 데이터만 빈번하게 조회되는 경우에 적합               | 데이터베이스와 캐시 간 일관성을 쉽게 유지해야 하는 경우 적합 |
### 캐싱 전략 선택 시 고려 사항
- **캐시 일관성**이 중요한 경우: **Read-Through** 패턴이 더 적합합니다.
- **불필요한 데이터 캐시 저장을 피하고 싶은 경우**: **지연 로딩**이 더 효율적입니다.
- **첫 번째 요청의 성능이 중요한 경우**: **Read-Through**가 첫 요청에서도 일관된 성능을 제공합니다.