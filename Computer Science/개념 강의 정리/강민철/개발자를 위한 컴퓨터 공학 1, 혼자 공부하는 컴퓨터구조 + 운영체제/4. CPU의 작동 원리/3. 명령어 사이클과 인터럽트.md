# 명령어 사이클과 인터럽트
- CPU는 메모리로부터 명령어나 데이터들을 갖고와서 실행하거나 저장한다.
- 해당 과정은 일정한 주기, 패턴이 있다. 그런 정해진 흐름을 명령어 사이클이라고 한다.
- 그리고 그 흐름을 끊는 신호를 인터럽트라고 한다.

## 1) 명령어 사이클
- 프로그램 속 명령어들은 일정한 주기가 반복되며 실행하는데, 이 주기를 명령어 사이클이라고 한다.
- 일반적으로 CPU는 인출-실행-인출-실행-... 사이클을 반복한다.

### (1) 인출 사이클
- 가장 먼저 메모리로부터 CPU로 갖고 와야 한다.

### (2) 실행 사이클
- 갖고 왔으면 실행해야 한다.

### (3) 간접 사이클
- CPU로 명령어를 가지고 와도 바로 실행이 불가능한 경우도 있다.
- 메모리 접근이 더 필요한 경우이다.
	- 간접 주소 지정 방식
- 인출-간접-실행-...

## 2) 인터럽트
- 'CPU가 꼭 주목해야 할 때', 'CPU가 얼른 처리해야 할 다른 작업이 생겼을 때' 발생한다.

### (1) 동기 인터럽트 (예외)
- CPU가 예기치 못한 상황을 접했을 때 발생한다.
- 주로 4가지가 있다.
	- 폴트
	- 트랩
	- 중간 (abort)
	- 소프트웨어 인터럽트

### (2) 비동기 입터럽트 (하드웨어 인터럽트)
- 주로 입출력장치에 의해서 발생한다.
- 알림과 같은 역할을 한다.
- 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트를 사용한다.
	- 입출력 장치는 CPU에 비해서 느리다.
	- 인터럽트가 없으면 CPU는 프린트 완료 여부를 확인하기 위해 주기적으로 확인해야 한다.

#### 하드웨어 인터럽트의 처리 순서
- 인터럽트의 종류를 막론하고 인터럽트 처리 순서를 대동소이하다.
1. 입출력장치는 CPU에 **인터럽트 요청 신호**를 보낸다.
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
3. CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작접을 백언한다.
5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행한다.
6. 입터럽트 서비스 루틴 실행이 끝나면 4에 백업해 둔 작업을 복구하여 실행을 재개한다.

#### 인터럽트 요청 신호
- 하드웨어 인터럽트를 보내는 주체인 입출력 장치가 CPU한테 지금 끼어들어도 되냐고 묻는 신호이다.
- CPU가 인터럽트 요청 받아들일려면 플래그 레지스터에서 인터럽트 플래그를 확인해야한다.
	- 모든 인터럽트를 인터럽트 플래그로 막을 수 있는 건 아니다.

#### 인터럽트 플래그
- 인터럽트 요청 신호를 받아들일지 무시할지를 결정하는 비트이다.

#### 하드웨어 인터럽트 종류
- 막을 수 있는 인터럽트 (Maskable Interrupt)
- 막을 수 없는 인터럽트 (Non Maskable Interrupt)

#### 인터럽트 서비스 루틴
- CPU가 인터럽트를 받아들이기로 했다면 인터럽트 서비스 루틴을 실행한다.
- 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하면 되는지 적혀있는 프로그램이다.
- 프로그램이기 때문에 메모리에 저장되있다.

#### 인터럽트 벡터
- 각각의 인터럽트를 구분하기 위한 식별 정보이다.
- 인터럽트마다 고유한 인터럽트 서비스 루틴의 주소를 가지고 있다. 인터럽트 벡터는 해당 서비스 루틴의 시작 주소를 가지고 있다.

#### CPU가 인터럽트를 처리한다.
- = 인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다.
	- 그리고 인터럽트의 시작 주소는 인터럽트 벡터를 통해 알 수 있다.

#### 지금까지 작업했던 내용은 어디에 백업을 할까?
- 스택 영역에 프로그램 카운터부터 메모리 주소 레지스터 값 등을 저장해놓는다.